<!doctype html>
<html lang="en">

<head>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
<meta http-equiv="Content-Security-Policy" content="base-uri 'none'; default-src 'none'; form-action 'none'; frame-src 'self'; img-src 'self'; script-src 'self'; style-src 'self' 'unsafe-inline'">
<title>BPB</title>
<link rel="stylesheet" type="text/css" href="../../../_styles/master.css">
<link rel="stylesheet" type="text/css" href="../../../_styles/document.css">
<link rel="stylesheet" type="text/css" href="../../_styles/notes.css">
<style type="text/css">
td, th {
  white-space: nowrap;
}
table.DiskFormat col.Value {
  text-align: right;
}
table.DiskFormat td + td {
  text-align: right;
}
</style>
<script type="text/javascript" src="../../../_scripts/master.js"></script>
<script type="text/javascript" src="../../../_scripts/document.js"></script>
<script type="text/javascript" src="../../_scripts/notes.js"></script>
</head>

<body>

<!--webbot bot="Include" U-Include="../../_include/noscript.htm" TAG="BODY" startspan -->

<div class="NoScript Header" id="Banner">
  <div id="Links">
    <ul class="LinkList">
      <li> 
      <ul class="PreferNoWrap">
        <li class="LinkListItem"><a href="../../../index.htm">Home</a> </li><!--
     --><li class="LinkListItem"><a target="_self" href="../../toc.htm">Table of Contents</a> </li><!--
     --><li class="LinkListItem"><a href="../../../about/index.htm">About This Site</a> </li>
      </ul>
      <ul class="PreferNoWrap">
        <li class="LinkListItem"><a href="../../../new/index.htm">What’s New?</a> </li><!--
     --><li class="LinkListItem"><a href="../../../feedback/index.htm">Feedback</a> </li><!--
     --><li class="LinkListItem"><a href="../../../consult/index.htm">Consult</a> </li>
      </ul>
      </li>
    </ul>
  </div>
  <div id="Logo">
    <p><span class="PreferNoWrap">Geoff Chappell -</span> <span class="PreferNoWrap">Software Analyst</span> </p>
  </div>
</div>

<!--webbot bot="Include" endspan i-checksum="55207" -->
<div class="Main">
  <!--webbot bot="Include" U-Include="../../_include/preview.htm" TAG="BODY" startspan -->

<div class="Header">
  <p class="alert">CURRENT WORK ITEM - PREVIEW ONLY </p>
</div>

<!--webbot bot="Include" endspan i-checksum="8381" -->
  <h1>BPB </h1>
  <p>The <span class="struct">BPB</span>, standing for BIOS Parameter Block, is 
  the structure through which the DOS kernel is told about a disk drive or about 
  media, i.e., disks, that are accessed through a disk drive. What’s meant by a 
  disk drive in this context is a device for accessing block storage that is organised 
  according to one or another variant of DOS’s built-in File Allocation Table (FAT) 
  file system. The <span class="struct">BPB</span> is specialised to describing 
  the larger-scale features of this organisation—what might nowadays be called the 
  file-system metadata. </p>
  <p>Later versions of the DOS kernel, here meaning 3.20 and higher, expose the
  <span class="struct">BPB</span> to DOS programs through an interface for 
  Generic IOCTL. The kernel is then just a conduit to the relevant block device 
  driver. A program can both learn about a disk drive and its disks and 
  configure their handling by the device driver. This was a necessary, and 
  arguably too-long delayed, step towards standardising tools that work with 
  disks for more than file I/O, especially the FORMAT program. </p>
  <p>Inevitably, the <span class="struct">BPB</span> is used in other circumstances 
  that can benefit from the same or similar description. Most notable is that the
  <span class="struct">BPB</span> is usefully saved at a well-known position on 
  the disk so that the file-system metadata the kernel will need for correctly accessing 
  files on the disk can be known with some confidence instead of having to be calculated, 
  inferred, guessed or trusted to the user’s recognition. Though saving a
  <span class="struct">BPB</span> on each disk was not the original practice, finding 
  one at offset 0Bh in the boot sector soon became the standard expectation, never 
  of the DOS kernel but certainly of its built-in block device driver. </p>
  <p>Many writers about DOS, and even specifically about the history of DOS, would 
  have it that being on the media is the defining characteristic of the
  <span class="struct">BPB</span>. See, for instance, the opening sentence of Wikipedia’s 
  article on the <a href="https://en.wikipedia.org/wiki/BIOS_parameter_block">BIOS 
  parameter block</a> (today, 29th October 2021). However convenient this may be 
  from modern perspectives, such as programming other (typically newer) operating 
  systems to use disks that were formatted for DOS or to format disks for use by 
  DOS, it was not DOS’s perspective. </p>
  <p>This page that you read now is concerned solely with the
  <span class="struct">BPB</span> as understood by the DOS kernel. It 
  necessarily looks a little at the other sides of interfaces to gauge what 
  seems intended for the design, but it aims very much to ignore interpretations 
  that are imposed retrospectively, except to dismiss them as unreasonably unhistorical. 
  If ever these notes expand to take in the <span class="struct">BPB</span> as interpreted 
  on disk, it will be as separate material about the boot sector. Note that this 
  separation is not something I make up now as my own unhistorical revision. It 
  was the extant interpretation when DOS was current, as in the
  <span class="citation">Microsoft® MS-DOS Programmer’s Reference : version 5.0</span>, 
  ISBN 1-55615-329-5, by Microsoft Press in 1991, which has its definitions of the
  <span class="struct">BPB</span> and the <span class="struct">BOOTSECTOR</span> 
  at opposite ends of the book. </p>
  <h2>Availability </h2>
  <p>The <span class="struct">BPB</span> is as old as DOS. Indeed, it is at least 
  as old as the 86-DOS version 1.00 that PC DOS 1.00 was developed from. </p>
  <p>True, no <span class="struct">BPB</span> is known to have been stored on any 
  disk’s boot sector before PC DOS 2.00 became available, and neither is the
  <span class="struct">BPB</span> from DOS’s first version known to have been referred 
  to as a BIOS Parameter Block until version 2.00. Yet far from not existing earlier, 
  the <span class="struct">BPB</span> is essential to DOS’s disk I/O through all 
  versions 1.<span class="placeholder">xx</span>. </p>
  <p>Even if this had stayed obscure in the mists of pre-history because the few 
  who bother to write about early DOS versions mostly don’t also bother to disassemble 
  the software as their primary source, it ought to be well known by now given Microsoft’s 
  publication of source code for MS-DOS versions 1.25 and 2.11 in 2014 at the
  <a href="https://computerhistory.org/blog/microsoft-ms-dos-early-source-code/">
  Computer History Museum</a> and in 2018 on
  <a href="https://github.com/microsoft/ms-dos">GitHub</a>. Even without source 
  code, there’a big hint in the name. The <span class="struct">BPB</span> was not 
  named as a Boot Sector This or a Boot Sector That or a Boot Parameter Block or 
  a Boot Anything. Why has it instead always been specifically a
  <span class="emphasis">BIOS</span> Parameter Block? </p>
  <h3>Name </h3>
  <p>The name BIOS Parameter Block, along with its abbreviation to BPB, is well 
  established by formal documentation as early as IBM’s <span class="citation">Disk 
  Operating System</span> manual for PC DOS 2.00 (part 6936752, January 1983), but 
  if the BIOS in this name wasn’t already a mis-direction, it soon would be. Since 
  at least the mid-1980s, what the term BIOS has meant for all practising DOS programmers, 
  and perhaps even for most technically-minded computer users, is the firmware that 
  is pre-installed in ROM with the IBM Personal Computer (PC) or with computers 
  that offered some sort of compatibility with software written for the PC. This 
  BIOS is present in the computer regardless of which operating system ever gets booted. 
  It provides hardware-specific functionality that an operating system can use if 
  it wants, and PC DOS does indeed use the BIOS instead of programming any hardware 
  directly. This BIOS certainly has a role in DOS’s disk I/O, notably for the
  <span class="instruction">int 13h</span> functions that insulate their callers from 
  the details of drive controllers, but it has no direct role in naming 
  the <span class="struct">BPB</span>. </p>
  <p>The BIOS that names the <span class="struct">BPB</span> is instead a DOS component, 
  specifically the one that first came to wide attention as the IBMBIO.COM file 
  for PC DOS 1.00 but which is more generically named IO.SYS. Already in the first 
  edition of the <span class="citation">Disk Operating System</span> manual (part 
  6172220, August 1981) for the IBM PC , this file was described as the “Read-Only 
  Memory (ROM) BIOS interface module” but also as the “DOS BIOS”, the one claiming 
  the term BIOS for IBM’s firmware, the other acknowledging older usage. Long before 
  the PC existed, an operating system named CP/M (for a different processor) had 
  established an architectural separation of the operating system. A lower-level 
  component is adapted to each computer system, even by being written afresh. It 
  abstracts the hardware (including firmware) as an <span class="definition">I/O 
  system</span> so that a higher-level component can be independent of the hardware 
  and thus be the same operating system <span class="definition">kernel</span> to 
  all programs on all computers. The CP/M names for these two components are the 
  BIOS and the BDOS. The term BDOS seems never to have caught on in DOS programming, 
  but the term BIOS for the lower-level I/O system stuck for many years, 
  sometimes distinguished 
  explicitly from the ROM BIOS as the DOS BIOS but often just as the BIOS in contrast 
  to the DOS. </p>
  <p>To know why the <span class="struct">BPB</span> is the
  <span class="emphasis">BIOS</span> Parameter Block, ask who it is in DOS version 
  1.<span class="placeholder">xx</span> who tells the DOS about the disk drives 
  and the media they may contain. The only possible answer in these versions, 
  which have no installable device drivers, is the DOS BIOS. The
  <span class="struct">BPB</span> originated as the parameter block that the DOS 
  BIOS provides to the DOS kernel to describe a disk drive. </p>
  <h3>Use </h3>
  <p>To the DOS kernel in version 2.00 and higher, the <span class="struct">BPB</span> 
  is a block device driver’s description of a drive or disk. The driver can be installable 
  or it can be built in to the DOS BIOS. Either way, the kernel obtains a
  <span class="struct">BPB</span> as output from the driver’s Init and Build BPB 
  functions (00h and 02h, respectively). A block device driver’s successful initialisation 
  provides one <span class="struct">BPB</span> for each device unit, in effect, 
  to describe each of what the driver wants the kernel to perceive as a disk drive. 
  The kernel may then call the Build BPB function arbitrarily often, typically after a Media 
  Check function (01h) answers negatively, to get a <span class="struct">BPB</span> 
  for a specified unit’s current media, i.e., whatever disk is in the drive. </p>
  <p>Whether 
  a <span class="struct">BPB</span> is for a driver or a disk, the kernel treats 
  it as input for preparing or updating the <span class="struct">DPB</span> (Drive 
  Parameter Block) that it keeps for each drive—and then, as far as the kernel is 
  concerned, the <span class="struct">BPB</span> is thrown away. This 
  interpretation of a <span class="struct">BPB</span> as a BIOS structure whose 
  only meaning to the kernel is for capturing it into a longer-lasting DOS 
  structure is even exposed to DOS programs through
  <span class="instruction">int 21h</span> function 53h. Thuogh the purpose was, 
  at least at first, the very limited one of initialising block device drivers 
  at the direction of a <span class="keyword">device</span> statement in 
  CONFIG.SYS, the relevant code is the whole of the kernel’s interpretation of a
  <span class="struct">BPB</span> and is therefore taken here as definitive from 
  the kernel’s perspective. </p>
  <p>See that this interface between the DOS kernel and its device drivers provides 
  for a <span class="struct">BPB</span> to exist independently of any disk. See 
  that nowhere in the interface must a <span class="struct">BPB</span> that’s produced 
  for a disk have been on the disk. Nowhere does the interface require that a
  <span class="struct">BPB</span> has even the slightest role in the device driver’s 
  possibly substantial work for reading from or writing to the disk, or for doing 
  whatever else it is that a device driver might do with a disk—except to describe 
  the disk to the kernel. </p>
  <p>Obviously, a device driver’s implementation can be much easier if this
  <span class="struct">BPB</span> is used internally too, but no rule requires it 
  and conditions have existed when some advantage can be gained from giving the 
  kernel a logical picture of the disk that differs from the physical. For instance, 
  when the <span class="struct">BPB</span> had only a 16-bit member for the disk’s 
  capacity in sectors, disks that have 512-byte sectors but are larger than 32MB 
  could be accommodated by a device driver which describes the disk to the kernel 
  as having 1024-byte sectors (or larger) and translates the kernel’s I/O requests 
  to the 512-byte sectors of the (ROM) BIOS’s <span class="instruction">int 13h</span> 
  interface. </p>
  <p>Before version 2.00, there are no device drivers to install for hardware 
  that’s too unusual for the built-in drivers of the DOS BIOS. There is instead 
  only this BIOS, which must be changed in total if unusual hardware is to be 
  accommodated. The DOS kernel learns about 
  disk drives only from the BIOS and only during the kernel’s initialisation. 
  For this, the kernel is given an initialisation table. Within are pointers to 
  the BIOS’s description of each disk drive. In IO.ASM from the published source 
  code for MS-DOS 1.25, each such description is labelled but its contents are defined 
  just as a succession of bytes and words with no formal structure. Comments suggest 
  that these descriptions were then known as DPTs. Yet each is unmistakably an early 
  form of the <span class="struct">BPB</span>. When version 2.00 introduced installable 
  device drivers, it was only natural that what block device drivers return from 
  their initialisation is the parameter block that the BIOS had passed to 
  the kernel’s initialisation in version 1.<span class="placeholder">xx</span>.
  </p>
  <h2>Layout </h2>
  <p>The oldest representation that Microsoft has published of the BIOS Parameter 
  Block as a structure in a programming language is in a header named DOSSYM.ASM 
  among the source files for MS-DOS 2.11. The structure is there named
  <span class="struct">BPBLOCK</span>. Microsoft follows each member’s definition 
  with a single-line comment which is reproduced below as the Description: </p>
  <table class="Struct">
    <colgroup>
      <col class="Offset"><col class="Size"><col class="Name">
      <col class="Description"><col class="Versions">
    </colgroup>
    <thead>
      <tr>
        <th>Offset </th>
        <th>Size or Type </th>
        <th>Name </th>
        <th>Description </th>
        <th>Versions </th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td>00h </td>
        <td>word </td>
        <td><span class="member">BPSECSZ</span> </td>
        <td>Size in bytes of physical sector </td>
        <td>all </td>
      </tr>
      <tr>
        <td>02h </td>
        <td>byte </td>
        <td><span class="member">BPCLUS</span> </td>
        <td>Sectors/Alloc unit </td>
        <td>all </td>
      </tr>
      <tr>
        <td>03h </td>
        <td>word </td>
        <td><span class="member">BPRES</span> </td>
        <td>Number of reserved sectors </td>
        <td>all </td>
      </tr>
      <tr>
        <td>05h </td>
        <td>byte </td>
        <td><span class="member">BPFTCNT</span> </td>
        <td>Number of FATs </td>
        <td>all </td>
      </tr>
      <tr>
        <td>06h </td>
        <td>word </td>
        <td><span class="member">BPDRCNT</span> </td>
        <td>Number of directory entries </td>
        <td>all </td>
      </tr>
      <tr>
        <td>08h </td>
        <td>word </td>
        <td><span class="member">BPSCCNT</span> </td>
        <td>Total number of sectors </td>
        <td>all </td>
      </tr>
      <tr>
        <td>0Ah </td>
        <td>byte </td>
        <td><span class="member">BPMEDIA</span> </td>
        <td>Media descriptor byte </td>
        <td>2.00 and higher </td>
      </tr>
      <tr>
        <td>0Bh </td>
        <td>word </td>
        <td><span class="member">BPFTSEC</span> </td>
        <td>Number of sectors taken up by one FAT </td>
        <td>2.00 and higher </td>
      </tr>
    </tbody>
  </table>
  <p>Whatever Microsoft’s comment means about a sector being physical, what the 
  DOS kernel understands of the sector from the <span class="struct">BPB</span> 
  is that the interfaces through which the kernel can ask the BIOS or a device driver 
  to read from or write to the disk have this sector as the smallest unit of exchange. 
  The interfaces present the disk to the kernel as an array of these sectors, numbered 
  from 0 up to but not including the total number of sectors. All reads and writes 
  are in whole sectors. Whether these sectors are also the smallest block that the 
  I/O system can read or write through the drive controller is up to the I/O system. 
  How these sectors are laid out on the sides and tracks of a physical disk is also 
  up to the I/O system. Whether there’s even a physical disk is up to the I/O system. 
  The kernel sees just an array. </p>
  <p>The remaining members of the original <span class="struct">BPB</span> all describe 
  how the disk as an array of sectors is to be interpreted by the kernel in distinct 
  regions for managing file storage. Working upwards through the array, there can 
  be reserved sectors, FATs, a (root) directory, and then the contents of files.
  </p>
  <p>The “Alloc unit” of Microsoft’s comment is commonly referred to as a cluster. 
  The kernel exposes the contents of files with byte granularity but manages their 
  storage on disk in whole clusters. All known kernels assume that a cluster is 
  not just a whole number of sectors but that this number is a power of two. The 
  last of the disk regions is treated as an array of clusters, numbered from two 
  upwards. (That this numbering starts at two can be taken as given, but some hypothesis on this point is ventured in this page’s historical survey 
  below.) A FAT is an array of 0-based cluster numbers indexed by 0-based cluster 
  numbers. Looking up one cluster tells which, if any, is the next cluster for 
  the same file. DOS started with 12-bit cluster numbers. DOS 3.00 and 
  higher allow 16-bit cluster numbers. Recognition of 32-bit cluster numbers came 
  with DOS 7.10 (after the integration with WIndows, which is beyond this note’s present 
  scope). </p>
  <p>The reserved sectors typically—indeed, advisedly but not necessarily—begin 
  with a boot sector. More generally, the reserved sectors are those at the start of 
  the disk which are no business of the kernel’s for its management of files. They can be the business of the 
  I/O system. In DOS’s precursor, 86-DOS, they were not just the business of the 
  I/O system but were the storage for both the I/O system and (except in late versions) the kernel, which thus do not appear as files. </p>
  <p>However many reserved sectors are defined, including none, whatever follows 
  is the first FAT. This begins the file system’s metadata, which is in two parts: 
  the given number of FATs; and then a directory that is large enough for the given 
  number of entries. The point to multiple FATs is to have safety copies: roughly 
  speaking, DOS accepts any one of them when reading but insists on success for 
  all when writing. Each FAT must be a whole number of sectors. So too must the 
  directory. Computing how many whole sectors, especially for the FAT, is non-trivial 
  and inevitably has quirks. These are avoided in DOS version 2.00 and higher by 
  extending the <span class="struct">BPB</span> so that the FAT’s size in sectors 
  is specified rather than computed. </p>
  <h3>Public Definition </h3>
  <p>Though the <span class="struct">BPBLOCK</span> is the oldest definition that 
  Microsoft has published, the first that Microsoft published openly was a different 
  assembly-language definition in the <span class="citation">Microsoft® MS-DOS Programmer’s 
  Reference : version 5.0</span>. It there has the name <span class="struct">BPB</span>, 
  which is consistent with documentation since PC DOS 2.00. Earlier texts from Microsoft, 
  including the same reference for earlier DOS versions, present the
  <span class="struct">BPB</span> only with its members described in words, not 
  as a structure with a formal definition in any programming language. The presentation below attempts to back-fit Microsoft’s 
  names for the <span class="struct">BPB</span> members to earlier versions 
  according to which members were yet meaningful to the kernel’s interpretation 
  of a <span class="struct">BPB</span> from a device driver. </p>
  <table class="Struct">
    <colgroup>
      <col class="Offset"><col class="Size"><col class="Name">
      <col class="Versions">
    </colgroup>
    <thead>
      <tr>
        <th>Offset </th>
        <th>Size or Type </th>
        <th>Name </th>
        <th>Versions </th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td>00h </td>
        <td>word </td>
        <td><span class="member">bpbBytesPerSec</span> </td>
        <td>all </td>
      </tr>
      <tr>
        <td>02h </td>
        <td>byte </td>
        <td><span class="member">bpbSecPerClust</span> </td>
        <td>all </td>
      </tr>
      <tr>
        <td>03h </td>
        <td>word </td>
        <td><span class="member">bpbResSectors</span> </td>
        <td>all </td>
      </tr>
      <tr>
        <td>05h </td>
        <td>byte </td>
        <td><span class="member">bpbFATs</span> </td>
        <td>all </td>
      </tr>
      <tr>
        <td>06h </td>
        <td>word </td>
        <td><span class="member">bpbRootDirEnts</span> </td>
        <td>all </td>
      </tr>
      <tr>
        <td>08h </td>
        <td>word </td>
        <td><span class="member">bpbSectors</span> </td>
        <td>all </td>
      </tr>
      <tr>
        <td>0Ah </td>
        <td>byte </td>
        <td><span class="member">bpbMedia</span> </td>
        <td>2.00 and higher </td>
      </tr>
      <tr>
        <td>0Bh </td>
        <td>word </td>
        <td><span class="member">bpbFATSecs</span> </td>
        <td>2.00 and higher </td>
      </tr>
      <tr>
        <td>0Dh </td>
        <td>word </td>
        <td><span class="member">bpbSecPerTrack</span> </td>
        <td>3.31 and higher </td>
      </tr>
      <tr>
        <td>0Fh </td>
        <td>word </td>
        <td><span class="member">bpbHeads</span> </td>
        <td>3.31 and higher </td>
      </tr>
      <tr>
        <td>11h </td>
        <td>dword </td>
        <td><span class="member">bpbHiddenSectors</span> </td>
        <td>3.31 and higher </td>
      </tr>
      <tr>
        <td>15h </td>
        <td>dword </td>
        <td><span class="member">bpbHugeSectors</span> </td>
        <td>3.31 and higher </td>
      </tr>
    </tbody>
  </table>
  <p>The three members at offsets 0Dh, 0Fh and 11h (the last being originally 
  only a word) are irrelevant to the DOS kernel. 
  However commonly they are seen to follow the <span class="struct">BPB</span> 
  in boot sectors or even as kept in memory by the built-in block device driver, they are explicitly excluded from the <span class="struct">BPB</span> as 
  presented in boot sectors by Microsoft documentation up to and including the Programmer’s 
  Reference for version 4.0. There’s surely no mistaking this point in IBM’s
  <span class="citation">Disk Operating System</span> manual for PC DOS 2.00:
  </p>
  <blockquote>
    The three words at the end are optional. DOS does not care about them because 
    they are not part of the BPB.
  </blockquote>
  <p>When version 3.20 anticipated disks with too many sectors for the word at offset 
  08h, much of the practical value of having the <span class="struct">BPB</span> 
  in the boot sector would have been lost if the <span class="struct">BPB</span> 
  for the DOS kernel were extended incompatibly with what had been following the
  <span class="struct">BPB</span> when stored in boot sectors. The Programmer’s 
  Reference for version 3.20 adds the 32-bit sector count at offset 15h as a provision 
  for the future while still excluding it from the <span class="struct">BPB</span>: 
  they are all “fields that follow the BPB.” It is here thought that this 
  exclusion was put aside 
  when the DOS kernel first started interpreting the 32-bit sector count, and this 
  had the side-effect of bringing in the intervening eight bytes. </p>
  <p>The first known use of <span class="member">bpbHugeSectors</span> by a DOS 
  kernel is in a version 3.31 from Compaq. The DOS kernel treats the 32-bit
  <span class="member">bpbHugeSectors</span> as superseding the 16-bit
  <span class="member">bpbSectors</span>. That a <span class="struct">BPB</span> 
  reaches as far as <span class="member">bpbHugeSectors</span> is indicated by zero 
  for <span class="member">bpbSectors</span>. </p>
  <h3>The Device BPB </h3>
  <p>Other structural representations of the <span class="struct">BPB</span> were 
  published by Microsoft years later when DOS was integrated into Windows. 
  Though these came much too late to be of any practical use to DOS programmers, they 
  do have the merit of looking more plausibly like they were extracted from Microsoft’s 
  source code rather than confected for documentation. </p>
  <p>Especially notable is a header named BPB.INC from the Device Driver Kit (DDK) 
  for Windows 95. It has a copyright notice that dates at least some of its content 
  back to 1993. What the file presents, without comments, are two very nearly identical 
  structures named <span class="struct">BPB</span> and <span class="struct">A_BPB</span>. 
  To these may be added—except for being outside this note’s present scope—an
  <span class="struct">A_BF_BPB</span> from the <span class="citation">FAT32 API 
  Reference</span> for Windows 95 OEM Service Release 2 and later. </p>
  <table class="Struct">
    <colgroup>
      <col class="Offset"><col class="Size"><col class="Name">
      <col class="Versions"><col class="Remarks">
    </colgroup>
    <thead>
      <tr>
        <th>Offset </th>
        <th>Size or Type </th>
        <th>Name </th>
        <th>Versions </th>
        <th>Remarks </th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td rowspan="2">00h </td>
        <td rowspan="2">word </td>
        <td><span class="member">A_BPB_BytesPerSector</span> <br>
        <span class="member">BPB_BytesPerSector</span> </td>
        <td>3.20 and higher </td>
        <td>&nbsp;</td>
      </tr>
      <tr>
        <td><span class="member">A_BF_BPB_BytesPerSector</span> </td>
        <td>7.10 and higher </td>
        <td>&nbsp;</td>
      </tr>
      <tr>
        <td rowspan="2">02h </td>
        <td rowspan="2">byte </td>
        <td><span class="member">A_BPB_SectorsPerCluster</span> <br>
        <span class="member">BPB_SectorsPerCluster</span> </td>
        <td>3.20 and higher </td>
        <td>&nbsp;</td>
      </tr>
      <tr>
        <td><span class="member">A_BF_BPB_SectorsPerCluster</span> </td>
        <td>7.10 and higher </td>
        <td>&nbsp;</td>
      </tr>
      <tr>
        <td rowspan="2">03h </td>
        <td rowspan="2">word </td>
        <td><span class="member">A_BPB_ReservedSectors</span> <br>
        <span class="member">BPB_ReservedSectors</span> </td>
        <td>3.20 and higher </td>
        <td>&nbsp;</td>
      </tr>
      <tr>
        <td><span class="member">A_BF_BPB_ReservedSectors</span> </td>
        <td>7.10 and higher </td>
        <td>&nbsp;</td>
      </tr>
      <tr>
        <td rowspan="2">05h </td>
        <td rowspan="2">byte </td>
        <td><span class="member">A_BPB_NumberOfFATs</span> <br>
        <span class="member">BPB_NumberOfFATs</span> </td>
        <td>3.20 and higher </td>
        <td>&nbsp;</td>
      </tr>
      <tr>
        <td><span class="member">A_BF_BPB_NumberOfFATs</span> </td>
        <td>7.10 and higher </td>
        <td>&nbsp;</td>
      </tr>
      <tr>
        <td rowspan="2">06h </td>
        <td rowspan="2">word </td>
        <td><span class="member">A_BPB_RootEntries</span> <br>
        <span class="member">BPB_RootEntries</span> </td>
        <td>3.20 and higher </td>
        <td>&nbsp;</td>
      </tr>
      <tr>
        <td><span class="member">A_BF_BPB_RootEntries</span> </td>
        <td>7.10 and higher </td>
        <td>&nbsp;</td>
      </tr>
      <tr>
        <td rowspan="2">08h </td>
        <td rowspan="2">word </td>
        <td><span class="member">A_BPB_TotalSectors</span> <br>
        <span class="member">BPB_TotalSectors</span> </td>
        <td>3.20 and higher </td>
        <td>&nbsp;</td>
      </tr>
      <tr>
        <td><span class="member">A_BF_BPB_TotalSectors</span> </td>
        <td>7.10 and higher </td>
        <td>&nbsp;</td>
      </tr>
      <tr>
        <td rowspan="2">0Ah </td>
        <td rowspan="2">byte </td>
        <td><span class="member">A_BPB_MediaDescriptor</span> <br>
        <span class="member">BPB_MediaDescriptor</span> </td>
        <td>3.20 and higher </td>
        <td>&nbsp;</td>
      </tr>
      <tr>
        <td><span class="member">A_BF_BPB_MediaDescriptor</span> </td>
        <td>7.10 and higher </td>
        <td>&nbsp;</td>
      </tr>
      <tr>
        <td rowspan="2">0Bh </td>
        <td rowspan="2">word </td>
        <td><span class="member">A_BPB_SectorsPerFAT</span> <br>
        <span class="member">BPB_SectorsPerFAT</span> </td>
        <td>3.20 and higher </td>
        <td>&nbsp;</td>
      </tr>
      <tr>
        <td><span class="member">A_BF_BPB_SectorsPerFAT</span> </td>
        <td>7.10 and higher </td>
        <td>&nbsp;</td>
      </tr>
      <tr>
        <td rowspan="2">0Dh </td>
        <td rowspan="2">word </td>
        <td><span class="member">A_BPB_SectorsPerTrack</span> <br>
        <span class="member">BPB_SectorsPerTrack</span> </td>
        <td>3.20 and higher </td>
        <td>&nbsp;</td>
      </tr>
      <tr>
        <td><span class="member">A_BF_BPB_SectorsPerTrack</span> </td>
        <td>7.10 and higher </td>
        <td>&nbsp;</td>
      </tr>
      <tr>
        <td rowspan="2">0Fh </td>
        <td rowspan="2">word </td>
        <td><span class="member">A_BPB_Heads</span> <br>
        <span class="member">BPB_Heads</span> </td>
        <td>3.20 and higher </td>
        <td>&nbsp;</td>
      </tr>
      <tr>
        <td><span class="member">A_BF_BPB_Heads</span> </td>
        <td>7.10 and higher </td>
        <td>&nbsp;</td>
      </tr>
      <tr>
        <td rowspan="2">11h </td>
        <td rowspan="2">word </td>
        <td><span class="member">A_BPB_HiddenSectors</span> <br>
        <span class="member">BPB_HiddenSectors</span> </td>
        <td>3.20 and higher </td>
        <td>last <span class="struct">BPB</span> member in 3.20 to 3.30 </td>
      </tr>
      <tr>
        <td><span class="member">A_BF_BPB_HiddenSectors</span> </td>
        <td>7.10 and higher </td>
        <td>&nbsp;</td>
      </tr>
      <tr>
        <td rowspan="3">13h </td>
        <td rowspan="3">word </td>
        <td><span class="member">A_BPB_HiddenSectorsHigh</span> </td>
        <td>3.20 and higher </td>
        <td>&nbsp;</td>
      </tr>
      <tr>
        <td><span class="member">BPB_HiddenSectorsHigh</span> </td>
        <td>3.31 and higher </td>
        <td>&nbsp;</td>
      </tr>
      <tr>
        <td><span class="member">A_BF_BPB_HiddenSectorsHigh</span> </td>
        <td>7.10 and higher </td>
        <td>&nbsp;</td>
      </tr>
      <tr>
        <td rowspan="3">15h </td>
        <td rowspan="3">word </td>
        <td><span class="member">A_BPB_BigTotalSectors</span> </td>
        <td>3.20 and higher </td>
        <td>&nbsp;</td>
      </tr>
      <tr>
        <td><span class="member">BPB_BigTotalSectors</span> </td>
        <td>3.31 and higher </td>
        <td>&nbsp;</td>
      </tr>
      <tr>
        <td><span class="member">A_BF_BPB_BigTotalSectors</span> </td>
        <td>7.10 and higher </td>
        <td>&nbsp;</td>
      </tr>
      <tr>
        <td rowspan="3">17h </td>
        <td rowspan="3">word </td>
        <td><span class="member">A_BPB_BigTotalSectorsHigh</span> </td>
        <td>3.20 and higher </td>
        <td>&nbsp;</td>
      </tr>
      <tr>
        <td><span class="member">BPB_BigTotalSectorsHigh</span> 
        <!-- <br>
        --></td>
        <td>3.31 and higher </td>
        <td>last <span class="struct">BPB</span> member in 3.31 and higher </td>
      </tr>
      <tr>
        <td><span class="member">A_BF_BPB_BigTotalSectorsHigh</span> </td>
        <td>7.10 and higher </td>
        <td>&nbsp;</td>
      </tr>
      <tr>
        <td>19h </td>
        <td>six bytes </td>
        <td><span class="member">A_BPB_Reserved</span> </td>
        <td>3.20 and higher </td>
        <td>last <span class="struct">A_BPB</span> member </td>
      </tr>
      <tr>
        <td>19h </td>
        <td>word </td>
        <td><span class="member">A_BF_BPB_BigSectorsPerFat</span> </td>
        <td>7.10 and higher </td>
        <td>&nbsp;</td>
      </tr>
      <tr>
        <td>1Bh </td>
        <td>word </td>
        <td><span class="member">A_BF_BPB_BigSectorsPerFatHi</span> </td>
        <td>7.10 and higher </td>
        <td>&nbsp;</td>
      </tr>
      <tr>
        <td>1Dh </td>
        <td>word </td>
        <td><span class="member">A_BF_BPB_ExtFlags</span> </td>
        <td>7.10 and higher </td>
        <td>&nbsp;</td>
      </tr>
      <tr>
        <td>1Fh </td>
        <td>word </td>
        <td><span class="member">A_BF_BPB_FS_Version</span> </td>
        <td>7.10 and higher </td>
        <td>&nbsp;</td>
      </tr>
      <tr>
        <td>21h </td>
        <td>word </td>
        <td><span class="member">A_BF_BPB_RootDirStrtClus</span> </td>
        <td>7.10 and higher </td>
        <td>&nbsp;</td>
      </tr>
      <tr>
        <td>23h </td>
        <td>word </td>
        <td><span class="member">A_BF_BPB_RootDirStrtClusHi</span> </td>
        <td>7.10 and higher </td>
        <td>&nbsp;</td>
      </tr>
      <tr>
        <td>25h </td>
        <td>word </td>
        <td><span class="member">A_BF_BPB_FSInfoSec</span> </td>
        <td>7.10 and higher </td>
        <td>&nbsp;</td>
      </tr>
      <tr>
        <td>27h </td>
        <td>word </td>
        <td><span class="member">A_BF_BPB_BkUpBootSec</span> </td>
        <td>7.10 and higher </td>
        <td>&nbsp;</td>
      </tr>
      <tr>
        <td>29h </td>
        <td>six words </td>
        <td><span class="member">A_BF_BPB_Reserved</span> </td>
        <td>7.10 and higher </td>
        <td>last <span class="struct">A_BF_BPB</span> member </td>
      </tr>
    </tbody>
  </table>
  <p>&nbsp;</p>
  <h2>Early Version 1 </h2>
  <p>In the earliest DOS versions, a DOS drive can hold different disks but all 
  the disks in any one drive are assumed to have the same format. This is established 
  already in the 86-DOS 1.00 that PC DOS 1.00 started its development from, and 
  continues at least to 86-DOS 1.14. It is built into the kernel’s initialisation. 
  This starts with <span class="register">ds</span>:<span class="register">si</span> 
  addressing an initialisation table provided by the I/O system: </p>
  <table class="Struct">
    <colgroup>
      <col class="Offset"><col class="Size"><col class="Description">
    </colgroup>
    <thead>
      <tr>
        <th>Offset </th>
        <th>Size or Type </th>
        <th>Description </th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td>00h </td>
        <td>byte </td>
        <td><span class="placeholder">N</span>, as number of drives </td>
      </tr>
      <tr>
        <td>01h </td>
        <td><span class="placeholder">N</span> near pointers <br>
        (relative to <span class="register">ds</span>) </td>
        <td>array of pointers to <span class="struct">BPBLOCK</span> structures 
        for successive drives </td>
      </tr>
    </tbody>
  </table>
  <p>What the kernel is to understand from each entry in this table is that the 
  I/O system’s functions for reading and writing disks—these are the functions named
  <span class="function">BIOSREAD</span> and <span class="function">BIOSWRITE</span> 
  in the MSDOS.ASM source file—take the 0-based index into this table as an input 
  parameter (in <span class="register">al</span>) to select which drive to access. 
  The other parameters are a 0-based starting sector (<span class="register">dx</span>), 
  a count of sectors (<span class="register">cx</span>) and a transfer address (<span class="register">ds</span>:<span class="register">bx</span>). 
  Remember, to the kernel the disk is an array of sectors. How, or even if, these 
  are mapped to sectors on sides of tracks on media in some physical device is up 
  to the I/O system. </p>
  <p>What the kernel presents to higher levels is that each of these drives is a 
  DOS drive. Each, in the same sequence as given in the initialisation table, becomes 
  accessible through a 0-based DOS drive number for use with such
  <span class="instruction">int 21h</span> functions as 0Eh and 19h, through a 1-based 
  DOS drive number in a File Control Block (FCB), and through a drive letter, A 
  and upwards, as used in filenames and as known to users. </p>
  <p>In programming terms, the <span class="struct">BPBLOCK</span> for a drive is 
  input for creating a <span class="struct">DPBLOCK</span> (later named
  <span class="struct">DPB</span>). This structure, not the <span class="struct">
  BPB</span>, is what the kernel keeps about the drive. Each is followed by a buffer 
  for caching the FAT from the drive’s current contents. These early DOS versions 
  have no notion of receiving a <span class="struct">BPB</span> for a drive and 
  later a different one for a disk in the drive. The initialised kernel will forever 
  know only of the drives it was told about in the initialisation table and it will 
  forever assume that all disks it accesses through any one drive have the one and 
  only format that was specified for that drive. </p>
  <p>Different formats of disk are possible but each must have its own DOS drive. 
  Here, it is important to recognise that the I/O system defines these drives for 
  the kernel but how the I/O system implements them is its own business. At the 
  most general, these DOS drives are logical constructions that need have no direct 
  correspondence with the physical drives that users load disks into. The interface 
  does not itself prevent an implementation in which one physical drive is accessible 
  through two, three or even more DOS drives, one for each format of disk that might 
  be loaded into the physical drive. </p>
  <p>As it happens, the extant implementations of these early DOS versions illustrate 
  two roughly opposite attitudes to this freedom of implementation. </p>
  <h3>86-DOS 1.00 </h3>
  <p>An 86-DOS 1.00 that has been found for inspection was built by Seattle Computer 
  Products (SCP) for a computer system that has a Tarbell controller of two double-headed 
  disk drives which can each take single-density or double-density 8” disks. The 
  I/O system presents these two physical drives to the DOS kernel as six logical 
  drives, the first four sharing one <span class="struct">BPB</span>, the last two 
  sharing another. All that the DOS kernel knows about these is that drives A to 
  D somehow access disks that have one format, and drives E and F are for disks 
  in a second format: </p>
  <table class="DiskFormat">
    <colgroup>
      <col class="Property"><col class="Value" span="2">
    </colgroup>
    <thead>
      <tr>
        <th>&nbsp;</th>
        <th>Drives A, B, C and D </th>
        <th>Drives E and F </th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td>Sector Size (bytes): </td>
        <td>128 </td>
        <td>1024 </td>
      </tr>
      <tr>
        <td>Cluster Size (sectors): </td>
        <td>4 </td>
        <td>1 </td>
      </tr>
      <tr>
        <td>Reserved Sectors: </td>
        <td>52 </td>
        <td>1 </td>
      </tr>
      <tr>
        <td>Number of FATs: </td>
        <td>2 </td>
        <td>2 </td>
      </tr>
      <tr>
        <td>Directory Capacity (directory entries): </td>
        <td>64 </td>
        <td>128 </td>
      </tr>
      <tr>
        <td>Disk Capacity (sectors): </td>
        <td>2002 </td>
        <td>1232 </td>
      </tr>
    </tbody>
  </table>
  <p>From the first <span class="struct">BPB</span>, the kernel understands that 
  every disk in drives A to D is an array of 128-byte sectors which are each represented 
  by a sector number that ranges from 0 up to but not including 2002, and that this 
  array can be reckoned in several regions: 52 reserved sectors; 2 FATs of 6 sectors 
  each; a directory of either 8 sectors or 16 (to be explained shortly); with the 
  remainder for file storage. From the second <span class="struct">BPB</span>, every 
  disk in drives E or F is understood as an array of 1232 sectors of 1024 bytes 
  each: 1 reserved sector; 2 FATs of 2 sectors each; a directory of either 2 or 
  4 sectors; and then file storage. </p>
  <p>That the directory has two possible sizes is because the capacity is counted 
  in entries and this early DOS allows that directory entries can be either 16 bytes 
  or 32. That a disk uses one rather than the other is determined by the first byte 
  in whichever FAT the kernel is able to read from the disk. This byte is the original 
  media descriptor, in the sense that it’s stored on the media to describe the intended 
  interpretation of its contents. To 86-DOS 1.00—and even to version 1.14, but not 
  to the intervening PC DOS 1.00—this media descriptor in the FAT is FFh for disks 
  that have 16-byte directory entries: anything else indicates 32-byte entries.
  </p>
  <p>This first byte in the FAT is part of the FAT entry for cluster 0. Its early 
  use as a media descriptor is qualitatively different from the use it’s put to 
  in later versions. Here, a different media descriptor does not signify that a 
  disk has a different FAT layout with a different <span class="struct">BPB</span> 
  to describe it, only that the one <span class="struct">BPB</span> is to be interpreted 
  a little differently. The variation that’s described is specifically of the directory.
  </p>
  <p>Much else about the drives and their media must be known to the I/O system, 
  of course, but since none of it is in a <span class="struct">BPB</span> addressed 
  from the initialisation table, the kernel never knows. The I/O system decides 
  (and keeps to itself) which of the DOS drives map to which of the physical drives 
  that the user may load a disk into. For the system inspected, drives A, B and 
  E access one of the physical drives, A using just one head, B the other and E 
  both, and drives C, D and F follow this pattern but for the second physical drive. 
  The I/O system is also the sole determinant of how the kernel’s sector numbers 
  map to sectors on sides of tracks. For a disk that’s accessed through any of the 
  DOS drives A to D, the mapping is to 26 sectors on each of 77 single-sided tracks. 
  If instead a disk is accessed through drive E or F, the mapping is to 8 sectors 
  on each of two sides of 77 tracks. </p>
  <p>None of these characteristics of disk geometry or file-system metadata (putting 
  aside the hack of the FAT’s first byte to signify the use of old-style directory 
  entries) is stored on the media. The user is expected to know that drives A through 
  D are pre-configured for one type of disk with one file-system format, drives 
  E and F for a second, and there’s no way to use any third type of disk except 
  by re-configuring the I/O system. A computer system that uses differently formatted 
  disks would need a different I/O system—but, crucially, not a different kernel 
  (given that the formatting keeps the FAT file system). Some measure of how much 
  this loose coupling of I/O system and kernel is the deliberate design from the 
  time, rather than an architecture inferred with the help of passing decades, is 
  that source code (DOSIO.ASM) is supplied for the I/O system, presumably for customisation, 
  but not for the kernel. </p>
  <h3>PC DOS 1.00 </h3>
  <p>How well users of SCP’s computer system running 86-DOS 1.00 coped with six 
  DOS drive letters for the two drives they could see to load disks into is not 
  known, but they will mostly have been advanced users or at least have been enthusiastic 
  hobbyists aiming to become advanced users, if not advanced programmers, and so 
  it’s credible that they coped well enough. IBM perhaps will not have felt confident 
  of this for users of the mass-market PC, and so PC DOS 1.00 is at the other extreme. 
  Except for one (important) case, it presents its users with one DOS drive letter 
  for each physical drive. Its price for this simplicity is that (for the system 
  as IBM supplies it) all disks can have only the one format. </p>
  <p>The IBMBIO.COM for PC DOS 1.00 learns how many floppy disk drives are present 
  by calling <span class="instruction">int 11h</span> in the ROM BIOS. This returns 
  equipment flags in <span class="register">ax</span>. Bit 0 is set if there are 
  any floppy disk drives at all. Bits 6 to 7 then tell how many, 0 to 3 in the bits 
  meaning 1 to 4 as the count. IBMBIO.COM ignores bit 0, as if to assume that IBMBIO.COM 
  cannot be running except that it was booted from a floppy disk. The
  <span class="citation">Technical Reference</span> (part 6025008, August 1981) 
  is plain that “the 5-1/4" Diskette Drive Adapter is capable of attaching four 
  5-1/4" drives, two internal, and two external”, and IBMBIO.COM certainly is written 
  to manage as many as four. </p>
  <p>If 2, 3 or 4 floppy disk drives are present, then IBMBIO.COM defines 2, 3 or 
  4 DOS drives, one for each physical drive. The exception is that if only one floppy 
  disk drive is present, then IBMBIO.COM defines two DOS drives, both to access 
  the one physical drive. Crucially different from the 86-DOS implementation of 
  multiple DOS drives for each physical drive, the I/O system in PC DOS explicitly 
  manages the mapping so that the one physical drive is accessible through only 
  one of the two DOS drives at any one time. Attempted access through the other 
  generates a prompt to </p>
  <pre class="output">Insert diskette for drive <span class="placeholder">x</span>: and strike
any key when ready</pre>
  <p>Thus does the IBMBIO.COM for PC DOS 1.00 define as many as four DOS drives 
  when initialising the kernel. It has the one hard-coded <span class="struct">BPB</span> 
  for all four. The FAT format specified in this hard coding is for what has forever 
  since been the standard 160KB disk: </p>
  <table class="DiskFormat">
    <colgroup>
      <col class="Property"><col class="Value">
    </colgroup>
    <thead>
      <tr>
        <th>&nbsp;</th>
        <th>Drives A and B, <br>
        Drive C (If Present) <br>
        Drive D (If Present) </th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td>Sector Size (bytes): </td>
        <td>512 </td>
      </tr>
      <tr>
        <td>Cluster Size (sectors): </td>
        <td>1 </td>
      </tr>
      <tr>
        <td>Reserved Sectors: </td>
        <td>1 </td>
      </tr>
      <tr>
        <td>Number of FATs: </td>
        <td>2 </td>
      </tr>
      <tr>
        <td>Directory Capacity (directory entries): </td>
        <td>64 </td>
      </tr>
      <tr>
        <td>Disk Capacity (sectors): </td>
        <td>320 </td>
      </tr>
    </tbody>
  </table>
  <p>This hard-coding of one FAT layout for all disks in all drives extends also 
  to the disk geometry. Though the ROM BIOS functions for reading and writing through
  <span class="instruction">int 13h</span> take a head number in
  <span class="register">dh</span>, IBMBIO.COM hard-codes its use of this parameter 
  to zero. To this IBMBIO.COM in this PC DOS version, all disks are single-sided 
  with eight sectors per track. </p>
  <p>For its part, the kernel in PC DOS 1.00 is hard-coded for 32-byte directory 
  entries. Support for 16-byte entries was retained in 86-DOS until at least version 
  1.14, being dropped in version 1.20 according to comments in the published source 
  code for MS-DOS 1.25, but it seems never to have got a look-in for PC DOS 1.00. 
  That aside, the kernel in PC DOS 1.00 is not known to have any other constraint 
  on the FAT formats it can work with, but it can’t ever learn of them except if 
  booted with a replacement IBMBIO.COM. </p>
  <h2>Later Version 1 </h2>
  <p>Most users, of course, did not have a replacement IBMBIO.COM—certainly not 
  at the time, even if they were programmers. Unlike SCP for its I/O system in 86-DOS, 
  and even unlike IBM for its ROM BIOS, IBM did not publish source code for IBMBIO.COM.
  </p>
  <p>Legend has it that the ROM BIOS for the PC was soon reverse-engineered, but 
  the simpler DOS BIOS for the PC seems not to have been. The one had very much 
  the greater commercial incentive, of course. With a good enough facsimile of the 
  ROM BIOS, you get the prospect of assembling whole computers as substitutes for 
  the PC and selling them (honestly) as capable of running all of the software that 
  was being written for the PC. Adapting IBMBIO.COM can at best open a market in 
  peripherals that users may add to (or change in) their PC beyond the offerings 
  of IBM and its resellers, and it anyway has the detraction of not scaling: adding 
  even two peripherals from different manufacturers needs that a modified IBMBIO.COM 
  that is somehow adapted to both. Fortunately, DOS soon had installable device 
  drivers, but soon was more than a year away. </p>
  <p>Had anyone at the time been looking for a customisation that could be supported 
  by adapting IBMBIO.COM, even just for their private use, then they might have 
  perceived a suggestion in the <span class="citation">Technical Reference</span>. 
  The disk drives in the original PC are there said to be “single-sided", but the 
  Reference elsewhere shows the disk controller as allowing for two heads and the 
  ROM BIOS as being already implemented for two heads. </p>
  <p>With the advantage of decades of </p>
  <p>Anyone who wanted that their original PC can use double-sided disks instead 
  of single-sided could easily enough have adapted IBMBIO.COM, but if they wanted 
  to use both single-sided and double-sided disks, each with its own
  <span class="struct">BPB</span>, they would have needed an adapted IBMBIO.COM 
  that’s more like the I/O system from SCP, with different DOS drives for the different 
  types of disk. While such a solution might have been fine for hobbyists, it plainly 
  was not the IBM way to easy usability. To have one DOS drive per physical drive 
  but with each capable of using different types of disk, more would have to change 
  than just IBMBIO.COM. </p>
  <p>The interfaces between the I/O system and kernel were changing anyway. PC DOS 
  1.00 had been got ready without changing the interfaces from 86-DOS, but a price 
  was that the PC DOS 1.00 kernel calls functions in the ROM BIOS. For instance, 
  the I/O system had no functions to call for date and time, and so the PC DOS 1.00 
  kernel calls <span class="instruction">int 1Ah</span> itself. The necessary functions, 
  named <span class="function">BIOSSETDATE</span>, <span class="function">BIOSSETTIME</span> 
  and <span class="function">BIOSGETTIME</span> in MSDOS.ASM, can be seen in 86-DOS 
  version 1.14. </p>
  <p>For PC DOS 1.10, if not earlier, the initialisation table that IBMBIO.COM passes 
  to IBMDOS.COM in <span class="register">ds</span>:<span class="register">si</span> 
  is a little more complicated: </p>
  <table>
    <thead>
      <tr>
        <th>Offset </th>
        <th>Size or Type </th>
        <th>Description </th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td>00h </td>
        <td>byte </td>
        <td><span class="placeholder">N</span>, as number of I/O drivers </td>
      </tr>
      <tr>
        <td>01h </td>
        <td><span class="placeholder">N</span> structures </td>
        <td>array of 3-byte structures for successive I/O drivers </td>
      </tr>
    </tbody>
  </table>
  <p>The 3-byte structure for each I/O driver is: </p>
  <table>
    <thead>
      <tr>
        <th>Offset </th>
        <th>Size or Type </th>
        <th>Description </th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td>00h </td>
        <td>byte </td>
        <td>0-based drive number </td>
      </tr>
      <tr>
        <td>01h </td>
        <td>near pointer <br>
        (relative to <span class="register">ds</span>) </td>
        <td>address of <span class="struct">BPBLOCK</span> for I/O driver </td>
      </tr>
    </tbody>
  </table>
  <p>Importantly, the 0-based index into the initialisation table is no longer also 
  the DOS drive number. In effect, there are two drive numbers, one for the I/O 
  system and one for the kernel. To the published source code for MS-DOS 1.25, nomenclature 
  was not settled. The 0-based index into the table is an I/O driver number and 
  the kernel keeps their count as an internal variable named
  <span class="internal variable">NUMIO</span>. As with earlier versions, each entry 
  in the table, and thus each <span class="struct">BPBLOCK</span>, is input for 
  creating a <span class="struct">DPBLOCK</span>. In this, the entry’s 0-based index 
  and 0-based drive number becomes members named <span class="member">DEVNUM</span> 
  and <span class="member">DRVNUM</span>, respectively. and the 0-based r</p>
  <p>Importantly, the I/O system’s functions that the kernel calls for reading and 
  writing disks still receive the 0-based index in <span class="register">al</span> 
  but this is no longer also the DOS drive number. It is instead the I/O driver 
  number. All the kernel’s calls to these functions to read from or write to a disk 
  in a drive must be preceded by a call to one of two other functions, one old but 
  altered, the other new. </p>
  <p>This was a less of a change than might be supposed, because the kernel anyway 
  asks for a media check</p>
  <p>&nbsp;</p>
  <p>&nbsp;</p>
  <h3>PC DOS 1.10 </h3>
  <p>&nbsp;</p>
  <table class="DiskFormat">
    <colgroup>
      <col class="Property"><col class="Value" span="2">
    </colgroup>
    <thead>
      <tr>
        <th>&nbsp;</th>
        <th>Drive A I/O Driver 0, <br>
        Drive B I/O Driver 2, <br>
        Drive C I/O Driver 4 (If Present), <br>
        Drive D I/O Driver 6 (If Present) </th>
        <th>Drive A I/O Driver 1, <br>
        Drive B I/O Driver 3, <br>
        Drive C I/O Driver 5 (If Present), <br>
        Drive D I/O Driver 7 (If Present) </th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td>Sector Size (bytes): </td>
        <td>512 </td>
        <td>512 </td>
      </tr>
      <tr>
        <td>Cluster Size (sectors): </td>
        <td>1 </td>
        <td>2 </td>
      </tr>
      <tr>
        <td>Reserved Sectors: </td>
        <td>1 </td>
        <td>1 </td>
      </tr>
      <tr>
        <td>Number of FATs: </td>
        <td>2 </td>
        <td>2 </td>
      </tr>
      <tr>
        <td>Directory Capacity (directory entries): </td>
        <td>64 </td>
        <td>112 </td>
      </tr>
      <tr>
        <td>Disk Capacity (sectors): </td>
        <td>320 </td>
        <td>640 </td>
      </tr>
    </tbody>
  </table>
  <p>&nbsp;</p>
  <h3>MS-DOS 1.25 For SCP </h3>
  <p>&nbsp;</p>
  <table class="DiskFormat">
    <colgroup>
      <col class="Property"><col class="Value" span="4">
    </colgroup>
    <thead>
      <tr>
        <th>&nbsp;</th>
        <th>Drive A I/O Driver 0, <br>
        Drive B I/O Driver 2 </th>
        <th>Drive A I/O Driver 1, <br>
        Drive B I/O Driver 3 </th>
        <th>Drive C I/O Driver 4, <br>
        Drive D I/O Driver 6 </th>
        <th>Drive C I/O Driver 5, <br>
        Drive D I/O Driver 7 </th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td>Sector Size (bytes): </td>
        <td>128 </td>
        <td>1024 </td>
        <td>128 </td>
        <td>1024 </td>
      </tr>
      <tr>
        <td>Cluster Size (sectors): </td>
        <td>4 </td>
        <td>1 </td>
        <td>4 </td>
        <td>1 </td>
      </tr>
      <tr>
        <td>Reserved Sectors: </td>
        <td>1 </td>
        <td>1 </td>
        <td>52 </td>
        <td>1 </td>
      </tr>
      <tr>
        <td>Number of FATs: </td>
        <td>2 </td>
        <td>2 </td>
        <td>2 </td>
        <td>2 </td>
      </tr>
      <tr>
        <td>Directory Capacity (directory entries): </td>
        <td>68 </td>
        <td>192 </td>
        <td>64 </td>
        <td>128 </td>
      </tr>
      <tr>
        <td>Disk Capacity (sectors): </td>
        <td>2002 </td>
        <td>1232 </td>
        <td>2002 </td>
        <td>1232 </td>
      </tr>
    </tbody>
  </table>
  <p>&nbsp;</p>
  <div class="Footer">
    <p class="Dates">This page was created on 28th
    <a href="../../../new/21/10.htm">October 2021</a> and was last modified on 6th 
    November 2021. </p>
    <!--webbot bot="Include" U-Include="../../_include/c21.htm" TAG="BODY" startspan -->

<p class="Copyright">Copyright © 2021. Geoff Chappell. All rights reserved. 
<a href="../../../about/terms.htm">Conditions apply</a>. </p>

<!--webbot bot="Include" endspan i-checksum="40488" -->
  </div>
</div>

</body>

</html>
