<html>

<head>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
<title>FeatureBits in the KPRCB</title>
<link rel="stylesheet" type="text/css" href="../../../../../../_styles/master.css">
<link rel="stylesheet" type="text/css" href="../../../../../../_styles/document.css">
<link rel="stylesheet" type="text/css" href="../../../_styles/km.css">
<script type="text/javascript" src="../../../../../../_scripts/master.js"></script>
<script type="text/javascript" src="../../../../../../_scripts/document.js"></script>
<script type="text/javascript" src="../../../_scripts/km.js"></script>
</head>

<body>

<!--webbot bot="Include" U-Include="../../../_include/noscript.htm" TAG="BODY" startspan -->

<div class="NoScript" id="Banner">
  <div id="Links">
    <ul class="LinkList">
      <li class="LinkListItem"><a href="../../../../../../index.htm"><span>Home</span></a> </li>
      <li class="LinkListItem"><a target="_self" href="../../../toc.htm"><span>Table of Contents</span></a> </li>
      <li class="LinkListItem"><a href="../../../../../../about/index.htm"><span>About This Site</span></a> </li>
      <li class="LinkListItem"><a href="../../../../../../new/index.htm"><span>What’s New?</span></a> </li>
      <li class="LinkListItem"><a href="../../../../../../feedback/index.htm"><span>Feedback</span></a> </li>
      <li class="LinkListItem"><a href="../../../../../../consult/index.htm"><span>Consult</span></a> </li>
    </ul>
  </div>
  <div id="Logo">
    <p>Geoff Chappell, Software Analyst </p>
  </div>
</div>

<!--webbot bot="Include" endspan i-checksum="54033" -->
<h1>FeatureBits in the KPRCB </h1>
<p>Microsoft’s names for a smattering of the feature bits are known from 
assembly-language headers KS386.INC and KSAMD64.INC in various development kits, 
starting with the Device Driver Kit (DDK) for Windows Server 2003 SP1. Names for 
many feature bits might easily be hypothesised, since most correspond directly 
to a single bit in output from one or another <span class="instruction">cpuid</span> 
leaf. As manageable as that may be, it is unsound since the known names do not 
fit so straightforward a pattern. Since the known names are so few, they are 
given not in the table below but in notes at the end. </p>
<table class="Constants">
  <tr>
    <th>Mask (x86) </th>
    <th>Mask (x64) </th>
    <th>Summary Description </th>
    <th>Versions </th>
  </tr>
  <tr>
    <td>0x00000000`00000001 </td>
    <td>&nbsp;</td>
    <td><span class="bit">VME</span> bit (0x00000002) in <span class="register">
    edx</span> from <span class="instruction">cpuid</span> leaf 1 </td>
    <td>3.50 and higher </td>
  </tr>
  <tr>
    <td>&nbsp;</td>
    <td>0x00000000`00000001 </td>
    <td><span class="bit">SMEP</span> bit (0x00000080) in <span class="register">
    ebx</span> from <span class="instruction">cpuid</span> leaf 7 </td>
    <td>6.2 </td>
  </tr>
  <tr>
    <td>0x00000000`00000002 </td>
    <td>0x00000000`00000002 </td>
    <td><span class="bit">TSC</span> bit (0x00000010) in <span class="register">
    edx</span> from <span class="instruction">cpuid</span> leaf 1 (x86); <br>
    always set (x64) </td>
    <td>3.50 and higher </td>
  </tr>
  <tr>
    <td rowspan="2">0x00000000`00000004 </td>
    <td rowspan="2">0x00000000`00000004 </td>
    <td><span class="bit">MCE</span> bit (0x00000080) in <span class="register">
    edx</span> from <span class="instruction">cpuid</span> leaf 1 </td>
    <td>3.50 to 3.51 </td>
  </tr>
  <tr>
    <td><span class="bit">VME</span>, <span class="bit">PSE</span> or
    <span class="bit">PGE</span> bit in <span class="register">edx</span> from
    <span class="instruction">cpuid</span> leaf 1 (x86); <br>
    always set (x64) </td>
    <td>4.0 and higher </td>
  </tr>
  <tr>
    <td>0x00000000`00000008 </td>
    <td>0x00000000`00000008 </td>
    <td><span class="bit">CMOV</span> bit (0x00008000) in <span class="register">edx</span> 
    from <span class="instruction">cpuid</span> leaf 1 (x86); <br>
    always set (x64) </td>
    <td>4.0 and higher </td>
  </tr>
  <tr>
    <td>0x00000000`00000010 </td>
    <td>0x00000000`00000010 </td>
    <td><span class="bit">PGE</span> bit (0x00002000) in <span class="register">
    edx</span> from <span class="instruction">cpuid</span> leaf 1 (x86); <br>
    always set (x64) </td>
    <td>4.0 and higher </td>
  </tr>
  <tr>
    <td>0x00000000`00000020 </td>
    <td>0x00000000`00000020 </td>
    <td><span class="bit">PSE</span> bit (0x00000008) in <span class="register">
    edx</span> from <span class="instruction">cpuid</span> leaf 1 (x86); <br>
    always set (x64) </td>
    <td>4.0 and higher </td>
  </tr>
  <tr>
    <td>0x00000000`00000040 </td>
    <td>0x00000000`00000040 </td>
    <td><span class="bit">MTRR</span> bit (0x00001000) in <span class="register">
    edx</span> from <span class="instruction">cpuid</span> leaf 1 (x86); <br>
    always set (x64) </td>
    <td>4.0 and higher </td>
  </tr>
  <tr>
    <td>0x00000000`00000080 </td>
    <td>0x00000000`00000080 </td>
    <td><span class="bit">CX8</span> bit (0x00000100) in <span class="register">
    edx</span> from <span class="instruction">cpuid</span> leaf 1 (x86); <br>
    always set (x64) </td>
    <td>4.0 and higher </td>
  </tr>
  <tr>
    <td>0x00000000`00000100 </td>
    <td>0x00000000`00000100 </td>
    <td><span class="bit">MMX</span> bit (0x00800000) in <span class="register">
    edx</span> from <span class="instruction">cpuid</span> leaf 1 (x86); <br>
    always set (x64) </td>
    <td>4.0 and higher </td>
  </tr>
  <tr>
    <td>0x00000000`00000200 </td>
    <td>&nbsp;</td>
    <td>set by default; <br>
    clear for some early Intel steppings, see note&nbsp; </td>
    <td>5.0 and higher </td>
  </tr>
  <tr>
    <td>&nbsp;</td>
    <td>0x00000000`00000200 </td>
    <td><span class="bit">DS</span> bit (0x00200000) in <span class="register">
    edx</span> from <span class="instruction">cpuid</span> leaf 1 </td>
    <td>late 5.2 to 6.2 </td>
  </tr>
  <tr>
    <td>0x00000000`00000400 </td>
    <td>0x00000000`00000400 </td>
    <td><span class="bit">PAT</span> bit (0x00010000) in <span class="register">
    edx</span> from <span class="instruction">cpuid</span> leaf 1 (x86); <br>
    always set (x64) </td>
    <td>5.0 and higher </td>
  </tr>
  <tr>
    <td>0x00000000`00000800 </td>
    <td>0x00000000`00000800 </td>
    <td><span class="bit">FXSR</span> bit (0x01000000) in <span class="register">
    edx</span> from <span class="instruction">cpuid</span> leaf 1 (x86); <br>
    always set (x64) </td>
    <td>5.0 and higher </td>
  </tr>
  <tr>
    <td>0x00000000`00001000 </td>
    <td>0x00000000`00001000 </td>
    <td><span class="bit">SEP</span> bit (0x00000800) in <span class="register">
    edx</span> from <span class="instruction">cpuid</span> leaf 1 (x86); <br>
    always set (x64) </td>
    <td>5.1 and higher </td>
  </tr>
  <tr>
    <td>0x00000000`00002000 </td>
    <td>0x00000000`00002000 </td>
    <td><span class="bit">SSE</span> bit (0x02000000) in <span class="register">
    edx</span> from <span class="instruction">cpuid</span> leaf 1 (x86); <br>
    always set (x64) </td>
    <td>5.0 and higher </td>
  </tr>
  <tr>
    <td>0x00000000`00004000 </td>
    <td>0x00000000`00004000 </td>
    <td><span class="bit">3DNow</span> bit (0x80000000) in
    <span class="register">edx</span> from <span class="instruction">cpuid</span> 
    leaf 0x80000001 </td>
    <td>5.0 and higher (x86); <br>
    late 5.2 to 6.2 (x64) </td>
  </tr>
  <tr>
    <td>0x00000000`00008000 </td>
    <td>&nbsp;</td>
    <td>AMD-specific MTRR support </td>
    <td>5.0 to 6.1 </td>
  </tr>
  <tr>
    <td>&nbsp;</td>
    <td>0x00000000`00008000 </td>
    <td>&nbsp;</td>
    <td>&nbsp;</td>
  </tr>
  <tr>
    <td>0x00000000`00010000 </td>
    <td>0x00000000`00010000 </td>
    <td><span class="bit">SSE2</span> bit (0x04000000) in <span class="register">
    edx</span> from <span class="instruction">cpuid</span> leaf 1 (x86); <br>
    always set (x64) </td>
    <td>5.1 and higher </td>
  </tr>
  <tr>
    <td>0x00000000`00020000 </td>
    <td>&nbsp;</td>
    <td><span class="bit">DS</span> bit (0x00200000) in <span class="register">
    edx</span> from <span class="instruction">cpuid</span> leaf 1 </td>
    <td>5.1 and higher </td>
  </tr>
  <tr>
    <td>&nbsp;</td>
    <td>0x00000000`00020000 </td>
    <td>see note </td>
    <td>6.1 to 6.2 </td>
  </tr>
  <tr>
    <td rowspan="3">0x00000000`00040000 </td>
    <td rowspan="3">&nbsp;</td>
    <td><span class="bit">HTT</span> bit (0x10000000) in <span class="register">
    edx</span> from <span class="instruction">cpuid</span> leaf 1 </td>
    <td>5.1 only </td>
  </tr>
  <tr>
    <td>apparently unused </td>
    <td>5.2 only </td>
  </tr>
  <tr>
    <td><span class="bit">CLFSH</span> bit (0x00080000) in <span class="register">
    edx</span> from <span class="instruction">cpuid</span> leaf 1 </td>
    <td>6.0 and higher </td>
  </tr>
  <tr>
    <td>&nbsp;</td>
    <td>0x00000000`00040000 </td>
    <td>&nbsp;</td>
    <td>&nbsp;</td>
  </tr>
  <tr>
    <td>0x00000000`00080000 </td>
    <td>0x00000000`00080000 </td>
    <td><span class="bit">SSE3</span> bit (0x00000001) in <span class="register">
    ecx</span> from <span class="instruction">cpuid</span> leaf 1 </td>
    <td>6.0 and higher </td>
  </tr>
  <tr>
    <td>&nbsp;</td>
    <td>0x00000000`00100000 </td>
    <td><span class="bit">CMPXCHG16B</span> (0x00002000) in
    <span class="register">ecx</span> from <span class="instruction">cpuid</span> 
    leaf 1 </td>
    <td>6.0 to 6.2 </td>
  </tr>
  <tr>
    <td rowspan="2">0x00000000`00100000 </td>
    <td rowspan="2">0x00000000`00200000 </td>
    <td>0x00010000 bit in <span class="register">ecx</span> from
    <span class="instruction">cpuid</span> leaf 1 </td>
    <td>6.0 only </td>
  </tr>
  <tr>
    <td>vendor is AuthenticAMD and family is 5 or higher (x86); <br>
    vendor is AuthenticAMD (x64) </td>
    <td>6.1 and higher </td>
  </tr>
  <tr>
    <td>0x00000000`00200000 </td>
    <td>0x00000000`00400000 </td>
    <td>0x00000002 bit in <span class="register">ecx</span> from
    <span class="instruction">cpuid</span> leaf 6 </td>
    <td>6.1 and higher </td>
  </tr>
  <tr>
    <td>0x00000000`00400000 </td>
    <td>0x00000000`00800000 </td>
    <td>see note </td>
    <td>6.1 and higher </td>
  </tr>
  <tr>
    <td>0x00000000`00800000 </td>
    <td>0x00000000`01000000 </td>
    <td>vendor is GenuineIntel </td>
    <td>6.1 and higher </td>
  </tr>
  <tr>
    <td>0x00000000`01000000 </td>
    <td>&nbsp;</td>
    <td><span class="bit">SMEP</span> bit (0x00000080) in <span class="register">
    ebx</span> from <span class="instruction">cpuid</span> leaf 7 </td>
    <td>6.2 and higher </td>
  </tr>
  <tr>
    <td>0x00000000`02000000 </td>
    <td>&nbsp;</td>
    <td><span class="bit">RDRAND</span> bit (0x40000000) in <span class="register">
    ecx</span> from <span class="instruction">cpuid</span> leaf 1 </td>
    <td>6.3 and higher </td>
  </tr>
  <tr>
    <td>&nbsp;</td>
    <td>0x00000000`02000000 </td>
    <td>&nbsp;</td>
    <td>&nbsp;</td>
  </tr>
  <tr>
    <td>0x00000000`04000000 </td>
    <td>0x00000000`04000000 </td>
    <td>see note </td>
    <td>6.2 and higher </td>
  </tr>
  <tr>
    <td>0x00000000`08000000 </td>
    <td>0x00000000`08000000 </td>
    <td>see note </td>
    <td>6.2 and higher </td>
  </tr>
  <tr>
    <td>&nbsp;</td>
    <td>0x00000000`10000000 </td>
    <td><span class="bit">FSGSBASE</span> bit (0x00000001) in
    <span class="register">ecx</span> from <span class="instruction">cpuid</span> 
    leaf 7 </td>
    <td>6.2 and higher </td>
  </tr>
  <tr>
    <td>0x00000000`20000000 </td>
    <td>0x00000000`20000000 </td>
    <td><span class="bit">NX</span> bit (0x00100000) in <span class="register">
    edx</span> from <span class="instruction">cpuid</span> leaf 0x80000001; <br>
    always set (x64 in 6.2 and higher) </td>
    <td>late 5.2 and higher </td>
  </tr>
  <tr>
    <td>0x00000000`40000000 </td>
    <td>0x00000000`40000000 </td>
    <td>&nbsp;</td>
    <td>&nbsp;</td>
  </tr>
  <tr>
    <td>0x00000000`80000000 </td>
    <td>0x00000000`80000000 </td>
    <td>&nbsp;</td>
    <td>&nbsp;</td>
  </tr>
  <tr>
    <td>&nbsp;</td>
    <td>0x00000001`00000000 </td>
    <td><span class="bit">RDRAND</span> bit (0x40000000) in <span class="register">
    ecx</span> from <span class="instruction">cpuid</span> leaf 1 </td>
    <td>10.0 and higher </td>
    </tr>
  <tr>
    <td>&nbsp;</td>
    <td>0x00000002`00000000 </td>
    <td>&nbsp;</td>
    <td>&nbsp;</td>
  </tr>
  <tr>
    <td>0x00000001`00000000 </td>
    <td>0x00000004`00000000 </td>
    <td><span class="bit">RDTSCP</span> bit (0x08000000) bit in <span class="register">edx</span> from
    <span class="instruction">cpuid</span> leaf 0x80000001 </td>
    <td>10.0 and higher </td>
  </tr>
  <tr>
    <td>0x00000002`00000000 </td>
    <td>&nbsp;</td>
    <td><span class="bit">CLFLUSHOPT</span> bit (0x00800000) in
    <span class="register">ebx</span> from <span class="instruction">cpuid</span> 
    leaf 7 </td>
    <td>10.0 and higher </td>
  </tr>
  <tr>
    <td>0x00000004`00000000 </td>
    <td>&nbsp;</td>
    <td><span class="bit">HDC</span> bit (0x00002000) in <span class="register">
    eax</span> from <span class="instruction">cpuid</span> leaf 6 </td>
    <td>10.0 and higher </td>
  </tr>
  <tr>
    <td>0x00000008`00000000 </td>
    <td>&nbsp;</td>
    <td>&nbsp;</td>
    <td>&nbsp;</td>
  </tr>
  <tr>
    <td>&nbsp;</td>
    <td>0x00000008`00000000 </td>
    <td>&nbsp;</td>
    <td>&nbsp;</td>
    </tr>
  <tr>
    <td>&nbsp;</td>
    <td>0x00000010`00000000 </td>
    <td>&nbsp;</td>
    <td>&nbsp;</td>
    </tr>
  <tr>
    <td>&nbsp;</td>
    <td>0x00000020`00000000 </td>
    <td>0x04000000 bit in <span class="register">edx</span> from
    <span class="instruction">cpuid</span> leaf 0x80000001 </td>
    <td>1607 and higher </td>
    </tr>
  <tr>
    <td>&nbsp;</td>
    <td>0x00000040`00000000 </td>
    <td>&nbsp;</td>
    <td>&nbsp;</td>
    </tr>
  <tr>
    <td>&nbsp;</td>
    <td>0x00000080`00000000 </td>
    <td>&nbsp;</td>
    <td>&nbsp;</td>
    </tr>
  <tr>
    <td>&nbsp;</td>
    <td>0x00000100`00000000 </td>
    <td>&nbsp;</td>
    <td>&nbsp;</td>
    </tr>
  <tr>
    <td>0x00000010`00000000 <br>
    </td>
    <td>0x00000200`00000000 </td>
    <td>&nbsp;</td>
    <td>&nbsp;</td>
  </tr>
</table>
<p>Microsoft’s assembly-language name for the 0x00000001 feature bit is
<span class="constant">KF_V86_VIS</span>. Versions before 4.0 recognise this 
feature bit if the vendor is GenuineIntel or AuthenticAMD but then discard it. 
Version 4.0 extends the recognition to CyrixInstead. Its effect in all known x86 
versions is to set the <span class="bit">VME</span> bit in
<span class="register">cr4</span> for all processors (though only at startup and 
not at all if the <span class="regvalue">DisableVme</span> registry value is 
present). </p>
<p>The name <span class="constant">KF_RDTSC</span> is known for the 0x00000002 
feature bit in both 32-bit and 64-bit Windows. Again, detection for early 
versions is restricted to particular vendors: GenuineIntel and AuthenticAMD 
before version 4.0, adding CyrixInstead in version 4.0. </p>
<p>From Microsoft’s known name <span class="constant">KF_CR4</span> 
for it in both 32-bit and 64-bit Windows, the 0x00000004 feature bit seems intended to record whether the processor has the
<span class="register">cr4</span> register. There is no direct test for this 
register’s presence. Intel’s manuals have it that “Control register CR4 was 
introduced in the Pentium processor” and the kernel’s earliest code for saving 
and restoring the processor’s control state takes as granted that
<span class="register">cr4</span> can be read and written as long as the
<span class="member">CpuType</span>, i.e., processor family, is at least 5. Starting with version 4.0, 
however, it tests for whether <span class="constant">KF_CR4</span> was 
discovered for the feature bits. Discovery is by inference. Some features are 
enabled only by setting a bit in <span class="register">cr4</span>. If
<span class="instruction">cpuid</span> tells that such a feature is present, 
then presumably <span class="register">cr4</span> is too. In versions 3.50 and 
3.51, this inference is made solely from the <span class="bit">MCE</span> 
feature and only then if the vendor is GenuineIntel. (That said, it is not yet 
ruled out that the intention truly was to test for the <span class="bit">MCE</span> 
feature.) Version 4.0 looks instead 
for any of several 
others: </p>
<ul>
  <li><span class="bit">VME</span>, for GenuineIntel, AuthenticAMD or 
  CyrixInstead; </li>
  <li><span class="bit">PSE</span> or <span class="bit">PGE</span> for 
  GenuineIntel or CyrixInstead. </li>
</ul>
<p>The 0x00000008, <span class="constant">KF_GLOBAL_PAGE</span> and <span class="constant">KF_LARGE_PAGE</span> 
feature bits are detected in version 4.0 only if the vendor is GenuineIntel or 
CyrixInstead. Though this constraint is abandoned in version 5.0, all later 
versions until at least the 1803 release of Windows 10 ignore one or more of 
these features in some early AMD processors. It is not known whether AMD and 
Intel had different meanings for the <span class="bit">PSE</span>, <span class="bit">
PGE</span> and <span class="bit">CMOV</span> bits or whether AMD’s 
implementation was thought unsafe to use, but all three bits are ignored in the
<span class="instruction">cpuid</span> report of all AuthenticAMD processors 
whose family is less than 5. In versions 5.1 through 6.1, the
<span class="bit">PGE</span> bit is ignored 
for family 5 up to and including model 1 stepping 3. </p>
<p>The 0x00000040 feature bit is detected in version 4.0 only if the vendor is 
GenuineIntel. </p>
<p>The <span class="constant">KF_CMPXCHG8B</span> feature bit is detected in 
version 4.0 if the vendor is GenuineIntel, AuthenticAMD or CyrixInstead. Version 
5.0 removes this restriction. Version 5.1 provides specially for other 
manufacturers whose processors may have their <span class="instruction">cpuid</span> 
instruction report that <span class="bit">CX8</span> is not supported even 
though they do have a working <span class="instruction">cmpxchg8b</span> 
instruction. They’ll have designed their processors this way for the 
understandable reason that they wanted their wares to work with the original 
Windows NT 4.0 and its first few service packs. </p>
<p>The 0x00000200 feature bit is cleared for GenuineIntel processors whose 
family is 6 and either the model is 1 up to and including stepping 9 or the 
model is 3 up to and including stepping 4. For these early processors, a routine 
for flushing translation buffers gets patched to an alternative that works 
synchronously, presumably to correct for a known defect in these processors. </p>
<p>The <span class="constant">KF_FAST_SYSCALL</span> feature bit is known to the 
kernel in version 5.0 as indicating that some returns to user mode can go 
through the <span class="instruction">sysexit</span> instruction instead of
<span class="instruction">iret</span>, but no code for detecting the feature is 
known in any x86 build of Windows 2000. In version 5.1 and higher, support for 
the <span class="bit">SEP</span> feature is ignored in Intel processors that aren’t 
at least family 6, model 3, stepping 3. </p>
<p>That the <span class="constant">KF_FAST_SYSCALL</span> feature bit is 
necessarily set for 64-bit Windows is presumably because the <span class="bit">
SYSCALL</span> bit (0x00000800) is set in <span class="register">edx</span> from
<span class="instruction">cpuid</span> leaf 0x80000001. </p>
<p>The 0x00004000 feature bit indicates the AMD-specific 3DNow instruction set. 
Except on an AuthenticAMD process whose family is less than 5, the kernel 
executes <span class="instruction">cpuid</span> leaf 0x80000000 to discover what 
extended information is available. A return in <span class="register">eax</span> 
between 0x80000000 and 0x800000FF is taken to be the highest leaf for extended 
information. If this is at least 0x80000001, then the kernel executes
<span class="instruction">cpuid</span> leaf 0x80000001. If the vendor is 
AuthenticAMD, then a set 0x80000000 bit in <span class="register">edx</span> 
indicates support for 3DNow. </p>
<p>The 0x00008000 feature bit is set for AuthenticAMD processors whose family is 
5, starting with model 8 stepping 8 and continuing to all steppings of model 9. 
It indicates that the kernel uses AMD-specific coding when loading Memory Type 
Range Registers (MTRR). This code, and the feature bit too, was removed for 
Windows 8. </p>
<p>The 0x00020000 feature bit for 64-bit Windows has the known assembly-language 
name <span class="constant">KF_BRANCH</span>. It is set for processors that the 
kernel recognises as having Model Specific Registers for keeping a Last Branch 
Record (LBR). This functionality is assumed for all AMD processors. For Intel 
processors, it is not so much detected as inferred from the family and model. 
Version 6.1 recognises it for family 6, models 15, 22, 23 and 26. </p>
<p>That <span class="instruction">cpuid</span> sets the <span class="bit">HTT</span> 
bit in <span class="register">edx</span> means that information is also returned 
in <span class="register">ebx</span> to tell of “the Maximum number of 
addressable IDs for logical processors in this package.” Windows XP extracts 
this into the <span class="struct">KPRCB</span> as the <span class="member">
LogicalProcessorsPerPhysicalProcessor</span> member. That it also makes a 
feature bit of it, 0x00040000, was soon recognised as unnecessary, which gives 
the first example of a feature bit eventually getting repurposed. </p>
<p>In version 6.0 only, the 0x00100000 feature bit on 64-bit Windows is simply 
assumed if the vendor is GenuineIntel. For other vendors, and for Intel in later 
versions, it is set only if availability of the <span class="instruction">
cmpxchg16b</span> instruction is established by the appropriate
<span class="instruction">cpuid</span> query. </p>
<p>The 0x00100000 feature bit is recognised only for GenuineIntel processors in 
version 6.0. </p>
<p>The 0x00200000 feature bit for 64-bit Windows Vista is recognised only for 
GenuineIntel processors. The 0x00010000 bit in <span class="register">ecx</span> 
from <span class="instruction">cpuid</span> leaf 1 is described by Intel as 
reserved. The kernel takes it as a cue to enable User-Mode Instruction 
Prevention (UMIP) by setting the <span class="bit">UMIP</span> bit in
<span class="register">cr4</span>. </p>
<p>The 0x00200000 and 0x00400000 feature bit for 32-bit and 64-bit Windows, 
respectively, are recognised only for GenuineIntel processors. It 
causes the kernel to set the 0x08000000 bit in Model Specific Register 0x01A0
<span class="constant">(IA32_MISC_ENABLE</span>) for every processor. Both the 
<span class="instruction">cpuid</span> bit for the detection and this MSR bit for the action are described by 
Intel as reserved. </p>
<p>The 0x01000000 feature bit is recognised only for GenuineIntel processors in 
versions 6.2 and 6.3. Version 10.0 detects it also for AuthenticAMD processors. </p>
<p>The 0x04000000 feature bit is detected differently for GenuineIntel and 
AuthenticAMD processors. There is a series of requirements for Intel: </p>
<ul>
  <li>a set <span class="bit">VMX</span> bit (0x00000020) in
  <span class="register">ecx</span> from <span class="instruction">cpuid</span> 
  leaf 1; </li>
  <li>a set 0x80000000`00000000 bit in Model Specific Register 0x0482 (<span class="constant">IA32_VMX_PROCBASED_CTLS</span>);
  </li>
  <li>a set 0x00000002`00000000 bit in Model Specific Register 0x048A (<span class="constant">IA32_VMX_PROCBASED_CTLS2</span>).
  </li>
</ul>
<p>For AMD processors, the test is simply whether the <span class="bit">NP</span> 
bit (0x00000001) is set in <span class="register">edx</span> from
<span class="instruction">cpuid</span> leaf 0x8000000A. </p>
<p>The 0x08000000 feature bit also has different methods of detection for 
GenuineIntel and AuthenticAMD processors. For Intel: </p>
<ul>
  <li>a set <span class="bit">VMX</span> bit (0x00000020) in
  <span class="register">ecx</span> from <span class="instruction">cpuid</span> 
  leaf 1; </li>
  <li>set 0x00000001 and 0x00000004 bits in Model Specific Register 0x3A (<span class="constant">IA32_FEATURE_CONTROL</span>).
  </li>
</ul>
<p>Again, the test for AMD is seemingly simpler, just whether the 0x00000010 bit 
is clear in Model Specific Register 0xC0010114. </p>
<p>The 0x20000000 feature bit is the first that depends on extended information 
from <span class="instruction">cpuid</span> but is not AMD-specific. The name
<span class="bit">NX</span> for the 0x00100000 bit in <span class="register">edx</span> 
from <span class="instruction">cpuid</span> leaf 0x80000001 is AMD’s. Intel does 
not name it but describes it as meaning “Execute Disable Bit available.” </p>
<p>The 0x00000002`00000000 and 0x00000004`00000000 feature bits are detected 
only if the vendor is GenuineIntel. HDC is Hardware Duty Cycling. </p>
<div class="Footer">
  <p class="Dates">This page was created on 6th January 2020. </p>
  <!--webbot bot="Include" U-Include="../../../_include/c20.htm" TAG="BODY" startspan -->

<p class="Copyright">Copyright © 2020. Geoff Chappell. All rights reserved. 
<a href="../../../../../../about/terms.htm">Conditions apply</a>. </p>

<!--webbot bot="Include" endspan i-checksum="61845" -->
</div>
</body>

</html>
