<!doctype html>
<html lang="en">

<head>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
<title>HV_HYPERVISOR_INTERFACE_INFO</title>
<link rel="stylesheet" type="text/css" href="../../../../../../../_styles/master.css">
<link rel="stylesheet" type="text/css" href="../../../../../../../_styles/document.css">
<link rel="stylesheet" type="text/css" href="../../../../_styles/km.css">
<script type="text/javascript" src="../../../../../../../_scripts/master.js"></script>
<script type="text/javascript" src="../../../../../../../_scripts/document.js"></script>
<script type="text/javascript" src="../../../../_scripts/km.js" defer></script>
</head>

<body>

<!--webbot bot="Include" U-Include="../../../../_include/noscript.htm" TAG="BODY" startspan -->

<div class="NoScript" id="Banner">
  <div id="Links">
    <ul class="LinkList">
      <li> 
      <ul class="PreferNoWrap">
        <li class="LinkListItem"><a href="../../../../../../../index.htm">Home</a> </li><!--
     --><li class="LinkListItem"><a target="_self" href="../../../../toc.htm">Table of Contents</a> </li><!--
     --><li class="LinkListItem"><a href="../../../../../../../about/index.htm">About This Site</a> </li>
      </ul>
      <ul class="PreferNoWrap">
        <li class="LinkListItem"><a href="../../../../../../../new/index.htm">What’s New?</a> </li><!--
     --><li class="LinkListItem"><a href="../../../../../../../feedback/index.htm">Feedback</a> </li><!--
     --><li class="LinkListItem"><a href="../../../../../../../consult/index.htm">Consult</a> </li>
      </ul>
      </li>
    </ul>
  </div>
  <div id="Logo">
    <p><span class="PreferNoWrap">Geoff Chappell -</span> <span class="PreferNoWrap">Software Analyst</span> </p>
  </div>
</div>

<!--webbot bot="Include" endspan i-checksum="48540" -->
<div class="Main">
  <h1>HV_HYPERVISOR_INTERFACE_INFO </h1>
  <p>The <span class="struct">HV_HYPERVISOR_INTERFACE_INFO</span> structure (formally
  <span class="struct">_HV_HYPERVISOR_INTERFACE_INFO</span>) collects the information 
  that a hypervisor’s <span class="instruction">
  <a href="../../../../cpu/cpuid/index.htm">cpuid</a></span> leaf 0x40000001 produces 
  in the <span class="register">eax</span>, <span class="register">ebx</span>,
  <span class="register">ecx</span> and <span class="register">edx</span> registers. 
  It may also be intended to do the same for a Microsoft hypervisor’s implementation 
  of <span class="instruction">cpuid</span> leaf 0x40000081. </p>
  <h2>Availability </h2>
  <p>The <span class="struct">HV_HYPERVISOR_INTERFACE_INFO</span> is defined in 
  version 6.3 and higher, having developed from what had been an unnamed structure 
  that versions 6.0 to 6.2 define for the <span class="member">HvInterface</span> 
  member of the <span class="union"><a href="hv_cpuid_result.htm">HV_CPUID_RESULT</a></span> 
  union. </p>
  <h3>Access </h3>
  <p>The kernel provides two ways to get the whole output from
  <span class="instruction">cpuid</span> leaf 0x40000001 into a caller-supplied
  <span class="struct">HV_HYPERVISOR_INTERFACE_INFO</span>: </p>
  <ul>
    <li>in kernel mode, as the output from <span class="function">
    <a href="../../../api/hvilib/hviintel/gethypervisorinterface.htm">HviGetHypervisorInterface</a></span>;
    </li>
    <li>in user mode too, as the <span class="member">HypervisorInterface</span> 
    member of the <span class="struct">
    <a href="../../api/ntexapi/system_hypervisor_detail_information.htm">SYSTEM_HYPERVISOR_DETAIL_INFORMATION</a></span> 
    that is the output of a successful call to <span class="function">
    <a href="../../../api/ex/sysinfo/query.htm">ZwQuerySystemInformation</a></span> 
    when given the information class <span class="constant">SystemHypervisorDetailInformation</span> 
    (0x9F). </li>
  </ul>
  <p>Both are available only in version 10.0 or higher. </p>
  <h2>Documentation Status </h2>
  <p>The <span class="struct">HV_HYPERVISOR_INTERFACE_INFO</span> structure itself 
  is not documented. Its members, having previously been defined in the
  <span class="union">HV_CPUID_RESULT</span>, are documented in the Windows Driver 
  Kit (WDK) for Windows 7, which also provided a C-language definition (of the structure’s 
  unnamed ancestor) in the HVGDK.H header file. Except that documentation continued 
  to a separately downloadable package for merging into Visual Studio 2012, later 
  kits have neither the documentation nor the header. </p>
  <p>The structure anyway repackages material that Microsoft documents in the
  <a href="https://msdn.microsoft.com/en-us/virtualization/hyperv_on_windows/reference/tlfs">
  Hypervisor Top-Level Functional Specification</a> (TLFS). If it or its members’ 
  previous definitions have become undocumented, it may be just that Microsoft regards 
  the structure as no more than a convenience for Microsoft’s own programming in 
  the loader and kernel, if not in the hypervisor itself. </p>
  <h2>Layout </h2>
  <p>The <span class="struct">HV_HYPERVISOR_INTERFACE_INFO</span> is 0x10 bytes 
  in both 32-bit and 64-bit Windows, as was the unnamed structure that it was developed 
  from. The definition of members has never changed. </p>
  <p>Offsets and definitions below are from type information in symbol files for 
  the kernel in Windows 8.1 (only) and for URLMON.DLL in Windows 8.1 through to 
  the 1709 release of Windows 10. Well might you wonder what URLMON.DLL has to do 
  with the hypervisor such that its symbol files have type information for this 
  structure but the kernel’s don’t! Names and definitions for later versions, presently 
  up to and including Version 2004, are checked against type information in a statically 
  linked library named KDHV.LIB which Microsoft distributes with programming samples 
  in the Debugging Tools for Windows. </p>
  <p>Also checked are earlier versions for which the <span class="struct">HV_HYPERVISOR_INTERFACE_INFO</span> 
  was not yet a named structure. Offsets, names and types are from (in roughly decreasing 
  order of forensic quality): the C-language definition of the
  <span class="union">HV_CPUID_RESULT</span> in the WDK for Windows 7; type information 
  in symbol files for URLMON.DLL for Windows 8; and type information in the statically 
  linked library CLFSMGMT.LIB from the Software Development Kit (SDK) for Windows 
  Vista. </p>
  <table class="Struct">
    <colgroup>
      <col class="Offset"><col class="Definition">
    </colgroup>
    <thead>
      <tr>
        <th>Offset </th>
        <th>Definition </th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td>0x00 </td>
        <td>
        <pre class="source">UINT32 Interface;</pre>
        </td>
      </tr>
      <tr>
        <td>0x04 </td>
        <td>
        <pre class="source">UINT32 Reserved1;</pre>
        </td>
      </tr>
      <tr>
        <td>0x08 </td>
        <td>
        <pre class="source">UINT32 Reserved2;</pre>
        </td>
      </tr>
      <tr>
        <td>0x0C </td>
        <td>
        <pre class="source">UINT32 Reserved3;</pre>
        </td>
      </tr>
    </tbody>
  </table>
  <p>The kernel deems the hypervisor as Microsoft-compatible if the
  <span class="member">Interface</span> is '1#vH’, reading as “Hv#1” when looking 
  at the structure as an array of bytes. The integer value is defined in the HVGDK.H 
  file as the <span class="constant">HvMicrosoftHypervisorInterface</span> in an
  <span class="enum"><a href="hv_hypervisor_interface.htm">HV_HYPERVISOR_INTERFACE</a></span> 
  enumeration, as if there may be more even if Microsoft only cares about one.
  </p>
  <p>Aside from retrieving the whole of the <span class="instruction">cpuid</span> 
  output on behalf of external callers, as noted above as Access, the kernel interprets 
  the <span class="member">Interface</span> for callers of
  <span class="function">
  <a href="../../../api/hvilib/hviintel/ishypervisormicrosoftcompatible.htm">HviIsHypervisorMicrosoftCompatible</a></span>. 
  Through much of the early history of hypervisors, the only interest that the kernel 
  itself has in the <span class="member">Interface</span> is that a Microsoft-compatible 
  hypervisor is assumed to support <span class="instruction">cpuid</span> leaves 
  0x40000002 to 0x40000005 inclusive such that no need exists to check these leaves 
  against the <span class="member">MaxFunction</span> from
  <span class="instruction">cpuid</span> leaf 0x40000000. </p>
  <p>Starting with the 1607 release of WIndows 10, the kernel knows of a second 
  hypervisor interface. For this, the <span class="member">Interface</span> is 'vnbX', 
  reading from low to high as “Xbnv”. All these versions, both 32-bit and 64-bit, 
  exempt this hypervisor interface from counting as a hypervisor. Specifically, 
  the undocumented kernel export <span class="function">
  <a href="../../../api/hvilib/hviintel/isanyhypervisorpresent.htm">HviIsAnyHypervisorPresent</a></span> 
  answers in the negative if <a href="../../../../cpu/cpuid/00000001h/ecx.htm">
  <span class="register">ecx</span> from <span class="instruction">cpuid</span> 
  leaf 1</a> says that a hypervisor is present but <span class="register">eax</span> 
  from <span class="instruction">cpuid</span> leaf 0x40000001 says the hypervisor 
  that’s present is this one. The 64-bit kernel has an internal routine that checks 
  for this interface once and caches the answer in an internal variable. In some 
  versions the routine is (also) instantiated and its name passes into the public 
  symbol files: <span class="internal routine">HviIsXboxNanovisorPresent</span>, 
  apparently confirming that “Xbnv” stands for Xbox Nanovisor. </p>
  <p>Starting with 64-bit Windows 8 and 32-bit WIndows 8.1, the boot manager, boot 
  loader and a changing selection of other software (but not the kernel) know of 
  a <span class="instruction">cpuid</span> leaf 0x40000081 whose output also fits 
  the <span class="struct">HV_HYPERVISOR_INTERFACE_INFO</span>. The expected
  <span class="member">InterfaceName</span> is '1#SV'. It signifies the existence 
  of a <span class="instruction">cpuid</span> leaf 0x40000082 whose output is a 
  set of bit flags. </p>
  <div class="Footer">
    <p class="Dates">This page was created on 13th
    <a href="../../../../../../../new/16/11.htm">November 2016</a>. and was last 
    modified on 10th December 2022. </p>
    <!--webbot bot="Include" U-Include="../../../../_include/c1622.htm" TAG="BODY" startspan -->

<p class="Copyright">Copyright © 2016-2022. Geoff Chappell. All rights reserved. 
<a href="../../../../../../../about/terms.htm">Conditions apply</a>. </p>

<!--webbot bot="Include" endspan i-checksum="4925" -->
  </div>
</div>

</body>

</html>
