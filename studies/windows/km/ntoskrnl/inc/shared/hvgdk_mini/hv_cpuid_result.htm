<!doctype html>
<html lang="en">

<head>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
<title>HV_CPUID_RESULT</title>
<link rel="stylesheet" type="text/css" href="../../../../../../../_styles/master.css">
<link rel="stylesheet" type="text/css" href="../../../../../../../_styles/document.css">
<link rel="stylesheet" type="text/css" href="../../../../_styles/km.css">
<script type="text/javascript" src="../../../../../../../_scripts/master.js"></script>
<script type="text/javascript" src="../../../../../../../_scripts/document.js"></script>
<script type="text/javascript" src="../../../../_scripts/km.js" defer></script>
</head>

<body>

<!--webbot bot="Include" U-Include="../../../../_include/noscript.htm" TAG="BODY" startspan -->

<div class="NoScript" id="Banner">
  <div id="Links">
    <ul class="LinkList">
      <li> 
      <ul class="PreferNoWrap">
        <li class="LinkListItem"><a href="../../../../../../../index.htm">Home</a> </li><!--
     --><li class="LinkListItem"><a target="_self" href="../../../../toc.htm">Table of Contents</a> </li><!--
     --><li class="LinkListItem"><a href="../../../../../../../about/index.htm">About This Site</a> </li>
      </ul>
      <ul class="PreferNoWrap">
        <li class="LinkListItem"><a href="../../../../../../../new/index.htm">What’s New?</a> </li><!--
     --><li class="LinkListItem"><a href="../../../../../../../feedback/index.htm">Feedback</a> </li><!--
     --><li class="LinkListItem"><a href="../../../../../../../consult/index.htm">Consult</a> </li>
      </ul>
      </li>
    </ul>
  </div>
  <div id="Logo">
    <p><span class="PreferNoWrap">Geoff Chappell -</span> <span class="PreferNoWrap">Software Analyst</span> </p>
  </div>
</div>

<!--webbot bot="Include" endspan i-checksum="48540" -->
<div class="Main">
  <h1>HV_CPUID_RESULT </h1>
  <p>The <span class="union">HV_CPUID_RESULT</span> union (formally
  <span class="union">_HV_CPUID_RESULT</span>) collects the various sorts of flags 
  and other data that a Microsoft-compatible hypervisor’s implementation of the
  <span class="instruction"><a href="../../../../cpu/cpuid/index.htm">cpuid</a></span> 
  instruction produces in the <span class="register">eax</span>,
  <span class="register">ebx</span>, <span class="register">ecx</span> and
  <span class="register">edx</span> registers. </p>
  <h2>Documentation Status </h2>
  <p>The <span class="union">HV_CPUID_RESULT</span> is documented in the Windows 
  Driver Kit (WDK) for Windows 7, which was the last to have documentation included. 
  This kit also provides a C-language definition in the HVGDK.H header file. Except 
  that documentation continued to a separately downloadable package for merging 
  into Visual Studio 2012, later kits have neither the documentation nor the header. 
  A search through Google today, 13th November 2016, produces just five results 
  for the name, none from Microsoft. </p>
  <p>If the <span class="union">HV_CPUID_RESULT</span> has become undocumented, 
  it may be that Microsoft regards the structure as no more than a convenience for 
  Microsoft’s own programming in the loader and kernel, if not in the hypervisor 
  itself. The <span class="union">HV_CPUID_RESULT</span> just repackages material 
  that Microsoft document elsewhere. </p>
  <p>The obvious, if not the only, candidate for elsewhere is the
  <a href="https://msdn.microsoft.com/en-us/virtualization/hyperv_on_windows/reference/tlfs">
  Hypervisor Top-Level Functional Specification</a> (TLFS) which today, 12th November 
  2016, offers as its most recent version a PDF that is three years old. The reality 
  behind the superficially fine words of the Microsoft Open Specification Promise 
  is that the Hyper-V implementation, and presumably Microsoft’s use of it to Microsoft’s 
  advantage for Microsoft’s purposes, runs years ahead of the documentation that 
  Microsoft opens for general use. &nbsp;</p>
  <p>As for the <span class="union">HV_CPUID_RESULT</span> as Microsoft’s particular 
  packaging of its hypervisor’s output from <span class="instruction">cpuid</span> 
  leaves, disclosure since the WDK for Windows 7 is conspicuously thin. The practical 
  equivalent of a C-language definition is published as type information in symbol 
  files, but in the downloadable packages of public symbols for 32-bit and 64-bit 
  Windows 10, type information for <span class="union">HV_CPUID_RESULT</span> appears
  <span class="emphasis">only</span> in the symbol files for URLMON.DLL. This is 
  a user-mode DLL that originated as a component of Internet Explorer (and still 
  follows Internet Explorer’s version numbering). Well might you wonder what this 
  DLL has to do with the hypervisor such that its symbol files have type information 
  for this structure but the kernel’s don’t! Symbol files for URLMON.DLL starting 
  with Windows 8, both in packages of Windows symbols and when downloaded from Microsoft’s 
  public symbol server, happen to be private symbols. This surely was an oversight, 
  but however this disclosure came about, Microsoft stopped it for Version 1803. 
  That URLMON.DLL knows of the <span class="union">HV_CPUID_RESULT</span> is because 
  some URLMON.DLL source file has a <span class="directive">#include</span> for 
  a header named <a href="../../../source/inc/hvgdk_mini.htm">hvgdk_mini.h</a>. 
  Microsoft is known to use his header for its own programming of the Windows kernel 
  but is not known to have ever made it available for use by programmers in general 
  (let alone by the programmers of competing web browsers). </p>
  <p>Type information for the <span class="union">HV_CPUID_RESULT</span> also turns 
  out to have been hiding in the relatively plain sight of two statically linked 
  libraries. One, named CLFSMGMT.LIB, is among the many that are supplied with the 
  Software Development Kit (SDK) for user-mode programming. Type information in 
  this library has the special value of confirming that the <span class="union">
  HV_CPUID_RESULT</span> was defined as long ago as Windows Vista, i.e., before 
  Microsoft published HVGDK.H for Windows 7. Against this is that type information 
  for <span class="union">HV_CPUID_RESULT</span> is not in all versions of the library. 
  It doesn’t start in the 64-bit library until WIndows 8 and it drops out for both 
  32-bit and 64-bit in Version 2004. Beware anyway that type information in statically 
  linked libraries has less forensic value (than in the operating system’s symbol 
  files) because it does not always match the operating system that the library 
  is supposedly intended for. </p>
  <p>The other static library that has type information for the
  <span class="union">HV_CPUID_RESULT</span> is more obviously related to hypervisors. 
  It is named KDHV.LIB. Microsoft distributes it among the programming samples in 
  the Debugging Tools for Windows. It has type information for the
  <span class="union">HV_CPUID_RESULT</span> for all versions of Windows 10 at least 
  to the 2004 release. </p>
  <h2>Layout </h2>
  <p>The <span class="union">HV_CPUID_RESULT</span> is 0x10 bytes in both 32-bit 
  and 64-bit Windows. Offsets, names and types in the tabulation below are from 
  (in roughly decreasing order of forensic quality): the C-language definition in 
  the WDK for Windows 7; type information in symbol files for the kernel in Windows 
  8.1 (only) and for URLMON.DLL in Windows 8 through to the 1709 release of Windows 
  10; and type information in most versions of CLFSMGMT.LIB from Windows Vista through 
  to the 1903 release of Windows 10 and in KDHV.LIB from the original Windows 10 
  and higher. </p>
  <p>The <span class="union">HV_CPUID_RESULT</span> is a union whose many branches 
  allow for different interpretations of the <span class="instruction">cpuid</span> 
  output, both in general and for specific <span class="instruction">cpuid</span> 
  leaves: </p>
  <ul>
    <li>an anonymous structure of dword members, one for each register; </li>
    <li>an array of dword members, one for each register; </li>
    <li>an unnamed structure for the output of
    <a href="../../../../cpu/cpuid/00000001h/index.htm">
    <span class="instruction">cpuid</span> leaf 0x00000001</a>; </li>
    <li>structures for the output of <span class="instruction">cpuid</span> leaves 
    starting at 0x40000000. </li>
  </ul>
  <p>The first member of the union, originally, but swapped with the second in Version 
  1703, is an unnamed structure for access to each dword that
  <span class="instruction">cpuid</span> produces in its four output registers:
  </p>
  <table class="Struct">
    <colgroup>
      <col class="Offset"><col class="Definition"><col class="Versions">
    </colgroup>
    <thead>
      <tr>
        <th>Offset </th>
        <th>Definition </th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td>0x00 </td>
        <td>
        <pre class="source">UINT32 Eax;</pre>
        </td>
      </tr>
      <tr>
        <td>0x04 </td>
        <td>
        <pre class="source">UINT32 Ebx;</pre>
        </td>
      </tr>
      <tr>
        <td>0x08 </td>
        <td>
        <pre class="source">UINT32 Ecx;</pre>
        </td>
      </tr>
      <tr>
        <td>0x0C </td>
        <td>
        <pre class="source">UINT32 Edx;</pre>
        </td>
      </tr>
    </tbody>
  </table>
  <p>A second member, originally, but then the first after the rearrangement for 
  Version 1703, provides for similar access but as an array: </p>
  <pre class="source">UINT32 AsUINT32 [4];</pre>
  <h3>Intel Leaf 1 </h3>
  <p>A third member, named <span class="member">VersionAndFeatures</span>, is defined 
  inline as an unnamed structure. It picks out two items that are produced by the 
  Intel-defined <span class="instruction">cpuid</span> leaf 1 but which have particular 
  interest to a hypervisor. </p>
  <table class="Struct">
    <colgroup>
      <col class="Offset"><col class="Definition">
    </colgroup>
    <thead>
      <tr>
        <th>Offset </th>
        <th>Definition </th>
        <th>Versions </th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td>0x00 </td>
        <td>
        <pre class="source">UINT32 ReservedEax;</pre>
        </td>
        <td>6.0 and higher </td>
      </tr>
      <tr>
        <td rowspan="2">0x04 </td>
        <td>
        <pre class="source">UINT32 ReservedEbx;</pre>
        </td>
        <td>6.0 only </td>
      </tr>
      <tr>
        <td>
        <pre class="source"> UINT32 ReservedEbx : 24;
UINT32 InitialApicId : 8;       // 0xFF000000</pre>
        </td>
        <td>6.1 and higher </td>
      </tr>
      <tr>
        <td>0x08 </td>
        <td>
        <pre class="source"> UINT32 ReservedEcx : 31;
UINT32 HypervisorPresent : 1;   // 0x80000000</pre>
        </td>
        <td>6.0 and higher </td>
      </tr>
      <tr>
        <td>0x0C </td>
        <td>
        <pre class="source">UINT32 ReservedEdx;</pre>
        </td>
        <td>6.0 and higher </td>
      </tr>
    </tbody>
  </table>
  <p>Type information in CLFSMGMT.LIB has it that <span class="constant">InitialApicId</span> 
  is not defined before Windows 8, no matter that the published HVGDK.H shows it 
  for Windows 7. It may have been defined only shortly before the final build for 
  Windows 7: the library in the Windows 7 SDK was built a month before the Windows 
  7 kernel (11th June 2009 versus 14th July). </p>
  <p>The <span class="member">HypervisorPresent</span> flag is described in Intel’s
  <span class="instruction">cpuid</span> documentation as “Not Used” and “Always 
  returns 0”. If this bit is set, the kernel infers that some sort of hypervisor 
  is present such that <span class="instruction">cpuid</span> supports the vendor-neutral 
  leaves 0x40000000 and 0x40000001. The first tells how far this sequence of hypervisor 
  leaves continues, the second whether the higher-numbered leaves conform to Microsoft’s 
  interface. </p>
  <h3>Hypervisor Leaves </h3>
  <p>The remaining members are specialised for input values of
  <span class="register">eax</span> beginning at 0x40000000 as expected by a Microsoft-compatible 
  hypervisor. They were at first arranged in increasing order of this input, but 
  then Version 1703 moved two to the front. Another irregularity that is yet to 
  be explained is that although Windows 10 inserts <span class="member">MsHvPlatformCapabilities</span> 
  among these members that plainly correspond to CPU leaves, the kernel is not known 
  to query any <span class="instruction">cpuid</span> leaf in the 0x40000000 series 
  for anything like the flags that are defined for that member. (Present thinking 
  is that <span class="member">MsHvPlatformCapabilities</span> is instead for
  <span class="instruction">cpuid</span> leaf 0x40000082 in an undocumented second 
  set of hypervisor leaves at 0x40000080.) </p>
  <p>Before version 6.3, each member other than <span class="member">MsHvVersion</span> 
  is defined inline as an unnamed structure. These inline definitions are not reproduced 
  below. To find what these early versions define for a leaf, refer to the separate 
  notes on the structure that corresponds to the leaf in later versions. </p>
  <table class="Union">
    <colgroup>
      <col class="Remarks"><col class="Definition"><col class="Versions">
    </colgroup>
    <thead>
      <tr>
        <th>Leaf </th>
        <th>Definition </th>
        <th>Versions </th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td>&nbsp;</td>
        <td>
        <pre class="source"><a href="hv_x64_platform_capabilities.htm">HV_X64_PLATFORM_CAPABILITIES</a> MsHvPlatformCapabilities;</pre>
        </td>
        <td>1703 and higher </td>
      </tr>
      <tr>
        <td>0x4000000A </td>
        <td>
        <pre class="source"><a href="hv_hypervisor_nested_virt_features.htm">HV_HYPERVISOR_NESTED_VIRT_FEATURES</a> MsHvNestedVirtFeatures;</pre>
        </td>
        <td>1703 and higher </td>
      </tr>
      <tr>
        <td rowspan="2">0x40000000 </td>
        <td>
        <pre class="source">struct {
    /*  two members, follow link  */
} HvVendorAndMaxFunction;</pre>
        </td>
        <td>6.0 to 6.2 </td>
      </tr>
      <tr>
        <td>
        <pre class="source"><a href="hv_vendor_and_max_function.htm">HV_VENDOR_AND_MAX_FUNCTION</a> HvVendorAndMaxFunction;</pre>
        </td>
        <td>6.3 and higher </td>
      </tr>
      <tr>
        <td rowspan="2">0x40000001 </td>
        <td>
        <pre class="source">struct {
    /*  four members, follow link  */
} HvInterface;</pre>
        </td>
        <td>6.0 to 6.2 </td>
      </tr>
      <tr>
        <td>
        <pre class="source"><a href="hv_hypervisor_interface_info.htm">HV_HYPERVISOR_INTERFACE_INFO</a> HvInterface;</pre>
        </td>
        <td>6.3 and higher </td>
      </tr>
      <tr>
        <td>0x40000002 </td>
        <td>
        <pre class="source"><a href="hv_hypervisor_version_info.htm">HV_HYPERVISOR_VERSION_INFO</a> MsHvVersion;</pre>
        </td>
        <td>6.0 and higher </td>
      </tr>
      <tr>
        <td rowspan="3">0x40000003 </td>
        <td>
        <pre class="source">struct {
    /*  changing members, follow link  */
} MsHvFeatures;</pre>
        </td>
        <td>6.0 to 6.2 </td>
      </tr>
      <tr>
        <td>
        <pre class="source"><a href="hv_hypervisor_features.htm">HV_HYPERVISOR_FEATURES</a> MsHvFeatures;</pre>
        </td>
        <td>6.3 only </td>
      </tr>
      <tr>
        <td>
        <pre class="source"><a href="hv_x64_hypervisor_features.htm">HV_X64_HYPERVISOR_FEATURES</a> MsHvFeatures;</pre>
        </td>
        <td>10.0 and higher </td>
      </tr>
      <tr>
        <td rowspan="3">0x40000004 </td>
        <td>
        <pre class="source">struct {
    /*  changing members, follow link  */
} MsHvEnlightenmentInformation;</pre>
        </td>
        <td>6.0 to 6.2 </td>
      </tr>
      <tr>
        <td>
        <pre class="source"><a href="hv_enlightenment_information.htm">HV_ENLIGHTENMENT_INFORMATION</a> MsHvEnlightenmentInformation;</pre>
        </td>
        <td>6.3 only </td>
      </tr>
      <tr>
        <td>
        <pre class="source"><a href="hv_x64_enlightenment_information.htm">HV_X64_ENLIGHTENMENT_INFORMATION</a> MsHvEnlightenmentInformation;</pre>
        </td>
        <td>10.0 and higher </td>
      </tr>
      <tr>
        <td rowspan="2">0x40000005 </td>
        <td>
        <pre class="source">struct {
    /*  changing members, follow link  */
} MsHvImplementationLimits;</pre>
        </td>
        <td>6.0 to 6.2 </td>
      </tr>
      <tr>
        <td>
        <pre class="source"><a href="hv_implementation_limits.htm">HV_IMPLEMENTATION_LIMITS</a> MsHvImplementationLimits;</pre>
        </td>
        <td>6.3 and higher </td>
      </tr>
      <tr>
        <td rowspan="3">0x40000006 </td>
        <td>
        <pre class="source">struct {
    /*  changing members, follow link  */
} MsHvHardwareFeatures;</pre>
        </td>
        <td>6.2 only </td>
      </tr>
      <tr>
        <td>
        <pre class="source"><a href="hv_hypervisor_hardware_features.htm">HV_HYPERVISOR_HARDWARE_FEATURES</a> MsHvHardwareFeatures;</pre>
        </td>
        <td>6.3 only </td>
      </tr>
      <tr>
        <td>
        <pre class="source"><a href="hv_x64_hypervisor_hardware_features.htm">HV_X64_HYPERVISOR_HARDWARE_FEATURES</a> MsHvHardwareFeatures;</pre>
        </td>
        <td>10.0 and higher </td>
      </tr>
      <tr>
        <td>&nbsp;</td>
        <td>
        <pre class="source">HV_X64_PLATFORM_CAPABILITIES MsHvPlatformCapabilities;</pre>
        </td>
        <td>10.0 to 1607 </td>
      </tr>
      <tr>
        <td>0x40000007 </td>
        <td>
        <pre class="source"><a href="hv_x64_hypervisor_cpu_management_features.htm">HV_X64_HYPERVISOR_CPU_MANAGEMENT_FEATURES</a> MsHvCpuManagementFeatures;</pre>
        </td>
        <td>10.0 and higher </td>
      </tr>
      <tr>
        <td>0x40000008 </td>
        <td>
        <pre class="source"><a href="hv_hypervisor_svm_features.htm">HV_HYPERVISOR_SVM_FEATURES</a> MsHvSvmFeatures;</pre>
        </td>
        <td>10.0 and higher </td>
      </tr>
      <tr>
        <td>0x4000000A </td>
        <td>
        <pre class="source">HV_HYPERVISOR_NESTED_VIRT_FEATURES MsHvNestedVirtFeatures;</pre>
        </td>
        <td>1511 to 1607 </td>
      </tr>
      <tr>
        <td>0x4000000B </td>
        <td>
        <pre class="source"><a href="hv_hypervisor_ipt_features.htm">HV_HYPERVISOR_IPT_FEATURES</a> MsHvIptFeatures;</pre>
        </td>
        <td>1903 and higher </td>
      </tr>
    </tbody>
  </table>
  <p>Note that the members’ names have prefixes that differentiate
  <span class="instruction">cpuid</span> leaves 0x40000000 and 0x40000001 as generic 
  and subsequent leaves as particular to Microsoft hypervisors. </p>
  <h2>Known Use By Microsoft </h2>
  <p>Incidentally, symbol files for the Windows 8.1 kernel reveal that the
  <span class="union">HV_CPUID_RESULT</span> is used for two internal routines, 
  apparently only ever inlined (at least in some instances into other routines that 
  are defined in headers): </p>
  <pre class="source">VOID HvipClearCpuIdResult (HV_CPUID_RESULT *);
VOID HvipCpuId (ULONG, HV_CPUID_RESULT *);</pre>
  <div class="Footer">
    <p class="Dates">This page was created on 12th
    <a href="../../../../../../../new/16/11.htm">November 2016</a> and was last 
    modified on 11th December 2022. </p>
    <!--webbot bot="Include" U-Include="../../../../_include/c1622.htm" TAG="BODY" startspan -->

<p class="Copyright">Copyright © 2016-2022. Geoff Chappell. All rights reserved. 
<a href="../../../../../../../about/terms.htm">Conditions apply</a>. </p>

<!--webbot bot="Include" endspan i-checksum="4925" -->
  </div>
</div>

</body>

</html>
