<html>

<head>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
<title>InitCommonControlsEx</title>
<link rel="stylesheet" type="text/css" href="../../../../../../_styles/master.css">
<link rel="stylesheet" type="text/css" href="../../../../../../_styles/document.css">
<link rel="stylesheet" type="text/css" href="../../../_styles/shell.css">
<script type="text/javascript" src="../../../../../../_scripts/master.js"></script>
<script type="text/javascript" src="../../../../../../_scripts/document.js"></script>
<script type="text/javascript" src="../../../_scripts/shell.js"></script>
</head>

<body>

<!--webbot bot="Include" u-include="../../../_include/noscript.htm" tag="BODY" startspan -->

<div class="NoScript" id="Banner">
  <div id="Links">
    <ul class="LinkList">
      <li class="LinkListItem"><a href="../../../../../../index.htm"><span>Home</span></a> </li>
      <li class="LinkListItem"><a target="_self" href="../../../toc.htm"><span>Table of Contents</span></a> </li>
      <li class="LinkListItem"><a href="../../../../../../about/index.htm"><span>About This Site</span></a> </li>
      <li class="LinkListItem"><a href="../../../../../../new/index.htm"><span>What’s New?</span></a> </li>
      <li class="LinkListItem"><a href="../../../../../../feedback/index.htm"><span>Feedback</span></a> </li>
      <li class="LinkListItem"><a href="../../../../../../consult/index.htm"><span>Consult</span></a> </li>
    </ul>
  </div>
  <div id="Logo">
    <p>Geoff Chappell - Software Analyst </p>
  </div>
</div>

<!--webbot bot="Include" i-checksum="55064" endspan -->
<h1>InitCommonControlsEx </h1>
<h2>Declaration </h2>
<pre class="source">BOOL InitCommonControlsEx (INITCOMMONCONTROLSEX const *picce);</pre>
<p>Since the <span class="struct">INITCOMMONCONTROLSEX</span> structure is apparently 
used only for this function, its definition is as well given here: </p>
<pre class="source">typedef struct tagINITCOMMONCONTROLSEX {
    DWORD dwSize;
    DWORD dwICC;
} INITCOMMONCONTROLSEX, *LPINITCOMMONCONTROLSEX;</pre>
<h3>Parameters </h3>
<p>The <span class="argument">picce</span> argument provides the address of a small 
structure that specifies which common controls to initialise. </p>
<h3>Return Value </h3>
<p>The function returns TRUE for success, else FALSE. </p>
<h2>Behaviour </h2>
<p>The function fails if the <span class="argument">picce</span> argument is NULL. 
Otherwise, this argument is taken as addressing an <span class="struct">INITCOMMONCONTROLSEX</span> 
structure. The function fails if the <span class="member">dwSize</span> member is 
not the size, in bytes, of this structure. The <span class="member">dwICC</span> 
member is then interpreted as bit flags. The function fails if any invalid flags 
are set. The valid flags select initialisations to perform. If any initialisation 
fails, then so does the function. </p>
<p>Each of these initialisations registers window classes for one or more of the
<a href="../../controls/index.htm">common controls</a>. Note that the initialisations 
are repeatable, as when the same flag is set in multiple calls to the function. 
The purpose of the function is thus to ensure that the window classes for the wanted 
types of common control are registered in advance of trying to create any of the 
controls. </p>
<p>The following table lists the valid flags. Each flag is shown with the controls 
whose window classes are to be registered if the flag is set. This table is also 
a convenient place in which to summarise which COMCTL32 versions support which flags.
</p>
<table class="Constants">
  <colgroup>
    <col class="Name"><col class="Name"><col class="Remarks">
    <col class="Versions">
  </colgroup>
  <tr>
    <th>Value </th>
    <th>Symbolic Name </th>
    <th>Controls to Register </th>
    <th>Applicable Versions </th>
  </tr>
  <tr>
    <td>0x0001 </td>
    <td><span class="constant">ICC_LISTVIEW_CLASSES</span> </td>
    <td>List-View Control <br>
    Header Control </td>
    <td>&nbsp;</td>
  </tr>
  <tr>
    <td>0x0002 </td>
    <td><span class="constant">ICC_TREEVIEW_CLASSES</span> </td>
    <td>ToolTip Control <br>
    Tree-View Control </td>
    <td>&nbsp;</td>
  </tr>
  <tr>
    <td>0x0004 </td>
    <td><span class="constant">ICC_BAR_CLASSES</span> </td>
    <td>Toolbar Control <br>
    ToolTip Control <br>
    Status Bar <br>
    Trackbar Control </td>
    <td>&nbsp;</td>
  </tr>
  <tr>
    <td>0x0008 </td>
    <td><span class="constant">ICC_TAB_CLASSES</span> </td>
    <td>ToolTip Control <br>
    Tab Control </td>
    <td>&nbsp;</td>
  </tr>
  <tr>
    <td>0x0010 </td>
    <td><span class="constant">ICC_UPDOWN_CLASS</span> </td>
    <td>Up-Down Control </td>
    <td>&nbsp;</td>
  </tr>
  <tr>
    <td>0x0020 </td>
    <td><span class="constant">ICC_PROGRESS_CLASS</span> </td>
    <td>Progress Bar Control </td>
    <td>&nbsp;</td>
  </tr>
  <tr>
    <td>0x0040 </td>
    <td><span class="constant">ICC_HOTKEY_CLASS</span> </td>
    <td>Hot Key Control </td>
    <td>&nbsp;</td>
  </tr>
  <tr>
    <td>0x0080 </td>
    <td><span class="constant">ICC_ANIMATE_CLASS</span> </td>
    <td>Animation Control </td>
    <td>&nbsp;</td>
  </tr>
  <tr>
    <td rowspan="2">0x0100 </td>
    <td rowspan="2"><span class="constant">ICC_DATE_CLASSES</span> </td>
    <td>Month Calendar Control <br>
    Date and Time Picker Control </td>
    <td>&nbsp;</td>
  </tr>
  <tr>
    <td>DropDown </td>
    <td>6.10 and higher </td>
  </tr>
  <tr>
    <td>0x0200 </td>
    <td><span class="constant">ICC_USEREX_CLASSES</span> </td>
    <td>ComboBoxEx Control </td>
    <td>&nbsp;</td>
  </tr>
  <tr>
    <td>0x0400 </td>
    <td><span class="constant">ICC_COOL_CLASSES</span> </td>
    <td>Rebar Control </td>
    <td>4.70 and higher </td>
  </tr>
  <tr>
    <td>0x0800 </td>
    <td><span class="constant">ICC_INTERNET_CLASSES</span> </td>
    <td>IP Address Control </td>
    <td>4.71 and higher </td>
  </tr>
  <tr>
    <td>0x1000 </td>
    <td><span class="constant">ICC_PAGESCROLLER_CLASS</span> </td>
    <td>Pager Control </td>
    <td>4.71 and higher </td>
  </tr>
  <tr>
    <td>0x2000 </td>
    <td><span class="constant">ICC_NATIVEFNTCTL_CLASS</span> </td>
    <td>Native Font Control </td>
    <td>4.71 and higher </td>
  </tr>
  <tr>
    <td>0x4000 </td>
    <td><span class="constant">ICC_STANDARD_CLASSES</span> </td>
    <td>Button Control <br>
    Static Control <br>
    Edit Control <br>
    ListBox Control <br>
    ComboBox Control <br>
    ComboLBox Control <br>
    Scroll Bar <br>
    Reader Mode Control </td>
    <td>6.0 and higher </td>
  </tr>
  <tr>
    <td>0x8000 </td>
    <td><span class="constant">ICC_LINK_CLASS</span> </td>
    <td>SysLink Control </td>
    <td>6.0 and higher </td>
  </tr>
</table>
<h3>Variations </h3>
<p>Version 4.0 does not guard against invalid flags. </p>
<p>Though not shown in the table, the <span class="constant">ICC_STANDARD_CLASSES</span> 
flag is supported in versions 5.80 and 5.81, but trivially. It is not rejected as 
invalid, but neither does it select an initialisation to perform. In version 5.82, 
the flag becomes invalid again. </p>
<h4>Initialisation for WINLOGON </h4>
<p>Also not shown in the table is an undocumented flag, 0x80000000, which is supported 
in version 5.81 and higher. It is unusual in not causing COMCTL32 to register a 
window class. It appears to be intended for use by WINLOGON.EXE to arrange a reset 
of COMCTL32. Useful details would seem to require more study of the COMCTL32 subclassing 
functions (and of WINLOGON) than is presently within the scope of these notes.
</p>
<p>In versions 5.82 and 6.10 from Windows Vista, and higher, the 0x80000000 flag 
has only trivial support. It is not rejected as invalid, but neither does it select 
an initialisation to perform. </p>
<h4>Control Initialisations </h4>
<p>The history of COMCTL32 includes some subtle changes to the algorithm for initialising 
each control. In calling these changes subtle, it is here meant that the variations 
might easily be overlooked as uninteresting, even really uninteresting, except that 
they turn out to have some practical consequences which Microsoft certainly has 
realised yet doesn’t document. </p>
<h5>Original </h5>
<p>COMCTL32’s original algorithm for initialising each control is to register the 
corresponding class if it is not already registered: </p>
<ul>
  <li>if the class is already registered (in the sense that
  <span class="function">GetClassInfo</span> succeeds), then the initialisation 
  succeeds; </li>
  <li>if the class can be registered, then the initialisation succeeds; </li>
  <li>otherwise, the initialisation fails and so does the function. </li>
</ul>
<p>A slight variation applies to the controls represented by
<span class="constant">ICC_DATE_CLASSES</span>. These are handled together, such 
that only the class for the Month Calendar Control is checked before attempting 
registration of classes for both that control and the Date and Time Picker Control.
</p>
<p>This original algorithm leaves <span class="function">InitCommonControlsEx</span> 
prone to fail in programs that may call the function from more than one thread. 
If the calls overlap, it may happen that a class does not exist at the first step 
but the subsequent attempt to register the class fails because it has meanwhile 
got registered from another thread. </p>
<h5>Early Builds of Version 6.0 </h5>
<p>The first attempt, chronologically, to address this problem of atomic class registration 
came with the builds of version 6.0 from before Windows XP SP2. For all but one 
control, the steps in the original algorithm are reversed: </p>
<ul>
  <li>if the class can be registered, then the initialisation succeeds; </li>
  <li>if the class is registered anyway (in the sense that
  <span class="function">GetClassInfo</span> succeeds), then the initialisation 
  succeeds; </li>
  <li>otherwise, the initialisation fails and so does the function. </li>
</ul>
<p>For who can know what reason, the Scroll Bar control is treated differently. 
For it, there is just the attempt at registration. If this fails, then so does the 
initialisation (and thence the function). </p>
<p>In these builds of version 6.0, Microsoft may have tried to solve a problem that 
matters only when multiple calls from different threads happen to overlap, but has 
instead made a problem whenever multiple calls are made to
<span class="function">InitCommonControlsEx</span> with <span class="constant">ICC_STANDARD_CLASSES</span> 
set, whether overlapped or not. The first call will typically succeed, but the repeats 
are doomed to fail because the class for the Scroll Bar control is already registered. 
This has practical consequences even for programmers who mean to call
<span class="function">InitCommonControlsEx</span> just once in their program: as 
described later, a programmer’s one and only call to <span class="function">InitCommonControlsEx</span> 
always is in fact a repeated call, because an earlier call is made by COMCTL32 itself 
at process attachment. </p>
<h5>Later Builds of Version 6.0 </h5>
<p>The builds of version 6.0 from Windows XP SP2 and higher, but excluding Windows 
XP SP3, refine the test for whether the class is already registered: </p>
<ul>
  <li>if the class can be registered, then the initialisation succeeds; </li>
  <li>if the error code from the failed registration is <span class="constant">ERROR_CLASS_ALREADY_EXISTS</span>, 
  then the initialisation succeeds; </li>
  <li>otherwise, the initialisation fails and so does the function. </li>
</ul>
<p>Yet still the Scroll Bar is treated differently—not just from the other controls 
but from the previous builds. Its initialisation is still just to register the class, 
but failure is now ignored. </p>
<h5>Later Builds of Version 5.82 </h5>
<p>The first builds of version 5.82 retain the original algorithm, as if they have 
do not have the problem with atomic class registration which needed to be fixed 
for version 6.0. Perhaps it was only when COMCTL32 was used as an assembly that 
overlapping calls to <span class="function">InitCommonControlsEx</span> from different 
threads were ever seen. Eventually, however, version 5.82 changed too—just not to 
anything like what’s done for the corresponding builds of version 6.0. </p>
<p>In builds of version 5.82 from Windows XP SP2 and higher, but excluding Windows 
XP SP3, the algorithm is greatly simplified: just register the class and ignore 
any failure. All initialisations always succeed. </p>
<h5>Version 6.10 </h5>
<p>The great simplification for later builds of version 5.82 is also the practical 
effect of changes made for version 6.10 as far as concerns the success or failure 
of <span class="function">InitCommonControlsEx</span>. The algorithm for initialising 
a control is just to register the corresponding class and assume success. All initialisations 
always succeed. </p>
<p>However, failure to register a class is not exactly ignored. As discussed later, 
COMCTL32 remembers which classes it has registered, so that they can be un-registered 
at process detachment. The algorithm is in full: </p>
<ul>
  <li>if the class can be registered, then the initialisation succeeds and the class 
  is remembered as registered; </li>
  <li>if the error code from the failed registration is <span class="constant">ERROR_CLASS_ALREADY_EXISTS</span>, 
  then the initialisation succeeds and the class is remembered as registered;
  </li>
  <li>otherwise, the initialisation <span class="emphasis">succeeds</span> but the 
  class is remembered as <span class="emphasis">not</span> registered. </li>
</ul>
<h5>Windows XP SP3 </h5>
<p>An entirely different solution is ventured in the versions 5.82 and 6.0 from 
Windows XP SP3 specifically: </p>
<ul>
  <li>if an atom is already known for the class (from a previous initialisation), 
  then the initialisation succeeds; </li>
  <li>if the class can be registered, then the initialisation succeeds and the class 
  atom is remembered; </li>
  <li>if the error code from the failed registration is <span class="constant">ERROR_CLASS_ALREADY_EXISTS</span>, 
  then the initialisation succeeds; </li>
  <li>otherwise, the initialisation fails and so does the function. </li>
</ul>
<p class="draft">Chronologically, this release appeared among the Windows Vista 
service packs. Perhaps the algorithm that is broadly similar for versions 5.82 and 
6.10 from Windows Vista was not thought entirely satisfactory (which arguably it 
is not), such that a revision was attempted but then abandoned, surviving only in 
Windows XP SP3. </p>
<p>Given that <span class="function">InitCommonControlsEx</span> is presented as 
a simple function in Microsoft’s own documentation and that it is easy to find commentary 
on the Internet to the effect that the function is almost trivial, Microsoft has 
certainly made very heavy work of this problem of registering a window class if 
and only if it does not already exist. The problem must of course be handled atomically 
within USER32, such that it ought to have a simple and sound solution. Is it that 
Microsoft’s COMCTL32 programmers know or suspect that something is very wrong in 
USER32 such that the atomicity of its handling is unreliable? More plausible perhaps 
is that Microsoft’s own programmers can be as befuddled by sparse documentation 
as can anyone: see that Microsoft’s documentation of the <span class="function">
RegisterClass</span> function does not even go as far as saying whether the function 
succeeds or fails if the class is already registered. </p>
<h4>Activation Contexts </h4>
<p>One of the points, if not the main point, to the SxS versions of COMCTL32 is 
to redirect the window classes for some controls that would otherwise be implemented 
in USER32. An important piece of background is that the USER32 functions that work 
with window classes, e.g., <span class="function">RegisterClass</span> but also
<span class="function">GetClassInfo</span>, vary their behaviour depending on the 
current activation context (not that you would know this from Microsoft’s documentation 
of those functions). The same name may represent a different window class implemented 
in a different module, depending on which activation context, if any, is current 
when the function is called. The implication for COMCTL32 is that when
<span class="function">InitCommonControlsEx</span> registers window classes, it 
matters which activation context is current. </p>
<p>Early builds of versions 5.82 and 6.0 leave <span class="function">InitCommonControlsEx</span> 
to the caller’s choice of activation context. This is surely a bug and was eventually 
corrected. In builds of version 5.82 and 6.0 from Windows XP SP2, and higher, COMCTL32 
imposes its own activation context while <span class="function">InitCommonControlsEx</span> 
registers classes. </p>
<h4>Window Class Redirection </h4>
<p>Recent developments in USER32 take away much of the reason that
<span class="function">InitCommonControlsEx</span> exists. Starting with Windows 
XP, the USER32 functions for creating a window do not require that the window class 
is yet registered. If the window class is named in the current activation context, 
then USER32 can call the corresponding assembly to ask it to register the class 
before USER32 proceeds to create the window. </p>
<p>For this to work, the assembly must export a function named
<span class="function"><a href="registerclassnamew.htm">RegisterClassNameW</a></span>. 
In practice then, <span class="function">InitCommonControlsEx</span> is redundant 
for any program whose manifest asks for a sufficiently late COMCTL32 version:
</p>
<ul>
  <li>5.82 from Windows XP SP2 and higher, except for Windows XP SP3; </li>
  <li>6.0 from Windows XP SP2 and higher, except for Windows XP SP3; </li>
  <li>6.10 and higher </li>
</ul>
<h3>Implied Use </h3>
<p>The <span class="function">InitCommonControlsEx</span> function can be called 
automatically at process attachment, such that its explicit use by the programmer 
is often redundant. (Of course, this assumes that process attachment actually is 
attempted. If the program imports no other COMCTL32 function, which can easily enough 
be true in practice, then although the explicit call is redundant by the time it 
executes, its presence in the code may be the only reason that COMCTL32 gets loaded 
at all.) </p>
<p>This implied call most plausibly exists for backwards compatibility. In COMCTL32 
versions that precede the <span class="function">InitCommonControlsEx</span> function, 
all the supported controls are initialised automatically during process attachment. 
The introduction of <span class="function">InitCommonControlsEx</span> preserved 
this behaviour by calling the function at process attachment to initialise those 
same controls that are supported in earlier versions and which are now represented 
by the flags in <span class="constant">ICC_WIN95_CLASSES</span> (0xFF). </p>
<p>The treatment is not fully backwards-compatible, however: in versions that predate
<span class="function">InitCommonControlsEx</span>, if any of the automatic initialisations 
fail, then so does the process attachment, but this is mostly not true of the implied 
initialisations in later versions. Indeed, though all subsequent versions of COMCTL32 
have this implied call at process attachment, there is significant variation in 
the flags that are used for the call, in whether the call is made only in particular 
conditions, and in whether failure of the call is fatal to the process attachment.
</p>
<table class="Constants">
  <colgroup>
    <col class="Versions"><col class="Remarks" span="3">
  </colgroup>
  <tr>
    <th>Versions </th>
    <th>Flags </th>
    <th>Conditions </th>
    <th>Failure </th>
  </tr>
  <tr>
    <td>4.0 (NT) and 4.70 </td>
    <td><span class="constant">ICC_WIN95_CLASSES</span> </td>
    <td>&nbsp;</td>
    <td>ignored </td>
  </tr>
  <tr>
    <td>4.71 to 5.81 </td>
    <td><span class="constant">ICC_WIN95_CLASSES</span> </td>
    <td>&nbsp;</td>
    <td>fatal </td>
  </tr>
  <tr>
    <td>5.82 from Windows XP </td>
    <td>all documented flags (0x3FFF) </td>
    <td>&nbsp;</td>
    <td>fatal </td>
  </tr>
  <tr>
    <td>5.82 from Windows Server 2003 and higher </td>
    <td><span class="constant">ICC_WIN95_CLASSES</span> </td>
    <td>if running in 16-bit process </td>
    <td>ignored </td>
  </tr>
  <tr>
    <td>6.0 from Windows XP </td>
    <td>all documented flags (0xFFFF) </td>
    <td>&nbsp;</td>
    <td>ignored </td>
  </tr>
  <tr>
    <td>6.0 from Windows Server 2003, and higher </td>
    <td>all documented flags (0xBFFF) <br>
    except <span class="constant">ICC_STANDARD_CLASSES</span> </td>
    <td>if running in 16-bit process </td>
    <td>ignored </td>
  </tr>
</table>
<p>All that Microsoft’s documentation finds to say about any of these cases is:
</p>
<blockquote>
  <p><b>Windows XP</b>: If a manifest is used, <b>InitCommonControlsEx</b> is not 
  required. </p>
</blockquote>
<p>(Even this little got removed from the online documentation some time during 
2007 or 2008.) Although the statement is true, it would be true even without using 
a manifest. Perhaps its author at Microsoft had something else in mind entirely, 
but the simple fact is that the Windows XP builds of COMCTL32, for both version 
5.82 and 6.0, already have called <span class="function">InitCommonControlsEx</span> 
for all the documented flags before the programmer’s own code has a chance. The
<span class="function">InitCommonControlsEx</span> function is therefore redundant 
for the Windows XP builds, whether a manifest is used or not. Even for COMCTL32 
versions 5.81 and earlier, the implied call means that <span class="function">InitCommonControlsEx</span> 
is redundant for the controls that pre-date the function. </p>
<p>At least there’s no harm in any of that, just redundancy. However, Microsoft’s 
documentation conveniently understates a problem. In builds of version 6.0 from 
before Windows XP SP2, not only is <span class="function">InitCommonControlsEx</span> 
“not required” when a manifest is used, it is better left alone. For the programmer 
who thinks to include <span class="constant">ICC_STANDARD_CLASSES</span> among the 
flags, the function will be nothing but trouble. This is because these early builds 
have a defect, described above, concerning initialisation of the Scroll Bar control. 
Because of the implied call, which will almost certainly have succeeded, the programmer’s 
explicit call will fail. Microsoft cannot be ignorant of this case, nor of the trouble 
it may cause, so why isn’t it documented? </p>
<h3>Un-initialisation </h3>
<p>There is no function to undo the work of <span class="function">InitCommonControlsEx</span>. 
Indeed, early versions of COMCTL32 do not provide at all for un-registering the 
window classes for any common controls. It seems that un-registration was left to 
be done as the system’s normal cleanup for process termination. This may be fine 
if COMCTL32 is loaded automatically because COMCTL32 appears in the program’s import 
directory, but it is problematic if a program loads and unloads COMCTL32 dynamically: 
most of the controls have the <span class="constant">CS_GLOBALCLASS</span> style 
and therefore remain registered if COMCTL32 is unloaded. </p>
<p>Microsoft first addressed this problem in the builds of version 4.72 from Windows 
NT 4.0 SP4 and Internet Explorer 4.01 SP2. (The Microsoft blog
<a target="_top" href="http://blogs.msdn.com/oldnewthing/archive/2006/09/20/763727.aspx">
Don’t forget to unregister your window classes when your DLL shuts down dynamically</a> 
speaks of a hotfix, presumably from before these retail releases.) In these builds 
and subsequently, COMCTL32 un-registers the window classes for common controls while 
handling process detachment. (Though Microsoft’s documentation of
<span class="function">DllMain</span> advises against calling USER32 functions, 
it is presumably no less dangerous to call <span class="function">UnregisterClass</span> 
while handling process detachment than to call <span class="function">RegisterClass</span> 
while handling process attachment.) </p>
<p>The original algorithm for each control is to un-register the window class if
<span class="function">GetClassInfo</span> succeeds. In versions 5.82 and 6.0 from 
Windows XP SP2, and higher, the algorithm changes so that the window class for a 
control is un-registered if the initialisation algorithm for that control either 
succeeded at registering the window class or found that the class was already registered.
</p>
<h2>Availability </h2>
<p>The <span class="function">InitCommonControlsEx</span> function is exported by 
name from COMCTL32.DLL in version 4.70 and higher, but also in one build of version 
4.0. The function is certainly not exported from COMCTL32 in the original Windows 
95, but is in Internet Explorer 3.00 for Windows NT. (I have no copy of an Internet 
Explorer 3.00 for Windows 95. See the list of <a href="../../history/index.htm">
COMCTL32 versions</a> found for this survey.) </p>
<p>The function has long been documented, but not always. Though COMCTL32 versions 
that export this function had been on retail release for most of 1996, the function’s 
only mention in the January 1997 edition of the MSDN Library on CD is in two articles 
from <span class="citation">Microsoft Systems Journal</span> (dated October and 
November 1996) which promote development for Internet Explorer as the way to get 
“new and improved common controls” for arbitrary Windows programs. </p>
<p>The documentation puts the “minimum DLL version” at 4.70 for the
<span class="function">InitCommonControlsEx</span> function but at 4.71 for the
<span class="struct">INITCOMMONCONTROLSEX</span> structure. This discrepancy is 
present at least as early as the January 1999 edition of the MSDN Library on CD.
</p>
<p>A recent discrepancy affects the function’s declaration. The argument was for 
many years given simply as <span class="type">LPINITCOMMONCONTROLSEX</span>, which 
is equivalent to <span class="type">INITCOMMONCONTROLSEX *</span>. Sometime during 
2005 or 2006, the <span class="keyword">const</span> keyword was added, but inconsistently, 
to produce <span class="type">const INITCOMMONCONTROLSEX *</span> in the COMMCTRL.H 
from the Windows Vista SDK but <span class="type">const LPINITCOMMONCONTROLSEX</span> 
in the same SDK’s documentation. (The two are not the same. Microsoft’s compiler 
interprets them as <span class="type">INITCOMMONCONTROLSEX const *</span> and
<span class="type">INITCOMMONCONTROLSEX * const</span>, respectively.) </p>
<div class="Footer">
  <p class="Dates">This page was created on 30th May 2008 and was last modified 
  on 21st December 2009. </p>
  <!--webbot bot="Include" u-include="../../../_include/c0809.htm" tag="BODY" startspan -->

<p class="Copyright">Copyright © 2008-2009. Geoff Chappell. All rights reserved. 
<a href="../../../../../../about/terms.htm">Conditions apply</a>. </p>

<!--webbot bot="Include" i-checksum="55399" endspan -->
</div>

</body>

</html>
