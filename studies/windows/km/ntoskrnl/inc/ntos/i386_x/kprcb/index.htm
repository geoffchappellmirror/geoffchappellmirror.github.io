<!doctype html>
<html lang="en">

<head>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
<title>KPRCB (i386)</title>
<link rel="stylesheet" type="text/css" href="../../../../../../../../_styles/master.css">
<link rel="stylesheet" type="text/css" href="../../../../../../../../_styles/document.css">
<link rel="stylesheet" type="text/css" href="../../../../../_styles/km.css">
<script type="text/javascript" src="../../../../../../../../_scripts/master.js"></script>
<script type="text/javascript" src="../../../../../../../../_scripts/document.js"></script>
<script type="text/javascript" src="../../../../../_scripts/km.js" defer></script>
</head>

<body>

<!--webbot bot="Include" U-Include="../../../../../_include/noscript.htm" TAG="BODY" startspan -->

<div class="NoScript" id="Banner">
  <div id="Links">
    <ul class="LinkList">
      <li> 
      <ul class="PreferNoWrap">
        <li class="LinkListItem"><a href="../../../../../../../../index.htm">Home</a> </li><!--
     --><li class="LinkListItem"><a target="_self" href="../../../../../toc.htm">Table of Contents</a> </li><!--
     --><li class="LinkListItem"><a href="../../../../../../../../about/index.htm">About This Site</a> </li>
      </ul>
      <ul class="PreferNoWrap">
        <li class="LinkListItem"><a href="../../../../../../../../new/index.htm">What’s New?</a> </li><!--
     --><li class="LinkListItem"><a href="../../../../../../../../feedback/index.htm">Feedback</a> </li><!--
     --><li class="LinkListItem"><a href="../../../../../../../../consult/index.htm">Consult</a> </li>
      </ul>
      </li>
    </ul>
  </div>
  <div id="Logo">
    <p><span class="PreferNoWrap">Geoff Chappell -</span> <span class="PreferNoWrap">Software Analyst</span> </p>
  </div>
</div>

<!--webbot bot="Include" endspan i-checksum="33595" -->
<div class="Main">
  <h1>KPRCB (i386) </h1>
  <p>The name <span class="struct">KPRCB</span> stands for (Kernel) Processor Control 
  Block. The kernel keeps one <span class="struct">KPRCB</span> (formally
  <span class="struct">_KPRCB</span>) for each logical processor as the
  <span class="member">PrcbData</span> member of the same processor’s
  <span class="struct"><a href="../kpcr.htm">KPCR</a></span>. The
  <span class="struct">KPRCB</span> holds most of what the kernel needs ready access 
  to while managing a processor and while managing resources that are themselves 
  managed more simply (and quickly) per processor. Neither of these structures is 
  formally documented. Both are highly specific to the processor architecture. This 
  page concerns itself only with the <span class="struct">KPRCB</span> in 32-bit 
  Windows for the processor architecture that’s variously named i386 or x86. The 
  x64 <a href="../../amd64_x/kprcb/index.htm"><span class="struct">KPRCB</span> 
  (amd64)</a> is presented separately. </p>
  <h2>Access </h2>
  <p>Kernel-mode code can easily find the <span class="struct">KPRCB</span> for 
  whichever processor it’s executing on, by finding the current
  <span class="struct">KPCR</span> first. The latter is well-known to be accessible 
  through the <span class="register">fs</span> register. Its
  <span class="member">Prcb</span> member points to the <span class="struct">KPRCB</span> 
  without depending on it to be embedded in the <span class="struct">KPCR</span>. 
  Given a C-language definition of the <span class="struct">KPCR</span>, getting 
  the current processor’s <span class="struct">KPRCB</span> can be conveniently 
  wrapped into one inline function: </p>
  <pre class="source">FORCEINLINE
KPRCB *KeGetCurrentPrcb (VOID)
{
    return (KPRCB *) __readfsdword (FIELD_OFFSET (KPCR, Prcb));
}</pre>
  <p>which, less some dressing, is mostly how Microsoft’s own programmers have been 
  doing it, as confirmed by the NTOSP.H that Microsoft published (possibly by oversight) 
  in early editions of the Windows Driver Kit (WDK) for Windows 10. Go back far 
  enough, to version 5.0 and earlier, and the kernel has this as a self-standing 
  routine that is apparently written in assembly language. The .DBG symbol files 
  for Windows NT 4.0 not only name i386pcr.asm as the source file but even tell 
  us that the routine’s two instructions are at lines 61 and 64. </p>
  <p>The part of the <span class="struct">KPCR</span> that’s ahead of the embedded
  <span class="struct">KPRCB</span> is highly stable. Of particular importance is 
  that the offset of the <span class="member">Prcb</span> member is reliable over 
  all Windows versions. See <span class="instruction">dword ptr fs:[20h]</span> 
  in kernel-mode code for any 32-bit Windows version and you know that what’s sought 
  is the currently executing processor’s <span class="struct">KPRCB</span>. </p>
  <p>The <span class="struct">KPRCB</span> that <span class="member">Prcb</span> 
  points to is the <span class="member">PrcbData</span> member. Its offset within 
  the <span class="struct">KPCR</span> also is stable over all versions. Members 
  of the <span class="struct">KPRCB</span> are sometimes accessed through offsets 
  from the <span class="struct">KPCR</span>. For some members, this is even the 
  most usual access. Notably, the <span class="function">KeGetCurrentThread</span> 
  function is implemented very like </p>
  <pre class="source"><a href="../../ke/kthread/index.htm">KTHREAD</a> *KeGetCurrentThread (VOID)
{
    return (KTHREAD *) __readfsdword (FIELD_OFFSET (KPCR, PrcbData.CurrentThread));
}</pre>
  <p>both as exported and when inlined throughout the kernel. This access to the
  <span class="struct">KPRCB</span> members as nested in the
  <span class="struct">KPCR</span> is formalised in Microsoft’s assembly-language 
  header KS386.INC through such definitions as <span class="constant">PcCurrentThread</span> 
  for the preceding field offset. This offset too is stable: see
  <span class="instruction">dword ptr fs:[0124h]</span> in kernel-mode code for 
  any 32-bit Windows version and you know that what’s sought is the current thread.
  </p>
  <p>Whether such access to <span class="struct">KPRCB</span> members from
  <span class="register">fs</span> is written in assembly language or C, one case 
  is known of it going wrong, such that the offset applied to
  <span class="register">fs</span> is relative to the <span class="struct">KPRCB</span> 
  instead of the <span class="struct">KPCR</span>. Look far below (to offset 0x1A18) 
  for the <span class="member">DpcInterruptRequested</span> member in Windows Vista 
  SP1, specifically. It would not surprise if there have been others. Microsoft 
  understandably does not say and I have neither time nor taste for tracking them 
  down. </p>
  <h3>Processor Switching </h3>
  <p>Problems of incorrect offset computation aside, acessing a
  <span class="struct">KPRCB</span> member through the <span class="register">fs</span> 
  register and an offset from the containing <span class="struct">KPCR</span> generally 
  is better. This is because the address that some such routine as
  <span class="routine">KeGetCurrentPrcb</span> obtains is merely the address of 
  the <span class="struct">KPRCB</span> for the processor that the current thread 
  was being run on at the time. It remains the address of the current
  <span class="struct">KPRCB</span> only while the thread can ensure it is not switched 
  to another processor. </p>
  <p>To sense the danger, look again at <span class="function">KeGetCurrentThread</span> 
  and imagine it as coded in two steps: </p>
  <pre class="bad source">KTHREAD *KeGetCurrentThread_BAD (VOID)
{
    return KeGetCurrentPrcb () -&gt; CurrentThread;
}</pre>
  <p>This is unsafe for general use. If you don’t already see why, then kernel-mode 
  programming is not yet an accomplishment—and if you don’t see why by the end of 
  this paragraph, then please leave kernel-mode programming alone for a while. Suppose 
  this bad <span class="function">KeGetCurrentThread</span> is called from thread 
  X. A first instruction executes on processor A and gets the address of A’s
  <span class="struct">KPRCB</span>. A second gets the address of the
  <span class="struct">KTHREAD</span> for the thread that this
  <span class="struct">KPRCB</span> says is executing on processor A. If a thread 
  switch can occur between these two instructions, then although the second instruction 
  also executes for thread X, processor A can by then be executing some other thread 
  Y (and thread X can instead be executing on some other processor B). The routine 
  will find the <span class="struct">KTHREAD</span> for Y, not X. </p>
  <p>Often, the circumstances are such that the thread can’t be switched. But often 
  is not always, even for the kernel’s own use. How much trouble has been caused 
  by unsynchronised access to a <span class="struct">KPRCB</span> for some processor 
  that the thread is no longer running on may be impossible to assess even roughly 
  but I doubt it’s negligible. </p>
  <p>Certainly it has not always been attended to closely even by Microsoft’s kernel 
  programmers. As perhaps the simplest possible cases (though also perhaps the most 
  inconsequential), consider the per-processor performance counters
  <span class="member">CcFastReadNoWait</span>, <span class="member">CcFastReadWait</span> 
  and <span class="member">CcFastReadNotPossible</span>. These are important enough 
  to have been defined from the start—see below at offset 0x0240 for version 3.10. 
  Put aside that it wasn’t until version 5.1 that the writers of third-party file 
  system (filter) drivers were given such functions as <span class="function">FsRtlIncrementCcFastReadNoWait</span> 
  so that the count can include work that they do independently of
  <span class="function">FsRtlCopyRead</span>, etc. Look instead at the implementations. 
  All that’s needed is one <span class="instruction">inc</span> instruction relative 
  to <span class="register">fs</span>. Even without a <span class="instruction">
  lock</span> prefix, as long as the counter in each <span class="struct">KPRCB</span> 
  is never incremented any other way, each counter can only be incremented by the 
  one intended processor. Each truly keeps a per-processor count. But Microsoft 
  did not deliver this simplicity until version 6.1. </p>
  <p>Up to and including version 5.2, for both the exported functions and the kernel 
  for its own purposes, the counters are incremented in two steps: first, to get 
  a pointer to the <span class="struct">KPRCB</span>; then an (unlocked)
  <span class="instruction">inc</span> instruction, using the counter’s offset relative 
  to the <span class="struct">KPRCB</span>. This leaves some very slight chance 
  that thread X runs on processor A for the first step but is switched to processor 
  B for the second step while thread Y gets run on processor A and also reaches 
  the second step. The two threads are now running on different processors, X on 
  B and Y on A, but both have pointers to the <span class="struct">KPRCB</span> 
  for processor A and seek to increment the same counter concurrently. Without at 
  least a <span class="instruction">lock</span> prefix, the two processors’ reads 
  and writes for their increments can be interleaved and one of the increments may 
  be lost. Whether someone at Microsoft deduced this as having happened in a real-world 
  case or merely contemplated it may never be known, but version 6.0 changes from
  <span class="instruction">inc</span> to a <span class="instruction">lock xadd</span>. 
  For the limited purpose of these counters, this is good enough: given that thread 
  X in the preceding scenario does run on both processors A and B in and around 
  whatever event is being counted, who’s to say the count is wrong to go to one 
  processor rather than the other? </p>
  <p>This case—here just to lose an increment for statistical use only—is arguably 
  of no great consequence. This may be why it went unattended for a decade or so. 
  But this case is also as simple as problems with multi-processing can be, and 
  yet it is hardly trivial. So, let that be a warning for accessing
  <span class="struct">KPRCB</span> members in real-world code! </p>
  <h2>Documentation Status </h2>
  <p>The <span class="struct">KPRCB</span> is not documented. Though C-language 
  definitions of the <span class="struct">KPRCB</span> are in NTDDK.H from as long 
  ago as the Device Driver Kit (DDK) for Windows NT 3.51, they are for other processors 
  than the x86, do not continue beyond Windows XP, and are anyway incomplete. Microsoft’s 
  first known disclosure of a C-language definition of the <span class="struct">
  KPRCB</span> for the x86 is in the NTOSP.H from early editions of the WDK for 
  Windows 10. Publication of this header was possibly an oversight—Microsoft did 
  not repeat it for the 1607 edition—and its definition too is incomplete. Comments 
  explain that the published definitions are just of an “architecturally defined 
  section” that “may be directly addressed by vendor/platform specific HAL code 
  and will not change from version to version of NT.” </p>
  <p>The practical equivalent of a C-language definition of the whole structure 
  is available as type information in public symbol files for the kernel, starting 
  with Windows 2000 SP3. Starting with Windows 8, these also tell that the type 
  information came from compiling a header named
  <a href="../../../../source/inc/i386_x.htm">i386_x.h</a>. Some other symbol files, 
  e.g., those for the HAL in Windows 7 and higher, have type information for only 
  the architecturally defined section at the structure’s start. From these it is 
  known that the incomplete definition is not only in the twice-published NTOSP.H 
  but also in the never-published NTHAL.H. </p>
  <h2>Layout </h2>
  <p>The <span class="struct">KPRCB</span> is highly variable. The layout changes 
  not just from one version to another but even between builds. To save space and 
  tedium, this article’s presentation of the variations refers to early and late 
  builds of some versions, as defined in the following table of the structure’s 
  varying size: </p>
  <table class="Sizes">
    <colgroup>
      <col class="Version"><col class="Size" span="2">
    </colgroup>
    <thead>
      <tr>
        <th>Version </th>
        <th>Whole Structure </th>
        <th>Architecturally Defined Section </th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td>3.10 </td>
        <td>0x0298 </td>
        <td rowspan="4">0x01BC </td>
      </tr>
      <tr>
        <td>3.50 </td>
        <td>0x0348 </td>
      </tr>
      <tr>
        <td>3.51 </td>
        <td>0x0360 </td>
      </tr>
      <tr>
        <td>early 4.0 (before SP4); <br>
        late 4.0 </td>
        <td>0x0558 </td>
      </tr>
      <tr>
        <td>5.0 </td>
        <td>0x09F0 </td>
        <td>0x043C </td>
      </tr>
      <tr>
        <td>early 5.1 (before SP2); <br>
        late 5.1 </td>
        <td>0x0C50 </td>
        <td rowspan="2">0x04A0 </td>
      </tr>
      <tr>
        <td>early 5.2 (before SP1) </td>
        <td>0x0DD0 </td>
      </tr>
      <tr>
        <td>late 5.2 </td>
        <td>0x0EC0 </td>
        <td rowspan="2">0x0520 </td>
      </tr>
      <tr>
        <td>early 6.0 (before SP1) </td>
        <td>0x1F98 </td>
      </tr>
      <tr>
        <td>late 6.0 </td>
        <td>0x2008 </td>
        <td>0x05A0 </td>
      </tr>
      <tr>
        <td>6.1 </td>
        <td>0x3628 </td>
        <td rowspan="7">0x04A0 </td>
      </tr>
      <tr>
        <td>6.2 </td>
        <td>0x4160 </td>
      </tr>
      <tr>
        <td>6.3 </td>
        <td>0x4508 </td>
      </tr>
      <tr>
        <td>10.0 to 1703 </td>
        <td>0x4900 </td>
      </tr>
      <tr>
        <td>1709 </td>
        <td>0x4940 </td>
      </tr>
      <tr>
        <td>1803 to 2004 </td>
        <td>0x5F00 </td>
      </tr>
    </tbody>
  </table>
  <p>These sizes, and the names, types and offsets below, are from Microsoft’s public 
  symbols for the kernel, starting from Windows 2000 SP3. Similarly definitive sources 
  are scarce for earlier versions. A statically linked library named craShlib.Lib 
  (sic) from sample code in a Software Development Kit (SDK) for Windows NT 4.0 
  has an early form of type information for the <span class="struct">KPRCB</span>. 
  Members are also named by the <span class="command">!strct</span> command of the 
  KDEX2X86 debugger extension for Windows NT 4.0 and Windows 2000. For most versions 
  before Windows 2000 SP3, members are not known with certainty. Much use in the 
  earliest versions can be more or less easily matched to use in versions for which 
  names and types are known from symbol files. But where such correspondence isn’t 
  known, Microsoft’s names are lost to history and types can only be guessed. It 
  seems I never knew of any use for some large tracts of the
  <span class="struct">KPRCB</span> in the earliest versions. There’s only so much 
  that’s practical to do about that now. </p>
  <p>Please bear in mind that the <span class="struct">KPRCB</span> is among the 
  largest of kernel-mode structures, not just in terms of size but of member count. 
  There have been frequent rearrangements such that finding a good presentation 
  of this structure’s development even through the versions that are known from 
  symbol files can only ever be a work in progress. </p>
  <h3>Architecturally Defined Section </h3>
  <p>Relative to the overall variability of the <span class="struct">KPRCB</span>, 
  even just of the architecturally defined section, the very beginning of the structure 
  is remarkably stable through many versions. The first change at all is that Windows 
  Vista found space for a <span class="member">NestingLevel</span> in what had been
  <span class="member">Reserved</span> and refined the definition of the
  <span class="member">CpuStep</span> (to clarify that the high and low bytes are 
  model and stepping, respectively). The first change that breaks the stability 
  of this region is when Windows 7 removes <span class="member">SetMember</span> 
  and thus shifts almost all subsequent members of the architecturally defined section.
  </p>
  <table class="Struct">
    <colgroup>
      <col class="Offset"><col class="Definition"><col class="Versions">
      <col class="Remarks">
    </colgroup>
    <thead>
      <tr>
        <th>Offset </th>
        <th>Definition </th>
        <th>Versions </th>
        <th>Remarks </th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td>0x00 </td>
        <td>
        <pre class="source">USHORT MinorVersion;</pre>
        </td>
        <td>all </td>
        <td>&nbsp;</td>
      </tr>
      <tr>
        <td>0x02 </td>
        <td>
        <pre class="source">USHORT MajorVersion;</pre>
        </td>
        <td>all </td>
        <td>&nbsp;</td>
      </tr>
      <tr>
        <td>0x04 </td>
        <td>
        <pre class="source">KTHREAD *CurrentThread;</pre>
        </td>
        <td>all </td>
        <td>&nbsp;</td>
      </tr>
      <tr>
        <td>0x08 </td>
        <td>
        <pre class="source">KTHREAD *NextThread;</pre>
        </td>
        <td>all </td>
        <td>&nbsp;</td>
      </tr>
      <tr>
        <td>0x0C </td>
        <td>
        <pre class="source">KTHREAD *IdleThread;</pre>
        </td>
        <td>all </td>
        <td>&nbsp;</td>
      </tr>
      <tr>
        <td rowspan="3">0x10 </td>
        <td>
        <pre class="source">CHAR Number;</pre>
        </td>
        <td>3.10 to 5.2 </td>
        <td>&nbsp;</td>
      </tr>
      <tr>
        <td>
        <pre class="source">UCHAR Number;</pre>
        </td>
        <td>6.0 only </td>
        <td>next as <span class="type">ULONG</span> at 0x03CC </td>
      </tr>
      <tr>
        <td>
        <pre class="source">UCHAR LegacyNumber;</pre>
        </td>
        <td>6.1 and higher </td>
        <td>&nbsp;</td>
      </tr>
      <tr>
        <td rowspan="2">0x11 </td>
        <td>
        <pre class="source">CHAR Reserved;</pre>
        </td>
        <td>3.10 to 5.2 </td>
        <td>&nbsp;</td>
      </tr>
      <tr>
        <td>
        <pre class="source">UCHAR NestingLevel;</pre>
        </td>
        <td>6.0 and higher </td>
        <td>&nbsp;</td>
      </tr>
      <tr>
        <td>0x12 </td>
        <td>
        <pre class="source">USHORT BuildType;</pre>
        </td>
        <td>3.10 and higher </td>
        <td>&nbsp;</td>
      </tr>
      <tr>
        <td>0x14 </td>
        <td>
        <pre class="source">KAFFINITY SetMember;</pre>
        </td>
        <td>3.10 to 6.0 </td>
        <td>next as <span class="member">GroupSetMember</span> at 0x03C8 </td>
      </tr>
      <tr>
        <td>0x18 (3.10 to 6.0); <br>
        0x14 </td>
        <td>
        <pre class="source">CHAR CpuType;</pre>
        </td>
        <td>all </td>
        <td>&nbsp;</td>
      </tr>
      <tr>
        <td>0x19 (3.10 to 6.0); <br>
        0x15 </td>
        <td>
        <pre class="source">CHAR CpuID;</pre>
        </td>
        <td>all </td>
        <td>&nbsp;</td>
      </tr>
      <tr>
        <td rowspan="2">0x1A (3.10 to 6.0); <br>
        0x16 </td>
        <td>
        <pre class="source">USHORT CpuStep;</pre>
        </td>
        <td>3.10 to 5.2 </td>
        <td>&nbsp;</td>
      </tr>
      <tr>
        <td>
        <pre class="source">union {
    USHORT CpuStep;
    struct {
        UCHAR CpuStepping;
        UCHAR CpuModel;
    };
};</pre>
        </td>
        <td>6.0 and higher </td>
        <td>&nbsp;</td>
      </tr>
      <tr>
        <td>0x1C (3.10 to 6.0); <br>
        0x18 </td>
        <td>
        <pre class="source"><a href="../kprocessor_state.htm">KPROCESSOR_STATE</a> ProcessorState;</pre>
        </td>
        <td>all </td>
        <td>&nbsp;</td>
      </tr>
    </tbody>
  </table>
  <p>By no stretch can even the architecturally defined section be thought to have 
  lived up to Microsoft’s comment that it “will not change from version to version 
  of NT”, but the <span class="member">MinorVersion</span> and
  <span class="member">MajorVersion</span> never have changed. All known versions 
  of the x86 kernel set both to 1. From NTDDK.H for other processors in versions 
  3.51 to 5.1 inclusive, it can be inferred that Microsoft has the symbolic names
  <span class="constant">PRCB_MAJOR_VERSION</span> and <span class="constant">PRCB_MINOR_VERSION</span> 
  for these version numbers, which NTOSP.H confirms for the x86. </p>
  <p>Checked builds of the kernel set the 0x0001 bit in the <span class="member">
  BuildType</span>. Single-processor builds set the 0x0002 bit. Whether a kernel 
  is checked or single-processor is up to the kernel. There can be surprises. For 
  instance, a checked build of NTOSKRNL.EXE for Windows NT 3.51 has the 0x0001 bit 
  set but the 0x0002 bit clear because although it has the name of a single-processor 
  build it has the code of a multi-processor build. Again, Microsoft’s names
  <span class="constant">PRCB_BUILD_DEBUG</span> and <span class="constant">PRCB_BUILD_UNIPROCESSOR</span> 
  for these bits can be inferred from definitions for other processors in early 
  versions and are confirmed for the x86 by the NTOSP.H that is published for Windows 
  10. </p>
  <p>The <span class="member">CpuType</span> is what the processor manuals refer 
  to as the family. In <a href="../../../../../cpu/cpuid/00000001h/eax.htm">
  <span class="register">eax</span> from <span class="instruction">cpuid</span> 
  leaf 1</a>, bits 8 to 11 inclusive make a 4-bit family. If all four bits are set, 
  then an 8-bit family to keep as the <span class="member">CpuType</span> is formed 
  by adding the 4-bit family, i.e., 15, to the 8-bit extended family from bits 20 
  to 27. Or so things go now, both in Intel’s manuals and in the Windows kernel. 
  Beware, though, that the kernel has not always computed it this way exactly. The 
  extended family is ignored before version 5.1. The earliest versions, up to and 
  including the version 4.0 from Windows NT 4.0 SP5, read only a 3-bit family from 
  bits 8 to 10. Indeed, this departure of Microsoft’s from Intel’s specification 
  of a 4-bit family may be the reason that Intel had to introduce the extended family.
  </p>
  <p>The <span class="member">CpuID</span> is redundant now that Windows assumes 
  all processors have the <span class="instruction">
  <a href="../../../../../cpu/cpuid/index.htm">cpuid</a></span> instruction. Up 
  to and including version 6.2, it is set to 1 if the processor has an acceptable
  <span class="instruction">cpuid</span> instruction. Starting with version 3.50, 
  acceptable means that the instruction supports at least
  <a href="../../../../../cpu/cpuid/00000001h/index.htm">leaf 1</a>. Before the 
  version 4.0 from Windows NT 4.0 SP6, it means also that the instruction does not 
  support any leaf higher than 3. In version 6.3 and higher,
  <span class="member">CpuID</span> is necessarily 1 (except briefly while the
  <span class="struct">KPRCB</span> exists but the processor’s family, model and 
  stepping aren’t yet known). </p>
  <p>The <span class="member">CpuStepping</span> and <span class="member">CpuModel</span> 
  are named straightforwardly from the manuals. The <span class="member">CpuStepping</span> 
  is bits 0 to 3 inclusive of <span class="register">eax</span> from
  <span class="instruction">cpuid</span> leaf 1. The <span class="member">CpuModel</span> 
  is bits 4 to 7 inclusive, except that versions 5.1 and higher allow for two cases 
  in which an extended model in bits 16 to 19 supply four high bits to make an 8-bit
  <span class="member">CpuModel</span>. This use of the extended model is indicated 
  if either: the 4-bit family is 15; or it is 6 and the vendor as known from
  <a href="../../../../../cpu/cpuid/00000000h/index.htm">
  <span class="instruction">cpuid</span> leaf 0</a> is either GenuineIntel or, in 
  version 6.2 and higher, CentaurHauls. </p>
  <p>Within a processor family, the <span class="member">CpuModel</span> and
  <span class="member">CpuStepping</span> are much like major and minor version 
  numbers. They usually are taken together, especially to compare against some cut-off, 
  as when some feature flag is set but the indicated feature is thought to have 
  been faulty before some model and stepping—or, the other way round, when the feature 
  is known to have been present without the formal indication. Versions 3.10 and 
  3.50 have a case of taking the <span class="member">CpuID</span> and
  <span class="member">CpuType</span> together as a word, which may be a coding 
  oversight but at least has some merit as comparing for either a minimum family 
  or <span class="instruction">cpuid</span> support. Versions before 6.3 have a 
  curious case of taking <span class="member">CpuModel</span>,
  <span class="member">CpuStepping</span>, <span class="member">CpuID</span> and
  <span class="member">CpuType</span> together as a dword. This isn’t credibly anything 
  other than a coding oversight. It will have had a possibly harmless side-effect 
  for versions up to and including 3.51 when running on an 80386: presence of an 
  80387 will have caused the kernel to set the <span class="register">cr0</span> 
  bit <span class="bit">NE</span> (5) which the 80386 doesn’t have. </p>
  <p>Whatever Microsoft may have started out meaning by “architecturally defined”, 
  it did not mean even as early as Windows 2000 that architecturally defined members 
  do not move. The <span class="struct">KPROCESSOR_STATE</span> contains a
  <span class="struct">CONTEXT</span>. The latter has long been documented, with 
  C-language definitions in WINNT.H and NTDDK.H, but because its size changed for 
  Windows 2000, due to the addition of <span class="member">ExtendedRegisters</span>, 
  even the ancient <span class="struct">KPRCB</span> members that are defined beyond 
  this point all change their position at least once. </p>
  <p>The <span class="member">ProcessorState</span> itself moved for version 6.1. 
  This shift gave it 8-byte alignment, which may have been seen as a happy side-effect 
  when version 6.2 added a 64-bit register to the <span class="struct">
  <a href="../kspecial_registers.htm">KSPECIAL_REGISTERS</a></span> that’s nested 
  in the <span class="struct">KPROCESSOR_STATE</span>. </p>
  <h4>Kernel And HAL Reservations </h4>
  <p>Two specifically reserved areas, one each for the kernel and the HAL, are also 
  supposed to be architectural. The kernel’s reserved area starts to get fleshed 
  out with Windows 8.1, though only then to define two members at the start. </p>
  <table class="Struct">
    <colgroup>
      <col class="Offset"><col class="Definition"><col class="Versions">
      <col class="Remarks">
    </colgroup>
    <thead>
      <tr>
        <th>Offset </th>
        <th>Definition </th>
        <th>Versions </th>
        <th>Remarks </th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td>0x0338 </td>
        <td>
        <pre class="source">KNODE *ParentNode;</pre>
        </td>
        <td>6.3 and higher </td>
        <td>previously at 0x04CC </td>
      </tr>
      <tr>
        <td>0x033C </td>
        <td>
        <pre class="source">CHAR *PriorityState;</pre>
        </td>
        <td>6.3 and higher </td>
        <td>&nbsp;</td>
      </tr>
      <tr>
        <td rowspan="2">0x013C (3.10 to 4.0); <br>
        0x033C (5.0 to 6.0); <br>
        0x0338 (6.1 to 6.2); <br>
        0x0340 </td>
        <td>
        <pre class="source">ULONG KernelReserved [0x10];</pre>
        </td>
        <td>3.10 to 6.2 </td>
        <td>&nbsp;</td>
      </tr>
      <tr>
        <td>
        <pre class="source">ULONG KernelReserved [0x0E];</pre>
        </td>
        <td>6.3 and higher </td>
        <td>&nbsp;</td>
      </tr>
      <tr>
        <td>0x017C (3.10 to 4.0); <br>
        0x037C (5.0 to 6.0); <br>
        0x0378 </td>
        <td>
        <pre class="source">ULONG HalReserved [0x10];</pre>
        </td>
        <td>all </td>
        <td>&nbsp;</td>
      </tr>
    </tbody>
  </table>
  <p>The HAL’s reserved area certainly does get used by at least some HALs—even 
  from long ago, e.g., HALMPS.DLL from Windows NT 3.50—but the kernel knows nothing 
  of it. </p>
  <h4>Architectural Padding </h4>
  <p>The preceding reservations for the kernel and HAL look like they originally 
  ended the architecturally defined section: the next few members in versions 3.10 
  to 4.0 survive to later versions whose symbol files place them firmly beyond the 
  reach of the NTOSP.H definition. Version 5.0 inserted an array of per-processor 
  spin lock queues as the architecturally defined section’s new end: see
  <span class="member">LockQueue</span> at offset 0x03BC in version 5.0. Version 
  5.1 pushed this array further into the structure by inserting 0x5C bytes explicitly 
  as padding: see <span class="member">PrcbPad0</span>, below. </p>
  <p>There seem to have been two intentions. One is that the
  <span class="member">LockQueue</span>, initially at offset 0x03BC, should have 
  some cache alignment. For reasons not yet understood, the cache alignment is not 
  of the array from its beginning but from its second element. This is clearly by 
  design, for the same outcome is achieved differently in the x64
  <span class="struct">KPRCB</span>, and it is confirmed by a comment in the NTOSP.H 
  from the WDK for Windows 10: </p>
  <pre class="source">// N.B. The following padding is such that the first lock entry falls in the
//      last eight bytes of a cache line.</pre>
  <p>A plausible second intention was to set aside not the bare minimum for cache 
  alignment but enough space that future additions to the architecturally defined 
  section should not again shift the lock queues (which are presumably at the end 
  of the architecturally defined section so that they too can grow without shifting 
  anything else that’s architectural). </p>
  <p>These future additions arrived with Windows Vista, which claims four bytes 
  at the start. Its first Service Pack brings members from (much) further into the 
  structure, presumably for better-defined access to them from outside the kernel—and 
  the HAL certainly does access many of them. But note two things. First, these 
  members were not moved here to remain at their new locations forever. In particular, 
  the <span class="member">CpuVendor</span> was moved into this padding for version 
  6.1 but then version 6.3 reordered it relative to what remained of the padding. 
  Second, no matter what is added, or even moved after being added, the padding 
  is always adjusted—and even split—so that whatever was at offset 0x0418 after 
  this insertion of padding for version 5.1 is there forever. </p>
  <table class="Struct">
    <colgroup>
      <col class="Offset"><col class="Definition"><col class="Versions">
      <col class="Remarks">
    </colgroup>
    <thead>
      <tr>
        <th>Offset </th>
        <th>Definition </th>
        <th>Versions </th>
        <th>Remarks </th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td>0x03BC (6.0); <br>
        0x03B8 </td>
        <td>
        <pre class="source">ULONG CFlushSize;</pre>
        </td>
        <td>6.0 and higher </td>
        <td>&nbsp;</td>
      </tr>
      <tr>
        <td>0x03C0 (late 6.0); <br>
        0x03BC </td>
        <td>
        <pre class="source">UCHAR CoresPerPhysicalProcessor;</pre>
        </td>
        <td>late 6.0 and higher </td>
        <td>previously at 0x1BBA </td>
      </tr>
      <tr>
        <td>0x03C1 (late 6.0); <br>
        0x03BD </td>
        <td>
        <pre class="source">UCHAR LogicalProcessorsPerCore;</pre>
        </td>
        <td>late 6.0 and higher </td>
        <td>previously at 0x1F8C </td>
      </tr>
      <tr>
        <td>0x03BE </td>
        <td>
        <pre class="source">UCHAR CpuVendor;</pre>
        </td>
        <td>6.3 and higher </td>
        <td>previously at 0x03C4 </td>
      </tr>
      <tr>
        <td rowspan="4">0x03BC (5.1 to 5.2); <br>
        0x03C0 (early 6.0); <br>
        0x03C2 (late 6.0); <br>
        0x03BE (6.1 to 6.2); <br>
        0x03BF </td>
        <td>
        <pre class="source">UCHAR PrcbPad0 [0x5C];</pre>
        </td>
        <td>5.1 to 5.2 </td>
        <td>&nbsp;</td>
      </tr>
      <tr>
        <td>
        <pre class="source">UCHAR PrcbPad0 [0x58];</pre>
        </td>
        <td>early 6.0 only </td>
        <td>&nbsp;</td>
      </tr>
      <tr>
        <td>
        <pre class="source">UCHAR PrcbPad0 [2];</pre>
        </td>
        <td>late 6.0 to 6.2 </td>
        <td>&nbsp;</td>
      </tr>
      <tr>
        <td>
        <pre class="source">UCHAR PrcbPad0 [1];</pre>
        </td>
        <td>6.3 and higher </td>
        <td>&nbsp;</td>
      </tr>
      <tr>
        <td>0x03C4 (late 6.0); <br>
        0x03C0 </td>
        <td>
        <pre class="source">ULONG MHz;</pre>
        </td>
        <td>late 6.0 and higher </td>
        <td>previously at 0x1BBC </td>
      </tr>
      <tr>
        <td>0x03C4 (6.1 to 6.2) </td>
        <td>
        <pre class="source">UCHAR CpuVendor;</pre>
        </td>
        <td>6.1 to 6.2 </td>
        <td>previously at 0x1C28; <br>
        next at 0x03BE </td>
      </tr>
      <tr>
        <td>0x03C5 (6.1 to 6.2); <br>
        0x03C4 </td>
        <td>
        <pre class="source">UCHAR GroupIndex;</pre>
        </td>
        <td>6.1 and higher </td>
        <td>&nbsp;</td>
      </tr>
      <tr>
        <td rowspan="2">0x03C6 (6.1 to 6.2); <br>
        0x03C5 </td>
        <td>
        <pre class="source">USHORT Group;</pre>
        </td>
        <td>6.1 to 6.2 </td>
        <td>&nbsp;</td>
      </tr>
      <tr>
        <td>
        <pre class="source">UCHAR Group;</pre>
        </td>
        <td>6.3 and higher </td>
        <td>&nbsp;</td>
      </tr>
      <tr>
        <td>0x03C6 </td>
        <td>
        <pre class="source">UCHAR PrcbPad05 [2];</pre>
        </td>
        <td>6.3 and higher </td>
        <td>&nbsp;</td>
      </tr>
      <tr>
        <td>0x03C8 </td>
        <td>
        <pre class="source">KAFFINITY GroupSetMember;</pre>
        </td>
        <td>6.1 and higher </td>
        <td>previously as <span class="member">SetMember</span> at 0x14 </td>
      </tr>
      <tr>
        <td>0x03CC </td>
        <td>
        <pre class="source">ULONG Number;</pre>
        </td>
        <td>6.1 and higher </td>
        <td>previously <span class="type">UCHAR</span> at 0x10 </td>
      </tr>
      <tr>
        <td>0x03D0 </td>
        <td>
        <pre class="source">BOOLEAN ClockOwner;</pre>
        </td>
        <td>6.2 and higher </td>
        <td>&nbsp;</td>
      </tr>
      <tr>
        <td rowspan="2">0x03D1 </td>
        <td>
        <pre class="source">UCHAR PendingTick;</pre>
        </td>
        <td>6.2 only </td>
        <td>&nbsp;</td>
      </tr>
      <tr>
        <td>
        <pre class="source">union {
    UCHAR PendingTickFlags;
    struct {
        UCHAR PendingTick : 1;          // 0x01
        UCHAR PendingBackupTick : 1;    // 0x02
    };
};</pre>
        </td>
        <td>6.3 and higher </td>
        <td>&nbsp;</td>
      </tr>
      <tr>
        <td rowspan="4">0x03C8 (late 6.0); <br>
        0x03D0 (6.1); <br>
        0x03D2 </td>
        <td>
        <pre class="source">UCHAR PrcbPad1 [0x50];</pre>
        </td>
        <td>late 6.0 only </td>
        <td>&nbsp;</td>
      </tr>
      <tr>
        <td>
        <pre class="source">UCHAR PrcbPad1 [0x48];</pre>
        </td>
        <td>6.1 only </td>
        <td>&nbsp;</td>
      </tr>
      <tr>
        <td>
        <pre class="source">UCHAR PrcbPad1 [0x46];</pre>
        </td>
        <td>6.2 only </td>
        <td>&nbsp;</td>
      </tr>
      <tr>
        <td>
        <pre class="source">UCHAR PrcbPad10 [0x46];</pre>
        </td>
        <td>6.3 and higher </td>
        <td>&nbsp;</td>
      </tr>
    </tbody>
  </table>
  <p>The <span class="member">CFlushSize</span> is the size of the cache line in 
  bytes as used for the <span class="instruction">clflush</span> and
  <span class="instruction">clflushopt</span> instructions. The kernel’s first use 
  of <span class="instruction">clflush</span> is for the exported function
  <span class="function">KeInvalidateRangeAllCaches</span> in version 6.0. Other 
  uses have been found since, and this first use is replaced in version 10.0 and 
  higher by <span class="instruction">clflushopt</span> if it’s available. In all 
  versions, the cache line’s size is computed as eight times the second lowest byte, 
  i.e., bits 8 to 15 inclusive, of what <span class="instruction">cpuid</span> leaf 
  1 returns in <span class="register">ebx</span>. </p>
  <p>The number of <span class="member">CoresPerPhysicalProcessor</span> defaults 
  to 1, of course. That it can be anything else isn’t noticed before version 6.0. 
  Generally, it is one more than what <span class="instruction">cpuid</span> leaf 
  4 returns in the high 6 bits of <span class="register">eax</span>. For AMD processors, 
  the kernel instead interprets what <span class="instruction">cpuid</span> leaf 
  0x80000008 returns in <span class="register">ecx</span>. Either way, versions 
  6.1 and higher round up to a power of two. </p>
  <p>The <span class="member">CpuVendor</span> is a convenient interpretation of 
  the <a href="../../../../../cpu/cpuid/00000000h/vendor.htm">CPU vendor string</a> 
  that is produced by <span class="instruction">cpuid</span> leaf 0. It takes its 
  values from the (x86-specific) <span class="enum">
  <a href="../cpu_vendors.htm">CPU_VENDORS</a></span> enumeration. </p>
  <h4>Spin Lock Queues </h4>
  <p>That the kernel has a “per processor lock queue” is well known from comments 
  in NTDDK.H from as long ago as the DDK for Windows XP (moved to WDM.H in the WDK 
  for Windows Vista). The comments come a little before the definition of the
  <span class="struct">KSPIN_LOCK_QUEUE</span> structure, which appears to be provided 
  only so that callers of such newly introduced HAL functions as
  <span class="function">
  <a href="../../../../../hal/api/mpspin/acquireinstack.htm">KeAcquireInStackQueuedSpinLock</a></span> 
  can create the necessary <span class="struct">KLOCK_QUEUE_HANDLE</span>. Less 
  well known is that this structure, and
  <a href="../../../../api/ke/queuelock/index.htm">queued spin locks</a> as a feature, 
  date from Windows 2000. This first existence was not for general use but for dedicated 
  purposes, with queueing supported only through the following array for each processor:
  </p>
  <table class="struct">
    <colgroup>
      <col class="Offset"><col class="Definition"><col class="Versions">
    </colgroup>
    <thead>
      <tr>
        <th>Offset </th>
        <th>Definition </th>
        <th>Versions </th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td rowspan="2">0x03BC (5.0); <br>
        0x0418 </td>
        <td>
        <pre class="source">KSPIN_LOCK_QUEUE LockQueue [0x10];</pre>
        </td>
        <td>5.0 to 5.1 </td>
      </tr>
      <tr>
        <td>
        <pre class="source">KSPIN_LOCK_QUEUE LockQueue [LockQueueMaximumLock];</pre>
        </td>
        <td>5.2 and higher </td>
      </tr>
      <tr>
        <td>0x0498 (5.1 to early 5.2) </td>
        <td>
        <pre class="source">UCHAR PrcbPad1 [8];</pre>
        </td>
        <td>5.1 to early 5.2 </td>
      </tr>
    </tbody>
  </table>
  <p>As noted above, trouble is taken to keep the <span class="member">LockQueue</span> 
  reliably at offset 0x0418 ever since Windows XP. Comparison with the 64-bit
  <span class="struct">KPRCB</span> suggests that what’s wanted is perhaps not a 
  specific offset but that the second entry is cache-aligned or that the first is 
  in a separate cache line from all the others. Such alignment to 0x40 bytes becomes 
  ever more important through successive versions. Remember always that what counts 
  for alignment is not the offset within the <span class="struct">KPRCB</span> but 
  within the containing <span class="struct">KPCR</span> (which is necessarily not 
  just cache-aligned but page-aligned). Programmers who deal much with the
  <span class="struct">KPCR</span> and <span class="struct">KPRCB</span> in the 
  debugger—and reverse engineers in their disassemblies—will be familiar with adding 
  and subtracting 0x0120. </p>
  <p>The <span class="member">LockQueue</span> array is indexed by members of the 
  enumeration <span class="enum">
  <a href="../../../api/ntkeapi_x/kspin_lock_queue_number.htm">KSPIN_LOCK_QUEUE_NUMBER</a></span>, 
  which is defined in WDM.H and is used in NTIFS.H for the declarations of the exported 
  functions such as <span class="function">KeAcquireQueuedSpinLock</span> that operate 
  on the applicable spin locks through these per-processor lock queues. These declarations 
  would have it that the functions require at least Windows XP. The functions are 
  documented, but only to say they’re reserved. </p>
  <p>The array initially allows for 0x10 entries even though use was not defined 
  for all 0x10 of them until version 5.2 The versions that trouble over cache-alignment 
  for the second entry also have either that the array ends at a cache-line boundary 
  or is padded to the next boundary. Since version 5.1, then, the non-architectural 
  section is cache-aligned. </p>
  <h3>Non-Architectural </h3>
  <p>The NTOSP.H from the WDK for Windows 10 confirms <span class="member">LockQueue</span> 
  as the last member of the architecturally defined section that is all that NTOSP.H 
  defines of the <span class="struct">KPRCB</span>. Though trouble has been taken 
  through successive revisions to keep the <span class="member">LockQueue</span> 
  array at a reliable offset, the array’s highly variable size through versions 
  5.1 to 6.1 means that most members in the non-architectural section shift wildly 
  in these versions even when not reordered. </p>
  <table class="Struct">
    <colgroup>
      <col class="Offset"><col class="Definition"><col class="Versions">
      <col class="Remarks">
    </colgroup>
    <thead>
      <tr>
        <th>Offset </th>
        <th>Definition </th>
        <th>Versions </th>
        <th>Remarks </th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td>0x01BC (3.10 to 4.0); <br>
        0x043C (5.0); <br>
        0x04A0 (5.1 to early 5.2); <br>
        0x0520 (late 5.2 to early 6.0); <br>
        0x05A0 (late 6.0); <br>
        0x04A0 (6.1 to 6.2) </td>
        <td>
        <pre class="source">KTHREAD *NpxThread;</pre>
        </td>
        <td>3.10 to 6.2 </td>
        <td>cache-aligned in 5.1 and higher </td>
      </tr>
      <tr>
        <td>0x01C0 (3.10 to 4.0); <br>
        0x0440 (5.0); <br>
        0x04A4 (5.1 to early 5.2); <br>
        0x0524 (late 5.2 to early 6.0); <br>
        0x05A4 (late 6.0); <br>
        0x04A4 (6.1 to 6.2); <br>
        0x04A0 </td>
        <td>
        <pre class="source">ULONG InterruptCount;</pre>
        </td>
        <td>all </td>
        <td>&nbsp;</td>
      </tr>
      <tr>
        <td rowspan="2">0x01C8 (3.10); <br>
        0x01C4 (3.50 to 4.0); <br>
        0x0444 (5.0); <br>
        0x04A8 (5.1 to early 5.2); <br>
        0x0528 (late 5.2 to early 6.0); <br>
        0x05A8 (late 6.0); <br>
        0x04A8 (6.1 to 6.2); <br>
        0x04A4 </td>
        <td>
        <pre class="source">LARGE_INTEGER KernelTime;</pre>
        </td>
        <td>3.10 only </td>
        <td>&nbsp;</td>
      </tr>
      <tr>
        <td>
        <pre class="source">ULONG KernelTime;</pre>
        </td>
        <td>3.50 and higher </td>
        <td>&nbsp;</td>
      </tr>
      <tr>
        <td rowspan="2">0x01D0 (3.10); <br>
        0x01C8 (3.50 to 4.0); <br>
        0x0448 (5.0); <br>
        0x04AC (5.1 to early 5.2); <br>
        0x052C (late 5.2 to early 6.0); <br>
        0x05AC (late 6.0); <br>
        0x04AC (6.1 to 6.2); <br>
        0x04A8 </td>
        <td>
        <pre class="source">LARGE_INTEGER UserTime;</pre>
        </td>
        <td>3.10 only </td>
        <td>&nbsp;</td>
      </tr>
      <tr>
        <td>
        <pre class="source">ULONG UserTime;</pre>
        </td>
        <td>3.50 and higher </td>
        <td>&nbsp;</td>
      </tr>
      <tr>
        <td rowspan="2">0x01D8 (3.10); <br>
        0x01CC (3.50 to 4.0); <br>
        0x044C (5.0); <br>
        0x04B0 (5.1 to early 5.2); <br>
        0x0530 (late 5.2 to early 6.0); <br>
        0x05B0 (late 6.0); <br>
        0x04B0 (6.1 to 6.2); <br>
        0x04AC </td>
        <td>
        <pre class="source">LARGE_INTEGER DpcTime;</pre>
        </td>
        <td>3.10 only </td>
        <td>&nbsp;</td>
      </tr>
      <tr>
        <td>
        <pre class="source">ULONG DpcTime;</pre>
        </td>
        <td>3.50 and higher </td>
        <td>&nbsp;</td>
      </tr>
      <tr>
        <td rowspan="2">0x04B4 (5.1 to early 5.2); <br>
        0x0534 (late 5.2 to early 6.0); <br>
        0x05B4 (late 6.0); <br>
        0x04B4 (6.1 to 6.2); <br>
        0x04B0 </td>
        <td>
        <pre class="source">ULONG DebugDpcTime;</pre>
        </td>
        <td>5.1 to 5.2 </td>
        <td>previously at 0x0460 </td>
      </tr>
      <tr>
        <td>
        <pre class="source">ULONG DpcTimeCount;</pre>
        </td>
        <td>6.0 and higher </td>
        <td>&nbsp;</td>
      </tr>
      <tr>
        <td rowspan="2">0x01E0 (3.10); <br>
        0x01D0 (3.50 to 4.0); <br>
        0x0450 (5.0); <br>
        0x04B8 (5.1 to early 5.2); <br>
        0x0538 (late 5.2 to early 6.0); <br>
        0x05B8 (late 6.0); <br>
        0x04B8 (6.1 to 6.2); <br>
        0x04B4 </td>
        <td>
        <pre class="source">LARGE_INTEGER InterruptTime;</pre>
        </td>
        <td>3.10 only </td>
        <td>&nbsp;</td>
      </tr>
      <tr>
        <td>
        <pre class="source">ULONG InterruptTime;</pre>
        </td>
        <td>3.50 and higher </td>
        <td>&nbsp;</td>
      </tr>
    </tbody>
  </table>
  <p>The <span class="member">InterruptCount</span>, <span class="member">KernelTime</span>,
  <span class="member">UserTime</span>, <span class="member">DpcTime</span> and
  <span class="member">InterruptTime</span> are all retrievable through the
  <span class="constant">SystemProcessorPerformanceInformation</span> (0x08) case 
  of <span class="function"><a href="../../../../api/ex/sysinfo/query.htm">NtQuerySystemInformation</a></span> 
  in all known versions. See that version 3.10 keeps the raw 64-bit times. Later 
  versions scale by the so-called maximum increment. </p>
  <p>The exported <span class="function">KeUpdateRunTime</span> function that updates 
  those times (and <span class="member">DpcTimeCount</span> in version 6.0 and higher) 
  also reduces the current thread’s quantum. If this leaves the thread with no more 
  quantum, version 3.10 schedules a DPC that will find another thread to run. This 
  was improved upon as early as version 3.50 so that the 0x20 bytes of this
  <span class="struct">KDPC</span> whose name may never be known seem to have became 
  spare. This is here supposed as the origin of the <span class="member">Spare2</span> 
  that is known from symbol files in later versions. The space recovered from this 
  unknown <span class="struct">KDPC</span> started to get used in version 3.51:
  </p>
  <table class="Struct">
    <colgroup>
      <col class="Offset"><col class="Definition"><col class="Versions">
      <col class="Remarks">
    </colgroup>
    <thead>
      <tr>
        <th>Offset </th>
        <th>Definition </th>
        <th>Versions </th>
        <th>Remarks </th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td>0x01D4 (3.51 to 4.0); <br>
        0x0454 (5.0) </td>
        <td>
        <pre class="source">ULONG ApcBypassCount;</pre>
        </td>
        <td>3.51 to 5.0 </td>
        <td>&nbsp;</td>
      </tr>
      <tr>
        <td>0x01D8 (3.51 to 4.0); <br>
        0x0458 (5.0) </td>
        <td>
        <pre class="source">ULONG DpcBypassCount;</pre>
        </td>
        <td>3.51 to 5.0 </td>
        <td>&nbsp;</td>
      </tr>
      <tr>
        <td>0x01DC (3.51 to 4.0); <br>
        0x045C (5.0) </td>
        <td>
        <pre class="source">ULONG AdjustDpcThreshold;</pre>
        </td>
        <td>3.51 to 5.0 </td>
        <td>next at 0x04BC </td>
      </tr>
      <tr>
        <td>0x0460 (5.0) </td>
        <td>
        <pre class="source">ULONG DebugDpcTime;</pre>
        </td>
        <td>5.0 only </td>
        <td>next at 0x04B4 </td>
      </tr>
      <tr>
        <td rowspan="4">0x01E8 (3.10); <br>
        0x01D4 (3.50); <br>
        0x01E0 (3.51 to 4.0); <br>
        0x0464 (5.0) </td>
        <td>unknown <span class="struct">KDPC</span> </td>
        <td>3.10 only </td>
        <td>&nbsp;</td>
      </tr>
      <tr>
        <td>
        <pre class="source">ULONG Spare2 [8];</pre>
        </td>
        <td>3.50 only </td>
        <td>&nbsp;</td>
      </tr>
      <tr>
        <td>
        <pre class="source">ULONG Spare2 [5];</pre>
        </td>
        <td>3.51 to 4.0 </td>
        <td>&nbsp;</td>
      </tr>
      <tr>
        <td>
        <pre class="source">ULONG Spare2 [4];</pre>
        </td>
        <td>5.0 only </td>
        <td>&nbsp;</td>
      </tr>
    </tbody>
  </table>
  <p>The <span class="member">ApcBypassCount</span> and <span class="member">DpcBypassCount</span> 
  are retrievable through the <span class="constant">SystemInterruptInformation</span> 
  (0x17) case of <span class="function">NtQuerySystemInformation</span> in the applicable 
  versions. Since their discontinuation in version 5.1, the corresponding members 
  in the retrieved information are both zero. </p>
  <p>No use of <span class="member">DebugDpcTime</span> is known in any version, 
  either here (where type information from public symbol files for the kernel places 
  it definitively, at least for the later builds of version 5.0) or at its next 
  position until version 6.0 reuses it (or relabels it) as <span class="member">
  DpcTimeCount</span>. Type information in CRASHLIB.LIB from Dr. Watson sample code 
  in the SDK for Windows NT 4.0 has <span class="member">Spare2</span> follow immediately 
  from <span class="member">AdjustDpcThreshold</span>, confirming that
  <span class="member">DebugDpcTime</span> was not yet defined. </p>
  <table class="Struct">
    <colgroup>
      <col class="Offset"><col class="Definition"><col class="Versions">
      <col class="Remarks">
    </colgroup>
    <thead>
      <tr>
        <th>Offset </th>
        <th>Definition </th>
        <th>Versions </th>
        <th>Remarks </th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td>0x04BC (5.1 to early 5.2); <br>
        0x053C (late 5.2 to early 6.0); <br>
        0x05BC (late 6.0); <br>
        0x04BC (6.1 to 6.2); <br>
        0x04B8 </td>
        <td>
        <pre class="source">ULONG AdjustDpcThreshold;</pre>
        </td>
        <td>5.1 and higher </td>
        <td>previously at 0x045C </td>
      </tr>
      <tr>
        <td>0x04C0 (5.1 to early 5.2); <br>
        0x0540 (late 5.2 to early 6.0); <br>
        0x05C0 (late 6.0); <br>
        0x04C0 (6.1 to 6.2); <br>
        0x04BC </td>
        <td>
        <pre class="source">ULONG PageColor;</pre>
        </td>
        <td>5.1 and higher </td>
        <td>&nbsp;</td>
      </tr>
      <tr>
        <td rowspan="2">0x04C4 (5.1 to early 5.2); <br>
        0x0544 (late 5.2 to early 6.0); <br>
        0x05C4 (late 6.0) </td>
        <td>
        <pre class="source">ULONG SkipTick;</pre>
        </td>
        <td>5.1 only </td>
        <td>previously <span class="type">UCHAR</span> at 0x072C </td>
      </tr>
      <tr>
        <td>
        <pre class="source">UCHAR SkipTick;</pre>
        </td>
        <td>5.2 to 6.0 </td>
        <td>&nbsp;</td>
      </tr>
      <tr>
        <td>0x04C8 (5.1) </td>
        <td>
        <pre class="source">UCHAR MultiThreadSetBusy;</pre>
        </td>
        <td>5.1 only </td>
        <td>&nbsp;</td>
      </tr>
      <tr>
        <td>0x04C5 (early 5.2); <br>
        0x0545 (late 5.2 to early 6.0); <br>
        0x05C5 (late 6.0); <br>
        0x04C4 (6.1 to 6.2); <br>
        0x04C0 </td>
        <td>
        <pre class="source">UCHAR DebuggerSavedIRQL;</pre>
        </td>
        <td>5.2 and higher </td>
        <td>&nbsp;</td>
      </tr>
      <tr>
        <td>0x0546 (late 5.2 to early 6.0); <br>
        0x05C6 (late 6.0); <br>
        0x04C5 (6.1 to 6.2); <br>
        0x04C1 </td>
        <td>
        <pre class="source">UCHAR NodeColor;</pre>
        </td>
        <td>late 5.2 and higher </td>
        <td>&nbsp;</td>
      </tr>
      <tr>
        <td>0x04C2 </td>
        <td>
        <pre class="source">UCHAR DeepSleep;</pre>
        </td>
        <td>10.0 and higher </td>
        <td>&nbsp;</td>
      </tr>
      <tr>
        <td>0x04C3 </td>
        <td>
        <pre class="source">UCHAR TbFlushListActive;</pre>
        </td>
        <td>1803 and higher </td>
        <td>&nbsp;</td>
      </tr>
      <tr>
        <td rowspan="3"><br>
        0x04C9 (5.1); <br>
        0x04C6 (early 5.2); <br>
        0x0547 (late 5.2) </td>
        <td>
        <pre class="source">UCHAR Spare2 [3];</pre>
        </td>
        <td>5.1 only </td>
        <td>&nbsp;</td>
      </tr>
      <tr>
        <td>
        <pre class="source">UCHAR Spare1 [6];</pre>
        </td>
        <td>early 5.2 only </td>
        <td>&nbsp;</td>
      </tr>
      <tr>
        <td>
        <pre class="source">UCHAR Spare1;</pre>
        </td>
        <td>late 5.2 only </td>
        <td>&nbsp;</td>
      </tr>
      <tr>
        <td>0x547 (early 6.0); <br>
        0x05C7 (late 6.0) </td>
        <td>
        <pre class="source">UCHAR PollSlot;</pre>
        </td>
        <td>6.0 only </td>
        <td>&nbsp;</td>
      </tr>
      <tr>
        <td rowspan="4">0x04C6 (6.1 to 6.2); <br>
        0x04C2 (6.3); <br>
        0x04C3 (10.0 to 1709) </td>
        <td>
        <pre class="source">UCHAR PrcbPad20 [2];</pre>
        </td>
        <td>6.1 to 6.2 </td>
        <td>&nbsp;</td>
      </tr>
      <tr>
        <td>
        <pre class="source">UCHAR PrcbPad20 [6];</pre>
        </td>
        <td>6.3 only </td>
        <td>&nbsp;</td>
      </tr>
      <tr>
        <td>
        <pre class="source">UCHAR PrcbPad20 [5];</pre>
        </td>
        <td>10.0 to 1703 </td>
        <td>&nbsp;</td>
      </tr>
      <tr>
        <td>
        <pre class="source">UCHAR PrcbPad20;</pre>
        </td>
        <td>1709 only </td>
        <td>&nbsp;</td>
      </tr>
      <tr>
        <td>0x04C4 </td>
        <td>
        <pre class="source">PVOID volatile CachedStack;</pre>
        </td>
        <td>1709 and higher </td>
        <td>&nbsp;</td>
      </tr>
      <tr>
        <td>0x0548 (late 5.2 to early 6.0); <br>
        0x05C8 (late 6.0); <br>
        0x04C8 </td>
        <td>
        <pre class="source">ULONG NodeShiftedColor;</pre>
        </td>
        <td>late 5.2 and higher </td>
        <td>&nbsp;</td>
      </tr>
      <tr>
        <td>0x04CC (5.1 to early 5.2); <br>
        0x054C (late 5.2 to early 6.0); <br>
        0x05CC (late 6.0); <br>
        0x04CC (6.1 to 6.2) </td>
        <td>
        <pre class="source">KNODE *ParentNode;</pre>
        </td>
        <td>5.1 to 6.2 </td>
        <td>next at 0x0338 </td>
      </tr>
      <tr>
        <td>0x04D0 (5.1 to early 5.2); <br>
        0x0550 (late 5.2 to early 6.0); <br>
        0x05D0 (late 6.0) </td>
        <td>
        <pre class="source">ULONG MultiThreadProcessorSet;</pre>
        </td>
        <td>5.1 to 6.0 </td>
        <td>&nbsp;</td>
      </tr>
      <tr>
        <td>0x04D4 (5.1 to early 5.2); <br>
        0x0554 (late 5.2 to early 6.0); <br>
        0x05D4 (late 6.0) </td>
        <td>
        <pre class="source">KPRCB *MultiThreadSetMaster;</pre>
        </td>
        <td>5.1 to 6.0 </td>
        <td>&nbsp;</td>
      </tr>
    </tbody>
  </table>
  <p>No use of <span class="member">ThreadStartCount</span>, below, is known in 
  any version before symbol files show its reuse for late builds of version 5.2. 
  That it is defined as early as version 3.51 is uncertain. It is confirmed for 
  version 4.0 from type information in the statically linked library CRASHLIB.LIB 
  from contemporaneous Dr. Watson sample code. </p>
  <table class="Struct">
    <colgroup>
      <col class="Offset"><col class="Definition"><col class="Versions">
      <col class="Remarks">
    </colgroup>
    <thead>
      <tr>
        <th>Offset </th>
        <th>Definition </th>
        <th>Versions </th>
        <th>Remarks </th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td>0x01F4 (3.51 to 4.0); <br>
        0x0474 (5.0); <br>
        0x04D8 (5.1 to early 5.2) <br>
        </td>
        <td>
        <pre class="source">ULONG ThreadStartCount [2];</pre>
        </td>
        <td>3.51 to early 5.2 </td>
        <td>&nbsp;</td>
      </tr>
      <tr>
        <td>0x0558 (late 5.2 to early 6.0); <br>
        0x05D8 (late 6.0); <br>
        0x04D0 (6.1 to 6.2); <br>
        0x04CC </td>
        <td>
        <pre class="source">ULONG SecondaryColorMask;</pre>
        </td>
        <td>late 5.2 and higher </td>
        <td>&nbsp;</td>
      </tr>
      <tr>
        <td rowspan="2">0x055C (late 5.2 to early 6.0); <br>
        0x05DC (late 6.0); <br>
        0x04D4 (6.1 to 6.2); <br>
        0x04D0 </td>
        <td>
        <pre class="source">LONG Sleeping;</pre>
        </td>
        <td>late 5.2 only </td>
        <td>next at 0x19C8 </td>
      </tr>
      <tr>
        <td>
        <pre class="source">ULONG DpcTimeLimit;</pre>
        </td>
        <td>6.0 and higher </td>
        <td>&nbsp;</td>
      </tr>
    </tbody>
  </table>
  <h4>Inter-Processor Interrupts </h4>
  <p>The very earliest versions deal here with inter-processor interrupts. The implementation 
  soon increased in sophistication and the supporting members were relocated much 
  further into the <span class="struct">KPRCB</span> (and reordered). </p>
  <table class="Struct">
    <colgroup>
      <col class="Offset"><col class="Definition"><col class="Versions">
      <col class="Remarks">
    </colgroup>
    <thead>
      <tr>
        <th>Offset </th>
        <th>Definition </th>
        <th>Versions </th>
        <th>Remarks </th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td>0x0208 (3.10); <br>
        0x01F4 (3.50) </td>
        <td>
        <pre class="source">BOOLEAN volatile IpiCommands [4];</pre>
        </td>
        <td>3.10 to 3.50 </td>
        <td>next at 0x02C0 </td>
      </tr>
      <tr>
        <td>0x020C (3.10); <br>
        0x01F8 (3.50) </td>
        <td>
        <pre class="source">UCHAR volatile IpiFrozen;</pre>
        </td>
        <td>3.10 to 3.50 </td>
        <td>next at 0x02CC </td>
      </tr>
      <tr>
        <td>0x0210 (3.10); <br>
        0x01FC (3.50) </td>
        <td>
        <pre class="source">ULONG volatile ReverseStall;</pre>
        </td>
        <td>3.10 to 3.50 </td>
        <td>next at 0x02C8 </td>
      </tr>
      <tr>
        <td>0x0214 (3.10); <br>
        0x0200 (3.50) </td>
        <td>
        <pre class="source">ULONG volatile IpiLastPacket;</pre>
        </td>
        <td>3.10 to 3.50 </td>
        <td>next at 0x02C4 </td>
      </tr>
      <tr>
        <td>0x0218 (3.10); <br>
        0x0204 (3.50) </td>
        <td>unaccounted 0x20 bytes </td>
        <td>3.10 to 3.50 </td>
        <td>&nbsp;</td>
      </tr>
    </tbody>
  </table>
  <p>The <span class="member">IpiCommands</span> array records which of the four 
  possible types of packet-less request are being sent to this processor. They are 
  set by the kernel’s <span class="function">KiIpiSend</span> function (which is 
  exported in these versions) on the way to asking the HAL’s
  <span class="function">HalRequestIpi</span> function to interrupt this processor. 
  They get cleared at this processor by the kernel’s exported
  <span class="function">KiIpiServiceRoutine</span>. The name
  <span class="member">IpiCommands</span> is inferred with reasonable certainty 
  from the I386KD debugger for version 3.10 and the KDEXTX86 debugger extension 
  for version 3.51. Their descriptions of the four types of request are: APC, DPC, 
  Clock and Freeze. These commands are essentially signals to this processor to 
  start some pre-determined activity such as executing Deferred Procedure Calls. 
  Each signal is either set or not. Each can have been set by multiple sending processors 
  concurrently before this processor gets interrupted. </p>
  <p>The names <span class="member">IpiFrozen</span> and <span class="member">IpiLastPacket</span> 
  are also known from the debugger (and the latter from the extension). </p>
  <p>The <span class="member">IpiLastPacket</span> is the 32-bit sequence number 
  of the packet that the processor last serviced (or most recently started servicing). 
  In these versions, a processor can send a packet-based request to arbitrarily 
  many processors but multiple processors cannot send requests concurrently. The 
  packet’s three parameters (or four, in version 3.50) and the address of the worker 
  routine that is to execute for the packet on each target processor are kept in 
  the kernel’s own data. So too is an array of boolean flags, one for each of the 
  possible 32 processors, which the worker routine must signal. The sending processor 
  holds a spin lock and waits for the signal from each target processor. Among the 
  inefficiencies is that while the sending processor waits, any target processor 
  can receive not just the one inter-processor interrupt to service the packet-based 
  request but others for packet-less commands. The sequence number is the defence 
  against re-servicing a packet. Whether this sequence number is signed or unsigned 
  is not known: type information never becomes available because it does not survive 
  to version 4.0, which provides for concurrent senders. </p>
  <h4>Per-Processor File Locking </h4>
  <p>Two pointers that are explicitly spare in version 5.0 according to symbol files 
  are known to be used in the earliest Windows versions. They each point to a chain 
  of freed fixed-sized allocations for managing file locks. The first pointer is 
  for shared locks, the second for exclusive. The allocations are containers for 
  a copy of the <span class="struct">FILE_LOCK_INFO</span> structure that is given 
  when locking bytes in a file. Some number (10 in 3.51 but 8 in 4.0) of allocations 
  are obtained in advance from the non-paged pool and are pre-freed to these caches. 
  In essence, these are rough-and-ready implementations of what version 5.0 would 
  formalise as per-processor look-aside lists (see <span class="member">PPLookasideList</span>, 
  below, at offset 0x0500). Late builds of version 4.0 do indeed change to lookaside 
  lists for file locking, but they use ordinary look-aside lists in the kernel’s 
  data, and per-processor caching for file locking never is returned to. </p>
  <table class="Struct">
    <colgroup>
      <col class="Offset"><col class="Definition"><col class="Versions">
    </colgroup>
    <thead>
      <tr>
        <th>Offset </th>
        <th>Definition </th>
        <th>Versions </th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td rowspan="2">0x0238 (3.10); <br>
        0x0224 (3.50); <br>
        0x01FC (3.51 to 4.0); <br>
        0x047C (5.0) </td>
        <td>
        <pre class="source">SINGLE_LIST_ENTRY FsRtlFreeSharedLockList;</pre>
        </td>
        <td>3.10 to early 4.0 </td>
      </tr>
      <tr>
        <td>
        <pre class="source">PVOID SpareHotData [2];</pre>
        </td>
        <td>late 4.0 to 5.0 </td>
      </tr>
      <tr>
        <td>0x023C (3.10); <br>
        0x0228 (3.50); <br>
        0x0200 (3.51 to early 4.0) </td>
        <td>
        <pre class="source">SINGLE_LIST_ENTRY FsRtlFreeExclusiveLockList;</pre>
        </td>
        <td>3.10 to early 4.0 </td>
      </tr>
    </tbody>
  </table>
  <h4>Performance Counters </h4>
  <p>Though performance counters evidently were never intended as part of an “architecturally 
  defined section”, the <span class="struct">KPRCB</span> has at least some from 
  the very beginning, as with the following which help assess the performance of 
  Fast I/O by the file system (including third-party file system drivers). That 
  the kernel keeps a “per processor control block of cache manager system counters” 
  is disclosed by Microsoft in documentation of such functions as
  <span class="function">FsRtlIncrementCcFastReadNoWait</span>. </p>
  <p>The point to counting separately for each processor is typically not to learn 
  how the count for any one processor differs from that for any other. The total 
  count is what matters, but keeping it is faster if done in parts. Given that the 
  counter for each processor is incremented only by code that is running on that 
  processor, the increments can be done safely and quickly without concern for synchronisation. 
  They don’t even need to be interlocked. To evaluate the counter is to tally the 
  per-processor instances, but since this will be wanted only infrequently its overhead 
  is nothing relative to the gain from the likely numerous increments. </p>
  <p>Sets of counters that are likely to be touched together would better be in 
  the same cache line. In versions 5.1 to 6.0, the first six counters do indeed 
  start at a 64-byte address boundary, relative to the containing
  <span class="struct">KPCR</span>. Although this cache alignment is achieved without 
  explicit padding, it seems unlikely to be accidental, especially given that version 
  5.1 is when Windows starts paying attention to cache lines. Later versions work 
  to keep it, first by padding explicitly, then by bringing the space into use:
  </p>
  <table class="Struct">
    <colgroup>
      <col class="Offset"><col class="Definition"><col class="Versions">
    </colgroup>
    <thead>
      <tr>
        <th>Offset </th>
        <th>Definition </th>
        <th>Versions </th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td rowspan="3">0x04D8 (6.1 to 6.2); <br>
        0x04D4 (6.3 to 1709) </td>
        <td>
        <pre class="source">ULONG PrcbPad21 [2];</pre>
        </td>
        <td>6.1 to 6.2 </td>
      </tr>
      <tr>
        <td>
        <pre class="source">ULONG PrcbPad21 [3];</pre>
        </td>
        <td>6.3 to 1703 </td>
      </tr>
      <tr>
        <td>
        <pre class="source">ULONG PrcbPad21 [2];</pre>
        </td>
        <td>1709 only </td>
      </tr>
      <tr>
        <td rowspan="2">0x04D4 </td>
        <td>
        <pre class="source">PVOID MmFlushList;</pre>
        </td>
        <td>1803 only </td>
      </tr>
      <tr>
        <td>
        <pre class="source">PVOID MmInternal;</pre>
        </td>
        <td>1809 and higher </td>
      </tr>
      <tr>
        <td>0x04D8 </td>
        <td>
        <pre class="source"><a href="../../ntosdef/kprcbflag.htm">KPRCBFLAG</a> PrcbFlags;</pre>
        </td>
        <td>1803 and higher </td>
      </tr>
      <tr>
        <td>0x04DC </td>
        <td>
        <pre class="source">PVOID SchedulerAssist;</pre>
        </td>
        <td>1709 and higher </td>
      </tr>
    </tbody>
  </table>
  <p>Totals for the first six of the per-processor performance counters have always 
  been retrievable through the <span class="constant">SystemPerformanceInformation</span> 
  (0x02) case of <span class="function">NtQuerySystemInformation</span>: </p>
  <table class="Struct">
    <colgroup>
      <col class="Offset"><col class="Definition"><col class="Versions">
      <col class="Remarks">
    </colgroup>
    <thead>
      <tr>
        <th>Offset </th>
        <th>Definition </th>
        <th>Versions </th>
        <th>Remarks </th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td>0x0240 (3.10); <br>
        0x022C (3.50); <br>
        0x0204 (3.51 to 4.0); <br>
        0x0484 (5.0); <br>
        0x04E0 (5.1 to early 5.2); <br>
        0x0560 (late 5.2 to early 6.0); <br>
        0x05E0 (late 6.0); <br>
        0x04E0 </td>
        <td>
        <pre class="source">ULONG CcFastReadNoWait;</pre>
        </td>
        <td>all </td>
        <td>cache-aligned in 5.1 and higher </td>
      </tr>
      <tr>
        <td>0x0244 (3.10); <br>
        0x0230 (3.50); <br>
        0x0208 (3.51 to 4.0); <br>
        0x0488 (5.0); <br>
        0x04E4 (5.1 to early 5.2); <br>
        0x0564 (late 5.2 to early 6.0); <br>
        0x05E4 (late 6.0); <br>
        0x04E4 </td>
        <td>
        <pre class="source">ULONG CcFastReadWait;</pre>
        </td>
        <td>all </td>
        <td>&nbsp;</td>
      </tr>
      <tr>
        <td>0x0248 (3.10); <br>
        0x0234 (3.50); <br>
        0x020C (3.51 to 4.0); <br>
        0x048C (5.0); <br>
        0x04E8 (5.1 to early 5.2); <br>
        0x0568 (late 5.2 to early 6.0); <br>
        0x05E8 (late 6.0); <br>
        0x04E8 </td>
        <td>
        <pre class="source">ULONG CcFastReadNotPossible;</pre>
        </td>
        <td>all </td>
        <td>&nbsp;</td>
      </tr>
      <tr>
        <td>0x024C (3.10); <br>
        0x0238 (3.50); <br>
        0x0210 (3.51 to 4.0); <br>
        0x0490 (5.0); <br>
        0x04EC (5.1 to early 5.2); <br>
        0x056C (late 5.2 to early 6.0); <br>
        0x05EC (late 6.0); <br>
        0x04EC </td>
        <td>
        <pre class="source">ULONG CcCopyReadNoWait;</pre>
        </td>
        <td>all </td>
        <td>&nbsp;</td>
      </tr>
      <tr>
        <td>0x0250 (3.10); <br>
        0x023C (3.50); <br>
        0x0214 (3.51 to 4.0); <br>
        0x0494 (5.0); <br>
        0x04F0 (5.1 to early 5.2); <br>
        0x0570 (late 5.2 to early 6.0); <br>
        0x05F0 (late 6.0); <br>
        0x04F0 </td>
        <td>
        <pre class="source">ULONG CcCopyReadWait;</pre>
        </td>
        <td>all </td>
        <td>&nbsp;</td>
      </tr>
      <tr>
        <td>0x0254 (3.10); <br>
        0x0240 (3.50); <br>
        0x0218 (3.51 to 4.0); <br>
        0x0498 (5.0); <br>
        0x04F4 (5.1 to early 5.2); <br>
        0x0574 (late 5.2 to early 6.0); <br>
        0x05F4 (late 6.0); <br>
        0x04F4 </td>
        <td>
        <pre class="source">ULONG CcCopyReadNoWaitMiss;</pre>
        </td>
        <td>all </td>
        <td>&nbsp;</td>
      </tr>
    </tbody>
  </table>
  <p>Windows Vista adds substantially, including some that Windows Server 2003 SP1 
  had added further on. All except <span class="member">MmSpinLockOrdering</span> 
  are retrievable through the <span class="constant">SystemPerformanceInformation</span> 
  case of <span class="function">NtQuerySystemInformation</span> (as are the preceding 
  originals). They always have been, but as simple counters in kernel data. It just 
  took a while before Windows counted them in per-processor parts. </p>
  <table class="Struct">
    <colgroup>
      <col class="Offset"><col class="Definition"><col class="Versions">
      <col class="Remarks">
    </colgroup>
    <thead>
      <tr>
        <th>Offset </th>
        <th>Definition </th>
        <th>Versions </th>
        <th>Remarks </th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td>0x0578 (early 6.0); <br>
        0x05F8 (late 6.0); <br>
        0x04F8 </td>
        <td>
        <pre class="source">LONG volatile MmSpinLockOrdering;</pre>
        </td>
        <td>6.0 and higher </td>
        <td>&nbsp;</td>
      </tr>
      <tr>
        <td>0x057C (early 6.0); <br>
        0x05FC (late 6.0); <br>
        0x04FC </td>
        <td>
        <pre class="source">LONG volatile IoReadOperationCount;</pre>
        </td>
        <td>6.0 and higher </td>
        <td>previously at 0x059C </td>
      </tr>
      <tr>
        <td>0x0580 (early 6.0); <br>
        0x0600 (late 6.0); <br>
        0x0500 </td>
        <td>
        <pre class="source">LONG volatile IoWriteOperationCount;</pre>
        </td>
        <td>6.0 and higher </td>
        <td>previously at 0x05A0 </td>
      </tr>
      <tr>
        <td>0x0584 (early 6.0); <br>
        0x0604 (late 6.0); <br>
        0x0504 </td>
        <td>
        <pre class="source">LONG volatile IoOtherOperationCount;</pre>
        </td>
        <td>6.0 and higher </td>
        <td>previously at 0x05A4 </td>
      </tr>
      <tr>
        <td>0x0588 (early 6.0); <br>
        0x0608 (late 6.0); <br>
        0x0508 </td>
        <td>
        <pre class="source">LARGE_INTEGER IoReadTransferCount;</pre>
        </td>
        <td>6.0 and higher </td>
        <td>previously at 0x05A8 </td>
      </tr>
      <tr>
        <td>0x0590 (early 6.0); <br>
        0x0610 (late 6.0); <br>
        0x0510 </td>
        <td>
        <pre class="source">LARGE_INTEGER IoWriteTransferCount;</pre>
        </td>
        <td>6.0 and higher </td>
        <td>previously at 0x05B0 </td>
      </tr>
      <tr>
        <td>0x0598 (early 6.0); <br>
        0x0618 (late 6.0); <br>
        0x0518 </td>
        <td>
        <pre class="source">LARGE_INTEGER IoOtherTransferCount;</pre>
        </td>
        <td>6.0 and higher </td>
        <td>previously at 0x05B8 </td>
      </tr>
      <tr>
        <td>0x05A0 (early 6.0); <br>
        0x0620 (late 6.0); <br>
        0x0520 </td>
        <td>
        <pre class="source">ULONG CcFastMdlReadNoWait;</pre>
        </td>
        <td>6.0 and higher </td>
        <td>&nbsp;</td>
      </tr>
      <tr>
        <td>0x05A4 (early 6.0); <br>
        0x0624 (late 6.0); <br>
        0x0524 </td>
        <td>
        <pre class="source">ULONG CcFastMdlReadWait;</pre>
        </td>
        <td>6.0 and higher </td>
        <td>&nbsp;</td>
      </tr>
      <tr>
        <td>0x05A8 (early 6.0); <br>
        0x0628 (late 6.0); <br>
        0x0528 </td>
        <td>
        <pre class="source">ULONG CcFastMdlReadNotPossible;</pre>
        </td>
        <td>6.0 and higher </td>
        <td>&nbsp;</td>
      </tr>
      <tr>
        <td>0x05AC (early 6.0); <br>
        0x062C (late 6.0); <br>
        0x052C </td>
        <td>
        <pre class="source">ULONG CcMapDataNoWait;</pre>
        </td>
        <td>6.0 and higher </td>
        <td>&nbsp;</td>
      </tr>
      <tr>
        <td>0x05B0 (early 6.0); <br>
        0x0630 (late 6.0); <br>
        0x0530 </td>
        <td>
        <pre class="source">ULONG CcMapDataWait;</pre>
        </td>
        <td>6.0 and higher </td>
        <td>&nbsp;</td>
      </tr>
      <tr>
        <td>0x05B4 (early 6.0); <br>
        0x0634 (late 6.0); <br>
        0x0534 </td>
        <td>
        <pre class="source">ULONG CcPinMappedDataCount;</pre>
        </td>
        <td>6.0 and higher </td>
        <td>&nbsp;</td>
      </tr>
      <tr>
        <td>0x05B8 (early 6.0); <br>
        0x0638 (late 6.0); <br>
        0x0538 </td>
        <td>
        <pre class="source">ULONG CcPinReadNoWait;</pre>
        </td>
        <td>6.0 and higher </td>
        <td>&nbsp;</td>
      </tr>
      <tr>
        <td>0x05BC (early 6.0); <br>
        0x063C (late 6.0); <br>
        0x053C </td>
        <td>
        <pre class="source">ULONG CcPinReadWait;</pre>
        </td>
        <td>6.0 and higher </td>
        <td>&nbsp;</td>
      </tr>
      <tr>
        <td>0x05C0 (early 6.0); <br>
        0x0640 (late 6.0); <br>
        0x0540 </td>
        <td>
        <pre class="source">ULONG CcMdlReadNoWait;</pre>
        </td>
        <td>6.0 and higher </td>
        <td>&nbsp;</td>
      </tr>
      <tr>
        <td>0x05C4 (early 6.0); <br>
        0x0644 (late 6.0); <br>
        0x0544 </td>
        <td>
        <pre class="source">ULONG CcMdlReadWait;</pre>
        </td>
        <td>6.0 and higher </td>
        <td>&nbsp;</td>
      </tr>
      <tr>
        <td>0x05C8 (early 6.0); <br>
        0x0648 (late 6.0); <br>
        0x0548 </td>
        <td>
        <pre class="source">ULONG CcLazyWriteHotSpots;</pre>
        </td>
        <td>6.0 and higher </td>
        <td>&nbsp;</td>
      </tr>
      <tr>
        <td>0x05CC (early 6.0); <br>
        0x064C (late 6.0); <br>
        0x054C </td>
        <td>
        <pre class="source">ULONG CcLazyWriteIos;</pre>
        </td>
        <td>6.0 and higher </td>
        <td>&nbsp;</td>
      </tr>
      <tr>
        <td>0x05D0 (early 6.0); <br>
        0x0650 (late 6.0); <br>
        0x0550 </td>
        <td>
        <pre class="source">ULONG CcLazyWritePages;</pre>
        </td>
        <td>6.0 and higher </td>
        <td>&nbsp;</td>
      </tr>
      <tr>
        <td>0x05D4 (early 6.0); <br>
        0x0654 (late 6.0); <br>
        0x0554 </td>
        <td>
        <pre class="source">ULONG CcDataFlushes;</pre>
        </td>
        <td>6.0 and higher </td>
        <td>&nbsp;</td>
      </tr>
      <tr>
        <td>0x05D8 (early 6.0); <br>
        0x0658 (late 6.0); <br>
        0x0558 </td>
        <td>
        <pre class="source">ULONG CcDataPages;</pre>
        </td>
        <td>6.0 and higher </td>
        <td>&nbsp;</td>
      </tr>
      <tr>
        <td>0x05DC (early 6.0); <br>
        0x065C (late 6.0); <br>
        0x055C </td>
        <td>
        <pre class="source">ULONG CcLostDelayedWrites;</pre>
        </td>
        <td>6.0 and higher </td>
        <td>&nbsp;</td>
      </tr>
      <tr>
        <td>0x05E0 (early 6.0); <br>
        0x0660 (late 6.0); <br>
        0x0560 </td>
        <td>
        <pre class="source">ULONG CcFastReadResourceMiss;</pre>
        </td>
        <td>6.0 and higher </td>
        <td>&nbsp;</td>
      </tr>
      <tr>
        <td>0x05E4 (early 6.0); <br>
        0x0664 (late 6.0); <br>
        0x0564 </td>
        <td>
        <pre class="source">ULONG CcCopyReadWaitMiss;</pre>
        </td>
        <td>6.0 and higher </td>
        <td>&nbsp;</td>
      </tr>
      <tr>
        <td>0x05E8 (early 6.0); <br>
        0x0668 (late 6.0); <br>
        0x0568 </td>
        <td>
        <pre class="source">ULONG CcFastMdlReadResourceMiss;</pre>
        </td>
        <td>6.0 and higher </td>
        <td>&nbsp;</td>
      </tr>
      <tr>
        <td>0x05EC (early 6.0); <br>
        0x066C (late 6.0); <br>
        0x056C </td>
        <td>
        <pre class="source">ULONG CcMapDataNoWaitMiss;</pre>
        </td>
        <td>6.0 and higher </td>
        <td>&nbsp;</td>
      </tr>
      <tr>
        <td>0x05F0 (early 6.0); <br>
        0x0670 (late 6.0); <br>
        0x0570 </td>
        <td>
        <pre class="source">ULONG CcMapDataWaitMiss;</pre>
        </td>
        <td>6.0 and higher </td>
        <td>&nbsp;</td>
      </tr>
      <tr>
        <td>0x05F4 (early 6.0); <br>
        0x0674 (late 6.0); <br>
        0x0574 </td>
        <td>
        <pre class="source">ULONG CcPinReadNoWaitMiss;</pre>
        </td>
        <td>6.0 and higher </td>
        <td>&nbsp;</td>
      </tr>
      <tr>
        <td>0x05F8 (early 6.0); <br>
        0x0678 (late 6.0); <br>
        0x0578 </td>
        <td>
        <pre class="source">ULONG CcPinReadWaitMiss;</pre>
        </td>
        <td>6.0 and higher </td>
        <td>&nbsp;</td>
      </tr>
      <tr>
        <td>0x05FC (early 6.0); <br>
        0x067C (late 6.0); <br>
        0x057C </td>
        <td>
        <pre class="source">ULONG CcMdlReadNoWaitMiss;</pre>
        </td>
        <td>6.0 and higher </td>
        <td>&nbsp;</td>
      </tr>
      <tr>
        <td>0x0600 (early 6.0); <br>
        0x0680 (late 6.0); <br>
        0x0580 </td>
        <td>
        <pre class="source">ULONG CcMdlReadWaitMiss;</pre>
        </td>
        <td>6.0 and higher </td>
        <td>&nbsp;</td>
      </tr>
      <tr>
        <td>0x0604 (early 6.0); <br>
        0x0684 (late 6.0); <br>
        0x0584 </td>
        <td>
        <pre class="source">ULONG CcReadAheadIos;</pre>
        </td>
        <td>6.0 and higher </td>
        <td>&nbsp;</td>
      </tr>
    </tbody>
  </table>
  <p>The preceding selection of performance counters for the Cache Manager expanded 
  as soon as version 3.50 with some miscellany for the Kernel Core. Several are 
  retrievable through <span class="function">NtQuerySystemInformation</span>:
  </p>
  <ul>
    <li><span class="constant">SystemPerformanceInformation</span> (again) for
    <span class="member">KeContextSwitches</span>, <span class="member">KeFirstLevelTbFills</span>,
    <span class="member">KeSecondLevelTbFills</span> and <span class="member">KeSystemCalls</span>;
    </li>
    <li><span class="constant">SystemExceptionInformation</span> for
    <span class="member">KeAlignmentFixupCount</span>, <span class="member">KeExceptionDispatchCount</span> 
    and <span class="member">KeFloatingEmulationCount</span>. </li>
  </ul>
  <p>No use is known of <span class="member">KeDcacheFlushCount</span> or
  <span class="member">KeIcacheFlushCount</span> in any version. </p>
  <table class="Struct">
    <colgroup>
      <col class="Offset"><col class="Definition"><col class="Versions">
      <col class="Remarks">
    </colgroup>
    <thead>
      <tr>
        <th>Offset </th>
        <th>Definition </th>
        <th>Versions </th>
        <th>Remarks </th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td>0x0244 (3.50); <br>
        0x021C (3.51 to 4.0); <br>
        0x049C (5.0); <br>
        0x04F8 (5.1 to early 5.2); <br>
        0x0578 (late 5.2); <br>
        0x0608 (early 6.0); <br>
        0x0688 (late 6.0); <br>
        0x0588 </td>
        <td>
        <pre class="source">ULONG KeAlignmentFixupCount;</pre>
        </td>
        <td>3.50 and higher </td>
        <td>&nbsp;</td>
      </tr>
      <tr>
        <td rowspan="2">0x0248 (3.50); <br>
        0x0220 (3.51 to 4.0); <br>
        0x04A0 (5.0); <br>
        0x04FC (5.1 to early 5.2); <br>
        0x057C (late 5.2) </td>
        <td>
        <pre class="source">ULONG KeContextSwitches;</pre>
        </td>
        <td>3.50 to 5.1 </td>
        <td>next as <span class="member">ContextSwitches</span> in
        <span class="struct">KPCR</span> </td>
      </tr>
      <tr>
        <td>
        <pre class="source">ULONG SpareCounter0;</pre>
        </td>
        <td>5.2 only </td>
        <td>&nbsp;</td>
      </tr>
      <tr>
        <td>0x024C (3.50); <br>
        0x0224 (3.51 to 4.0); <br>
        0x04A4 (5.0); <br>
        0x0500 (5.1 to early 5.2); <br>
        0x0580 (late 5.2) </td>
        <td>
        <pre class="source">ULONG KeDcacheFlushCount;</pre>
        </td>
        <td>3.50 to 5.2 </td>
        <td>&nbsp;</td>
      </tr>
      <tr>
        <td>0x0250 (3.50); <br>
        0x0228 (3.51 to 4.0); <br>
        0x04A8 (5.0); <br>
        0x0504 (5.1 to early 5.2); <br>
        0x0584 (late 5.2); <br>
        0x060C (early 6.0); <br>
        0x068C (late 6.0); <br>
        0x058C </td>
        <td>
        <pre class="source">ULONG KeExceptionDispatchCount;</pre>
        </td>
        <td>3.50 and higher </td>
        <td>&nbsp;</td>
      </tr>
      <tr>
        <td>0x0254 (3.50); <br>
        0x022C (3.51 to 4.0); <br>
        0x04AC (5.0); <br>
        0x0508 (5.1 to early 5.2); <br>
        0x0588 (late 5.2) </td>
        <td>
        <pre class="source">ULONG KeFirstLevelTbFills;</pre>
        </td>
        <td>3.50 to 5.2 </td>
        <td>&nbsp;</td>
      </tr>
      <tr>
        <td>0x0258 (3.50); <br>
        0x0230 (3.51 to 4.0); <br>
        0x04B0 (5.0); <br>
        0x050C (5.1 to early 5.2); <br>
        0x058C (late 5.2) </td>
        <td>
        <pre class="source">ULONG KeFloatingEmulationCount;</pre>
        </td>
        <td>3.50 to 5.2 </td>
        <td>&nbsp;</td>
      </tr>
      <tr>
        <td>0x025C (3.50); <br>
        0x0234 (3.51 to 4.0); <br>
        0x04B4 (5.0); <br>
        0x0510 (5.1 to early 5.2); <br>
        0x0590 (late 5.2) </td>
        <td>
        <pre class="source">ULONG KeIcacheFlushCount;</pre>
        </td>
        <td>3.50 to 5.2 </td>
        <td>&nbsp;</td>
      </tr>
      <tr>
        <td>0x0260 (3.50); <br>
        0x0238 (3.51 to 4.0); <br>
        0x04B8 (5.0); <br>
        0x0514 (5.1 to early 5.2); <br>
        0x0594 (late 5.2) </td>
        <td>
        <pre class="soruce">ULONG KeSecondLevelTbFills;</pre>
        </td>
        <td>3.50 to 5.2 </td>
        <td>&nbsp;</td>
      </tr>
      <tr>
        <td>0x0264 (3.50); <br>
        0x023C (3.51 to 4.0); <br>
        0x04BC (5.0); <br>
        0x0518 (5.1 to early 5.2); <br>
        0x0598 (late 5.2); <br>
        0x0610 (early 6.0); <br>
        0x0690 (late 6.0); <br>
        0x0590 </td>
        <td>
        <pre class="source">ULONG KeSystemCalls;</pre>
        </td>
        <td>3.50 and higher </td>
        <td>&nbsp;</td>
      </tr>
      <tr>
        <td>0x0594 </td>
        <td>
        <pre class="source">ULONG AvailableTime;</pre>
        </td>
        <td>6.1 and higher </td>
        <td>&nbsp;</td>
      </tr>
    </tbody>
  </table>
  <p>When Windows Server 2003 SP1 added counters for I/O operations, it appended 
  to the existing counters. But they didn’t stay for long: Windows Vista moved them 
  forward. </p>
  <table class="Struct">
    <colgroup>
      <col class="Offset"><col class="Definition"><col class="Versions">
      <col class="Remarks">
    </colgroup>
    <thead>
      <tr>
        <th>Offset </th>
        <th>Definition </th>
        <th>Versions </th>
        <th>Remarks </th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td>0x059C (late 5.2) </td>
        <td>
        <pre class="source">LONG volatile IoReadOperationCount;</pre>
        </td>
        <td>late 5.2 only </td>
        <td>next at 0x057C </td>
      </tr>
      <tr>
        <td>0x05A0 (late 5.2) </td>
        <td>
        <pre class="source">LONG volatile IoWriteOperationCount;</pre>
        </td>
        <td>late 5.2 only </td>
        <td>next at 0x0580 </td>
      </tr>
      <tr>
        <td>0x05A4 (late 5.2) </td>
        <td>
        <pre class="source">LONG volatile IoOtherOperationCount;</pre>
        </td>
        <td>late 5.2 only </td>
        <td>next at 0x0584 </td>
      </tr>
      <tr>
        <td>0x05A8 (late 5.2) </td>
        <td>
        <pre class="source">LARGE_INTEGER IoReadTransferCount;</pre>
        </td>
        <td>late 5.2 only </td>
        <td>next at 0x0588 </td>
      </tr>
      <tr>
        <td>0x05B0 (late 5.2) </td>
        <td>
        <pre class="source">LARGE_INTEGER IoWriteTransferCount;</pre>
        </td>
        <td>late 5.2 only </td>
        <td>next at 0x0590 </td>
      </tr>
      <tr>
        <td>0x05B8 (late 5.2) </td>
        <td>
        <pre class="source">LARGE_INTEGER IoOtherTransferCount;</pre>
        </td>
        <td>late 5.2 only </td>
        <td>next at 0x0598 </td>
      </tr>
    </tbody>
  </table>
  <p>The early versions follow their performance counters with space for which no 
  use is known other than two pointers that added to the original optimisation of 
  file locking. It is mere supposition that this unaccounted space in the earliest 
  versions is just a larger allowance for the same reservation that is known for 
  Windows NT 4.0 and Windows 2000 from type information. </p>
  <table class="Struct">
    <colgroup>
      <col class="Offset"><col class="Definition"><col class="Versions">
      <col class="Remarks">
    </colgroup>
    <thead>
      <tr>
        <th>Offset </th>
        <th>Definition </th>
        <th>Versions </th>
        <th>Remarks </th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td>0x0240 (early 4.0) </td>
        <td>
        <pre class="source">SINGLE_LIST_ENTRY FsRtlFreeWaitingLockList;</pre>
        </td>
        <td>early 4.0 only </td>
        <td>&nbsp;</td>
      </tr>
      <tr>
        <td>0x0244 (early 4.0) </td>
        <td>
        <pre class="source">SINGLE_LIST_ENTRY FsRtlFreeLockTreeNodeList;</pre>
        </td>
        <td>early 4.0 only </td>
        <td>&nbsp;</td>
      </tr>
      <tr>
        <td rowspan="10">0x0258 (3.10); <br>
        0x0268 (3.50); <br>
        0x0240 (3.51); <br>
        0x0248 (early 4.0); <br>
        0x0240 (late 4.0); <br>
        0x04C0 (5.0); <br>
        0x051C (5.1 to early 5.2); <br>
        0x05C0 (late 5.2); <br>
        0x0614 (early 6.0); <br>
        0x0694 (late 6.0); <br>
        0x0598 </td>
        <td>
        <pre class="source">ULONG ReservedCounter [0x10];</pre>
        </td>
        <td>3.10 only </td>
        <td>last member in 3.10 </td>
      </tr>
      <tr>
        <td>
        <pre class="source">ULONG ReservedCounter [0x20];</pre>
        </td>
        <td>3.50 to 3.51 </td>
        <td>&nbsp;</td>
      </tr>
      <tr>
        <td>
        <pre class="source">ULONG ReservedCounter [6];</pre>
        </td>
        <td>early 4.0 only </td>
        <td>&nbsp;</td>
      </tr>
      <tr>
        <td>
        <pre class="source">ULONG ReservedCounter [8];</pre>
        </td>
        <td>late 4.0 to 5.0 </td>
        <td>&nbsp;</td>
      </tr>
      <tr>
        <td>
        <pre class="source">ULONG SpareCounter0 [1];</pre>
        </td>
        <td>5.1 only </td>
        <td>&nbsp;</td>
      </tr>
      <tr>
        <td>
        <pre class="source">ULONG SpareCounter1;</pre>
        </td>
        <td>early 5.2 only </td>
        <td>&nbsp;</td>
      </tr>
      <tr>
        <td>
        <pre class="source">ULONG SpareCounter1 [8];</pre>
        </td>
        <td>late 5.2 only </td>
        <td>&nbsp;</td>
      </tr>
      <tr>
        <td>
        <pre class="source">ULONG PrcbPad1 [3];</pre>
        </td>
        <td>early 6.0 only </td>
        <td>&nbsp;</td>
      </tr>
      <tr>
        <td>
        <pre class="source">ULONG PrcbPad2 [3];</pre>
        </td>
        <td>late 6.0 only </td>
        <td>&nbsp;</td>
      </tr>
      <tr>
        <td>
        <pre class="source">ULONG PrcbPad22 [2];</pre>
        </td>
        <td>6.1 and higher </td>
        <td>&nbsp;</td>
      </tr>
    </tbody>
  </table>
  <p>That space had been set aside for counters was remembered in the names until 
  a change for version 6.0. But whatever the name, every version from 4.0 onwards 
  allows for expansion but takes care to adjust the padding to end exactly at the 
  next 64-byte alignment boundary relative to the containing
  <span class="struct">KPCR</span>. </p>
  <h4>Per-Processor Lookaside Lists </h4>
  <p>Symbol files for Windows 2000 SP3 and SP4 and even the CRASHLIB.LIB for Windows 
  NT 4.0 define the following pointers, apparently to chains of freed structures 
  as a cache to speed their reuse. However, no use is known of them. They perhaps 
  remain from development of the per-processor lookaside lists for special purposes 
  (taken up next). After all, the names suggest the same purposes in the same order.
  </p>
  <table class="struct">
    <colgroup>
      <col class="Offset"><col class="Definition"><col class="Versions">
    </colgroup>
    <thead>
      <tr>
        <th>Offset </th>
        <th>Definition </th>
        <th>Versions </th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td>0x0260 (4.0); <br>
        0x04E0 (5.0) </td>
        <td>
        <pre class="source">PVOID SmallIrpFreeEntry;</pre>
        </td>
        <td>4.0 to 5.0 </td>
      </tr>
      <tr>
        <td>0x0264 (4.0); <br>
        0x04E4 (5.0) </td>
        <td>
        <pre class="source">PVOID LargeIrpFreeEntry;</pre>
        </td>
        <td>4.0 to 5.0 </td>
      </tr>
      <tr>
        <td>0x0268 (4.0); <br>
        0x04E8 (5.0) </td>
        <td>
        <pre class="source">PVOID MdlFreeEntry;</pre>
        </td>
        <td>4.0 to 5.0 </td>
      </tr>
      <tr>
        <td>0x026C (4.0); <br>
        0x04EC (5.0) </td>
        <td>
        <pre class="source">PVOID CreateInfoFreeEntry;</pre>
        </td>
        <td>4.0 to 5.0 </td>
      </tr>
      <tr>
        <td>0x0270 (4.0); <br>
        0x04F0 (5.0) </td>
        <td>
        <pre class="source">PVOID NameBufferFreeEntry;</pre>
        </td>
        <td>4.0 to 5.0 </td>
      </tr>
      <tr>
        <td>0x0274 (4.0); <br>
        0x04F4 (5.0) </td>
        <td>
        <pre class="source">PVOID SharedCacheMapFreeEntry;</pre>
        </td>
        <td>4.0 to 5.0 </td>
      </tr>
      <tr>
        <td>0x0278 (4.0); <br>
        0x04F8 (5.0) </td>
        <td>
        <pre class="source">ULONG CachePad0 [2];</pre>
        </td>
        <td>4.0 to 5.0 </td>
      </tr>
    </tbody>
  </table>
  <p>Note that this first name that explicitly suggests padding for cache alignment 
  does not actually cache-align what follows. It does within the
  <span class="struct">KPRCB</span>, but the <span class="struct">KPRCB</span> itself 
  is not cache-aligned within the <span class="struct">KPCR</span>. </p>
  <h4>System Lookaside Lists </h4>
  <p>Though <a href="../../../../api/ex/lookasid/index.htm">lookaside lists</a> 
  were introduced for version 4.0, it’s not until version 5.0 that the kernel sets 
  some up for per-processor use. Broadly speaking, there are two separate types 
  of per-processor lookaside lists. First come the system lookaside lists. </p>
  <table class="struct">
    <colgroup>
      <col class="Offset"><col class="Definition"><col class="Versions">
      <col class="Remarks">
    </colgroup>
    <thead>
      <tr>
        <th>Offset </th>
        <th>Definition </th>
        <th>Versions </th>
        <th>Remarks </th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td>0x0500 (5.0); <br>
        0x0520 (5.1 to early 5.2); <br>
        0x05E0 (late 5.2); <br>
        0x0620 (early 6.0); <br>
        0x06A0 (late 6.0); <br>
        0x05A0 </td>
        <td>
        <pre class="source">PP_LOOKASIDE_LIST PPLookasideList [0x10];</pre>
        </td>
        <td>5.0 and higher </td>
        <td>cache-aligned in 5.1 and higher </td>
      </tr>
    </tbody>
  </table>
  <p>The <span class="member">PPLookasideList</span> array is indexed by the undocumented 
  enumeration <span class="enum">
  <a href="../../ex/pp_npaged_lookaside_number.htm">PP_NPAGED_LOOKASIDE_NUMBER</a></span>. 
  Its different values represent lookaside lists that cache very different fixed-size 
  structures that each have a very specific purpose. </p>
  <p>The undocumented <span class="struct">PP_LOOKASIDE_LIST</span> structure is 
  a pair of pointers, <span class="member">P</span> and <span class="member">L</span>, 
  to the actual lookaside lists. Ideally, they point to separate lists: the first 
  just for the processor; the second shared. Allocations are sought first from the 
  per-processor list, for speed, else from the shared. Allocations are freed to 
  the per-processor list for easy re-allocation, except that if that list has reached 
  its capacity the allocation is instead freed to the shared list. </p>
  <p>To support the <span class="constant">SystemLookasideInformation</span> case 
  of the <span class="function">NtQuerySystemInformation</span> function the kernel 
  keeps a double-linked list of all the lookaside lists that are pointed to from 
  the <span class="member">PPLookasideList</span> arrays for all processors. Although 
  additions to the list, when building the <span class="struct">KPRCB</span> for 
  a newly added processor, can be made by only one thread at a time, no synchronisation 
  is known with this function’s enumeration of the list. </p>
  <p>Note that in version 5.1 and higher, the <span class="member">PPLookasideList</span> 
  array starts on a 64-byte boundary, relative to the containing
  <span class="struct">KPCR</span>. Indeed, all the array that is known to be used 
  before Windows 7 fits in one 64-byte cache line. The allowance for 0x10 lists 
  when only 9 are yet defined is presumably intended so that the pool lookaside 
  lists that follow are also cache-aligned. </p>
  <h4>Pool Lookaside Lists </h4>
  <table class="Struct">
    <colgroup>
      <col class="Offset"><col class="Definition"><col class="Versions">
      <col class="Remarks">
    </colgroup>
    <thead>
      <tr>
        <th>Offset </th>
        <th>Definition </th>
        <th>Versions </th>
        <th>Remarks </th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td>0x0620 </td>
        <td>
        <pre class="source">GENERAL_LOOKASIDE_POOL PPNxPagedLookasideList [0x20];</pre>
        </td>
        <td>6.2 and higher </td>
        <td>cache-aligned </td>
      </tr>
      <tr>
        <td rowspan="3">0x0580 (5.0); <br>
        0x05A0 (5.1 to early 5.2); <br>
        0x0660 (late 5.2); <br>
        0x06A0 (early 6.0); <br>
        0x0720 (late 6.0); <br>
        0x0620 (6.1); <br>
        0x0F20 </td>
        <td>
        <pre class="source">PP_LOOKASIDE_LIST PPNPagedLookasideList [8];</pre>
        </td>
        <td>5.0 only </td>
        <td>&nbsp;</td>
      </tr>
      <tr>
        <td>
        <pre class="source">PP_LOOKASIDE_LIST PPNPagedLookasideList [0x20];</pre>
        </td>
        <td>5.1 to 5.2 </td>
        <td>cache-aligned </td>
      </tr>
      <tr>
        <td>
        <pre class="source">GENERAL_LOOKASIDE_POOL PPNPagedLookasideList [0x20];</pre>
        </td>
        <td>6.0 and higher </td>
        <td>cache-aligned </td>
      </tr>
      <tr>
        <td rowspan="3">0x05C0 (5.0); <br>
        0x06A0 (5.1 to early 5.2); <br>
        0x0760 (late 5.2); <br>
        0x0FA0 (early 6.0); <br>
        0x1020 (late 6.0); <br>
        0x0F20 (6.1); <br>
        0x1820 </td>
        <td>
        <pre class="source">PP_LOOKASIDE_LIST PPPagedLookasideList [8];</pre>
        </td>
        <td>5.0 only </td>
        <td>&nbsp;</td>
      </tr>
      <tr>
        <td>
        <pre class="source">PP_LOOKASIDE_LIST PPPagedLookasideList [0x20];</pre>
        </td>
        <td>5.1 to 5.2 </td>
        <td>cache-aligned </td>
      </tr>
      <tr>
        <td>
        <pre class="source">GENERAL_LOOKASIDE_POOL PPPagedLookasideList [0x20];</pre>
        </td>
        <td>6.0 and higher </td>
        <td>cache-aligned </td>
      </tr>
    </tbody>
  </table>
  <p>The pool lookaside lists help with the efficiency of small allocations from 
  various types of pool (<span class="constant">NonPagedPool</span>,
  <span class="constant">PagedPool</span> and, in version 6.2 and higher,
  <span class="constant">NonPagedPoolNx</span>). Successive lookaside lists in each 
  array are for successively larger sizes of allocation from that pool type. When 
  first introduced, for Windows 2000, the caching was relatively coarse. The first 
  list was for all allocations up to and including 0x20 bytes, which was also the 
  increment from one list to the next. Eight lists thus supported per-processor 
  caching of freed pool allocations up to and including 0x0100 bytes. Windows XP 
  and higher have the same coverage but in increments of 0x08 bytes. </p>
  <p>To support the <span class="constant">SystemPerformanceInformation</span> and
  <span class="constant">SystemLookasideInformation</span> cases of the
  <span class="function">NtQuerySystemInformation</span> function the kernel keeps 
  a double-linked list of all the pool lookaside lists for all processors. Although 
  additions to the list, when building the <span class="struct">KPRCB</span> for 
  a newly added processor, can be made by only one thread at a time, no synchronisation 
  is known with this function’s enumeration of the list. </p>
  <table class="Struct">
    <colgroup>
      <col class="Offset"><col class="Definition"><col class="Versions">
    </colgroup>
    <thead>
      <tr>
        <th>Offset </th>
        <th>Definition </th>
        <th>Versions </th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td rowspan="2">0x0280 (4.0); <br>
        0x0600 (5.0) </td>
        <td>
        <pre class="source">ULONG ReservedPad [0x80];</pre>
        </td>
        <td>4.0 only </td>
      </tr>
      <tr>
        <td>
        <pre class="source">ULONG ReservedPad [0x20];</pre>
        </td>
        <td>5.0 only </td>
      </tr>
    </tbody>
  </table>
  <h4>Inter-Processor Interrupts </h4>
  <p>As an earlier implementation of inter-processor interrupts grew in sophistication 
  it moved here for version 3.51, and has mostly stayed, albeit with reordering. 
  Insertions for versions 4.0 and 5.1 put the supporting members into three sets, 
  each in its own cache line. </p>
  <table class="Struct">
    <colgroup>
      <col class="Offset"><col class="Definition"><col class="Versions">
      <col class="Remarks">
    </colgroup>
    <thead>
      <tr>
        <th>Offset </th>
        <th>Definition </th>
        <th>Versions </th>
        <th>Remarks </th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td>0x07A0 (5.1 to early 5.2); <br>
        0x0860 (late 5.2); <br>
        0x18A0 (early 6.0); <br>
        0x1920 (late 6.0); <br>
        0x1820 (6.1); <br>
        0x2120 </td>
        <td>
        <pre class="source">ULONG volatile PacketBarrier;</pre>
        </td>
        <td>5.1 and higher </td>
        <td>cache-aligned </td>
      </tr>
      <tr>
        <td>0x07A4 (5.1 to early 5.2); <br>
        0x0864 (late 5.2); <br>
        0x18A4 (early 6.0); <br>
        0x1924 (late 6.0); <br>
        0x1824 (6.1); <br>
        0x2124 </td>
        <td>
        <pre class="source">ULONG volatile ReverseStall;</pre>
        </td>
        <td>5.1 and higher </td>
        <td>previously at 0x06A8 </td>
      </tr>
      <tr>
        <td>0x07A8 (5.1 to early 5.2); <br>
        0x0868 (late 5.2); <br>
        0x18A8 (early 6.0); <br>
        0x1928 (late 6.0); <br>
        0x1828 (6.1); <br>
        0x2128 </td>
        <td>
        <pre class="source">PVOID IpiFrame;</pre>
        </td>
        <td>5.1 and higher </td>
        <td>previously at 0x06AC </td>
      </tr>
      <tr>
        <td rowspan="2">0x07AC (5.1 to early 5.2); <br>
        0x086C (late 5.2); <br>
        0x18AC (early 6.0); <br>
        0x192C (late 6.0); <br>
        0x182C (6.1); <br>
        0x212C </td>
        <td>
        <pre class="source">UCHAR PrcbPad2 [0x34];</pre>
        </td>
        <td>5.1 to early 6.0 </td>
        <td>&nbsp;</td>
      </tr>
      <tr>
        <td>
        <pre class="source">UCHAR PrcbPad3 [0x34];</pre>
        </td>
        <td>late 6.0 and higher </td>
        <td>&nbsp;</td>
      </tr>
    </tbody>
  </table>
  <p>The name <span class="member">ReverseStall</span> takes its name from the stall 
  that is typically entered by the sender to wait for its request to be serviced 
  by all the targets. The reverse is that the target stalls too. Having signalled 
  that it is done with the packet, it stalls until someone changes whatever was 
  in the sender’s <span class="member">ReverseStall</span>. </p>
  <table class="Struct">
    <colgroup>
      <col class="Offset"><col class="Definition"><col class="Versions">
      <col class="Remarks">
    </colgroup>
    <thead>
      <tr>
        <th>Offset </th>
        <th>Definition </th>
        <th>Versions </th>
        <th>Remarks </th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td>0x0480 (4.0); <br>
        0x0680 (5.0); <br>
        0x07E0 (5.1 to early 5.2); <br>
        0x08A0 (late 5.2); <br>
        0x18E0 (early 6.0); <br>
        0x1960 (late 6.0); <br>
        0x1860 (6.1); <br>
        0x2160 </td>
        <td>
        <pre class="source">PVOID volatile CurrentPacket [3];</pre>
        </td>
        <td>4.0 and higher </td>
        <td>cache-aligned in 5.1 and higher </td>
      </tr>
      <tr>
        <td>0x048C (4.0); <br>
        0x068C (5.0); <br>
        0x07EC (5.1 to early 5.2); <br>
        0x08AC (late 5.2); <br>
        0x18EC (early 6.0); <br>
        0x196C (late 6.0); <br>
        0x186C (6.1); <br>
        0x216C </td>
        <td>
        <pre class="source">KAFFINITY volatile TargetSet;</pre>
        </td>
        <td>4.0 and higher </td>
        <td>&nbsp;</td>
      </tr>
      <tr>
        <td>0x0490 (4.0); <br>
        0x0690 (5.0); <br>
        0x07F0 (5.1 to early 5.2); <br>
        0x08B0 (late 5.2); <br>
        0x18F0 (early 6.0); <br>
        0x1970 (late 6.0); <br>
        0x1870 (6.1); <br>
        0x2170 </td>
        <td>
        <pre class="source">PKIPI_WORKER volatile WorkerRoutine;</pre>
        </td>
        <td>4.0 and higher </td>
        <td>&nbsp;</td>
      </tr>
      <tr>
        <td>0x0494 (4.0); <br>
        0x0694 (5.0); <br>
        0x07F4 (5.1 to early 5.2); <br>
        0x08B4 (late 5.2); <br>
        0x18F0 (early 6.0); <br>
        0x1974 (late 6.0); <br>
        0x1874 (6.1); <br>
        0x2174 </td>
        <td>
        <pre class="source">ULONG volatile IpiFrozen;</pre>
        </td>
        <td>4.0 and higher </td>
        <td>previously as <span class="type">UCHAR volatile</span> at 0x02CC
        </td>
      </tr>
      <tr>
        <td rowspan="3">0x0498 (4.0); <br>
        0x0698 (5.0); <br>
        0x07F8 (5.1 to early 5.2); <br>
        0x08B8 (late 5.2); <br>
        0x18F8 (early 6.0); <br>
        0x1978 (late 6.0); <br>
        0x1878 (6.1); <br>
        0x2178 </td>
        <td>
        <pre class="source">ULONG CachePad1 [2];</pre>
        </td>
        <td>4.0 to 5.0 </td>
        <td>&nbsp;</td>
      </tr>
      <tr>
        <td>
        <pre class="source">UCHAR PrcbPad3 [0x28];</pre>
        </td>
        <td>5.1 to early 6.0 </td>
        <td>&nbsp;</td>
      </tr>
      <tr>
        <td>
        <pre class="source">UCHAR PrcbPad4 [0x28];</pre>
        </td>
        <td>late 6.0 and higher </td>
        <td>&nbsp;</td>
      </tr>
    </tbody>
  </table>
  <p>These additions for version 4.0 are the essence of what may at the time have 
  been a big advance in sending packet-based requests between processors. Before 
  version 4.0, a processor could send a packet to multiple targets but two processors 
  cannot send packets concurrently, not even to separate targets. The new
  <span class="member">CurrentPacket</span>, <span class="member">TargetSet</span> 
  and <span class="member">WorkerRoutine</span> are in essence the packet: three 
  arbitrary parameters; a bitmap of targets; a worker routine that’s to execute 
  on each target (and be given the three parameters). The bottleneck in earlier 
  versions is that these are kept in the kernel’s own data. Version 4.0 keeps them 
  in the sender’s <span class="struct">KPRCB</span>. Each target knows who sent 
  the packet because the sender records the address of its own
  <span class="struct">KPRCB</span> as the <span class="member">SignalDone</span> 
  member (in the next cache line) in each target’s <span class="struct">KPRCB</span>.
  </p>
  <p>The type <span class="type">PKIPI_WORKER</span> is is defined in one or more 
  of the NTDDK.H, WDM.H and NTIFS.H from the Device Driver Kit (DDK) for Windows 
  NT 4.0 up to and including the WDK for Windows, and then only ever again in the 
  NTOSP.H from those early editions of the WDK for Windows 10. The type has a subtle 
  change between versions 4.0 and 5.0. In all versions it is </p>
  <pre class="source">typedef 
VOID 
(*PKIPI_WORKER) (
    PKIPI_CONTEXT PacketContext, 
    PVOID Parameter1, 
    PVOID Parameter2, 
    PVOID Parameter3);</pre>
  <p>but the <span class="type">PKIPI_CONTEXT</span> is a pointer to a
  <span class="type">ULONG</span> in version 4.0 and then becomes a pointer to
  <span class="type">void</span>. In version 3.51, this first argument is a pointer 
  to a 20-byte structure which perhaps was named <span class="struct">KIPI_CONTEXT</span>. 
  Microsoft’s names for its members are not known, though it would not surprise 
  to find that some of them survive as (otherwise quirky) names of other new
  <span class="struct">KPRCB</span> members. </p>
  <table class="Struct">
    <colgroup>
      <col class="Offset"><col class="Definition"><col class="Versions">
      <col class="Remarks">
    </colgroup>
    <thead>
      <tr>
        <th>Offset </th>
        <th>Definition </th>
        <th>Versions </th>
        <th>Remarks </th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td rowspan="2">0x02C0 (3.51); <br>
        0x04A0 (4.0); <br>
        0x06A0 (5.0); <br>
        0x0820 (5.1 to early 5.2); <br>
        0x08E0 (late 5.2); <br>
        0x1920 (early 6.0); <br>
        0x19A0 (late 6.0); <br>
        0x18A0 (6.1); <br>
        0x21A0 </td>
        <td>
        <pre class="source">BOOLEAN volatile IpiCommands [4];</pre>
        </td>
        <td>3.51 only </td>
        <td>previously at 0x01F4 </td>
      </tr>
      <tr>
        <td>
        <pre class="source">ULONG volatile RequestSummary;</pre>
        </td>
        <td>4.0 and higher </td>
        <td>cache-aligned </td>
      </tr>
      <tr>
        <td rowspan="3">0x02C4 (3.51); <br>
        0x04A4 (4.0); <br>
        0x06A4 (5.0); <br>
        0x0824 (5.1 to early 5.2); <br>
        0x08E4 (late 5.2); <br>
        0x1924 (early 6.0); <br>
        0x19A4 (late 6.0); <br>
        0x18A4 (6.1); <br>
        0x21A4 </td>
        <td>
        <pre class="source">ULONG volatile IpiLastPacket;</pre>
        </td>
        <td>3.51 only </td>
        <td>previously at 0x0200 </td>
      </tr>
      <tr>
        <td>
        <pre class="source">KPRCB volatile *SignalDone;</pre>
        </td>
        <td>4.0 to 6.3 </td>
        <td>&nbsp;</td>
      </tr>
      <tr>
        <td>
        <pre class="source">LONG volatile TargetCount;</pre>
        </td>
        <td>10.0 and higher </td>
        <td>&nbsp;</td>
      </tr>
      <tr>
        <td>0x02C8 (3.51); <br>
        0x04A8 (4.0); <br>
        0x06A8 (5.0) </td>
        <td>
        <pre class="source">ULONG volatile ReverseStall;</pre>
        </td>
        <td>3.51 to 5.0 </td>
        <td>previously at 0x01FC; <br>
        next at 0x07A4 </td>
      </tr>
      <tr>
        <td>0x02CC (3.51) <br>
        </td>
        <td>
        <pre class="source">UCHAR volatile IpiFrozen;</pre>
        </td>
        <td>3.51 only </td>
        <td>previously at 0x01F8; <br>
        next as <span class="type">ULONG volatile</span> at 0x0494 </td>
      </tr>
      <tr>
        <td>0x04AC (4.0); <br>
        0x06AC (5.0) </td>
        <td>
        <pre class="source">PVOID IpiFrame;</pre>
        </td>
        <td>4.0 to 5.0 </td>
        <td>next at 0x07A8 </td>
      </tr>
    </tbody>
  </table>
  <p>The <span class="member">RequestSummary</span> starts with the old implementation 
  as an array of bytes that record which of the four possible types of packet-less 
  request are being sent to the processor. Version 4.0 changed to bit flags, perhaps 
  anticipating new types of requests, one of which was added for version 5.0. Microsoft’s 
  assembly-language names for these bit flags have long been public: see, for instance,
  <span class="constant">IPI_APC</span>, in the KS386.INC from the DDK for Windows 
  Server 2003 SP1. </p>
  <table class="Struct">
    <colgroup>
      <col class="Offset"><col class="Definition"><col class="Versions">
      <col class="Remarks">
    </colgroup>
    <thead>
      <tr>
        <th>Offset </th>
        <th>Definition </th>
        <th>Versions </th>
        <th>Remarks </th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td rowspan="2">0x21A8 </td>
        <td>
        <pre class="source">ULONGLONG LastNonHrTimerExpiration;</pre>
        </td>
        <td>1607 to 1903 </td>
        <td>&nbsp;</td>
      </tr>
      <tr>
        <td>
        <pre class="source">ULONG PrcbPad94 [2];</pre>
        </td>
        <td>2004 and higher </td>
        <td>&nbsp;</td>
      </tr>
      <tr>
        <td>0x21B0 </td>
        <td>
        <pre class="source">ULONGLONG TrappedSecurityDomain;</pre>
        </td>
        <td>1803 and higher </td>
        <td>&nbsp;</td>
      </tr>
      <tr>
        <td rowspan="2">0x21B8 </td>
        <td>
        <pre class="source">union {
    USHORT BpbState;
    struct {
        USHORT BpbIbrsPresent : 1;
        USHORT BpbStibpPresent : 1;
        USHORT BpbSmepPresent : 1;
        USHORT BpbSimulateSpecCtrl : 1;
        USHORT BpbSimulateIbpb : 1;
        USHORT BpbIbpbPresent : 1;
        USHORT BpbCpuIdle : 1;
        USHORT BpbClearSpecCtrlOnIdle : 1;
        USHORT BpbHTDisabled : 1;
        USHORT BpbUserToUserOnly : 1;
        USHORT BpbReserved : 6;
    };
};</pre>
        </td>
        <td>1803 only </td>
        <td>&nbsp;</td>
      </tr>
      <tr>
        <td>
        <pre class="source">union {
    UCHAR BpbState;
    struct {
        UCHAR BpbCpuIdle : 1;
        UCHAR BpbFlushRsbOnTrap : 1;
        UCHAR BpbIbpbOnReturn : 1;
        UCHAR BpbIbpbOnTrap : 1;
        UCHAR BpbReserved : 4;
    };
};</pre>
        </td>
        <td>1809 and higher </td>
        <td>&nbsp;</td>
      </tr>
      <tr>
        <td>0x21B9 </td>
        <td>
        <pre class="source">union {
    UCHAR BpbFeatures;
    struct {
        UCHAR BpbClearOnIdle : 1;
        UCHAR BpbEnabled : 1;
        UCHAR BpbSmep : 1;
        UCHAR BpbFeaturesReserved : 5;
    };
};</pre>
        </td>
        <td>1809 and higher </td>
        <td>&nbsp;</td>
      </tr>
      <tr>
        <td rowspan="2">0x21BA </td>
        <td>
        <pre class="source">UCHAR BpbSpecCtrlValue;</pre>
        </td>
        <td>1803 only </td>
        <td>&nbsp;</td>
      </tr>
      <tr>
        <td>
        <pre class="source">UCHAR BpbCurrentSpecCtrl;</pre>
        </td>
        <td>1809 and higher </td>
        <td>&nbsp;</td>
      </tr>
      <tr>
        <td rowspan="2">0x21BB </td>
        <td>
        <pre class="source">UCHAR BpbCtxSwapSetValue;</pre>
        </td>
        <td>1803 only </td>
        <td>&nbsp;</td>
      </tr>
      <tr>
        <td>
        <pre class="source">UCHAR BpbKernelSpecCtrl;</pre>
        </td>
        <td>1809 and higher </td>
        <td>&nbsp;</td>
      </tr>
      <tr>
        <td>0x21BC </td>
        <td>
        <pre class="source">UCHAR BpbNmiSpecCtrl;</pre>
        </td>
        <td>1809 and higher </td>
        <td>&nbsp;</td>
      </tr>
      <tr>
        <td>0x21BD </td>
        <td>
        <pre class="source">UCHAR BpbUserSpecCtrl;</pre>
        </td>
        <td>1809 and higher </td>
        <td>&nbsp;</td>
      </tr>
      <tr>
        <td>0x21BE </td>
        <td>
        <pre class="source">UCHAR PrcbPad49 [2];</pre>
        </td>
        <td>1809 and higher </td>
        <td>&nbsp;</td>
      </tr>
      <tr>
        <td>0x21C0 </td>
        <td>
        <pre class="source">ULONG ProcessorSignature;</pre>
        </td>
        <td>1809 and higher </td>
        <td>&nbsp;</td>
      </tr>
      <tr>
        <td>0x21C4 </td>
        <td>
        <pre class="source">ULONG ProcessorFlags;</pre>
        </td>
        <td>1809 and higher </td>
        <td>&nbsp;</td>
      </tr>
      <tr>
        <td rowspan="9">0x02D0 (3.51); <br>
        0x04B0 (4.0); <br>
        0x06B0 (5.0); <br>
        0x0828 (5.1 to early 5.2); <br>
        0x08E8 (late 5.2); <br>
        0x1928 (early 6.0); <br>
        0x19A8 (late 6.0); <br>
        0x18A8 (6.1); <br>
        0x21A8 (6.2 to 1511); <br>
        0x21B0 (1607 to 1709); <br>
        0x21BC (1803); <br>
        0x21C8 </td>
        <td>
        <pre class="source">ULONG CachePad2 [4];</pre>
        </td>
        <td>3.51 to 5.0 </td>
        <td>&nbsp;</td>
      </tr>
      <tr>
        <td>
        <pre class="source">UCHAR PrcbPad4 [0x38];</pre>
        </td>
        <td>5.1 to early 6.0 </td>
        <td>&nbsp;</td>
      </tr>
      <tr>
        <td>
        <pre class="source">UCHAR PrcbPad5 [0x38];</pre>
        </td>
        <td>late 6.0 only </td>
        <td>&nbsp;</td>
      </tr>
      <tr>
        <td>
        <pre class="source">UCHAR PrcbPad50 [0x38];</pre>
        </td>
        <td>6.1 only </td>
        <td>&nbsp;</td>
      </tr>
      <tr>
        <td>
        <pre class="source">UCHAR PrcbPad50 [0x30];</pre>
        </td>
        <td>6.2 only </td>
        <td>&nbsp;</td>
      </tr>
      <tr>
        <td>
        <pre class="source">UCHAR PrcbPad50 [0x28];</pre>
        </td>
        <td>6.3 to 1511 </td>
        <td>&nbsp;</td>
      </tr>
      <tr>
        <td>
        <pre class="source">UCHAR PrcbPad50 [0x20];</pre>
        </td>
        <td>1607 to 1709 </td>
        <td>&nbsp;</td>
      </tr>
      <tr>
        <td>
        <pre class="source">UCHAR PrcbPad50 [0x14];</pre>
        </td>
        <td>1803 only </td>
        <td>&nbsp;</td>
      </tr>
      <tr>
        <td>
        <pre class="source">UCHAR PrcbPad50 [8];</pre>
        </td>
        <td>1809 and higher </td>
        <td>&nbsp;</td>
      </tr>
    </tbody>
  </table>
  <p>Despite being named <span class="member">CachePad2</span> initially, the preceding 
  padding does not actually cache-align what follows in versions 4.0 and 5.0. It 
  doesn’t in version 6.2 and higher, but deliberately. These versions instead squeeze 
  two or four members into the end of the cache line: </p>
  <table class="Struct">
    <colgroup>
      <col class="Offset"><col class="Definition"><col class="Versions">
    </colgroup>
    <thead>
      <tr>
        <th>Offset </th>
        <th>Definition </th>
        <th>Versions </th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td>0x21D8 (6.2); <br>
        0x21D0 </td>
        <td>
        <pre class="source">ULONG InterruptLastCount;</pre>
        </td>
        <td>6.2 and higher </td>
      </tr>
      <tr>
        <td>0x21DC (6.2); <br>
        0x21D4 </td>
        <td>
        <pre class="source">ULONG InterruptRate;</pre>
        </td>
        <td>6.2 and higher </td>
      </tr>
      <tr>
        <td>0x21D8 </td>
        <td>
        <pre class="source">ULONG DeviceInterrupts;</pre>
        </td>
        <td>6.3 and higher </td>
      </tr>
      <tr>
        <td>0x21DC </td>
        <td>
        <pre class="source">PVOID IsrDpcStats;</pre>
        </td>
        <td>6.3 and higher </td>
      </tr>
    </tbody>
  </table>
  <p>What <span class="member">IsrDpcStats</span> points to, when it does hold a 
  pointer, is an <span class="struct"><a href="../../ke_x/isrdpcstats.htm">ISRDPCSTATS</a></span> 
  structure. </p>
  <h4>Deferred Procedure Calls </h4>
  <p>A region of members concerned with DPC management was rearranged so much for 
  version 5.2, with its introduction of Threaded DPCs, that it seems better to separate 
  the layouts. Even before then, there were substantial introductions for version 
  3.51 and then rearrangements for version 5.1. </p>
  <table class="Struct">
    <colgroup>
      <col class="Offset"><col class="Definition"><col class="Versions">
      <col class="Remarks">
    </colgroup>
    <thead>
      <tr>
        <th>Offset </th>
        <th>Definition </th>
        <th>Versions </th>
        <th>Remarks </th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td>0x02E0 (3.51); <br>
        0x04C0 (4.0); <br>
        0x06C0 (5.0) </td>
        <td>
        <pre class="source">ULONG volatile DpcInterruptRequested;</pre>
        </td>
        <td>3.51 to 5.0 </td>
        <td>next at 0x0878 </td>
      </tr>
      <tr>
        <td>0x02E4 (3.51); <br>
        0x04C4 (4.0); <br>
        0x06C4 (5.0) </td>
        <td>
        <pre class="source">PVOID ChainedInterruptList;</pre>
        </td>
        <td>5.0 only </td>
        <td>&nbsp;</td>
      </tr>
      <tr>
        <td rowspan="2">0x02E4 (3.51); <br>
        0x04C4 (4.0); <br>
        0x06C8 (5.0) </td>
        <td>
        <pre class="source">ULONG CachePad3 [3];</pre>
        </td>
        <td>3.51 to 4.0 </td>
        <td>&nbsp;</td>
      </tr>
      <tr>
        <td>
        <pre class="source">ULONG CachePad3 [2];</pre>
        </td>
        <td>5.0 only </td>
        <td>&nbsp;</td>
      </tr>
      <tr>
        <td>0x02F0 (3.51); <br>
        0x04D0 (4.0); <br>
        0x06D0 (5.0) </td>
        <td>
        <pre class="source">ULONG MaximumDpcQueueDepth;</pre>
        </td>
        <td>3.51 to 5.0 </td>
        <td>next at 0x0884 </td>
      </tr>
      <tr>
        <td>0x02F4 (3.51); <br>
        0x04D4 (4.0); <br>
        0x06D4 (5.0) </td>
        <td>
        <pre class="source">ULONG MinimumDpcRate;</pre>
        </td>
        <td>3.51 to 5.0 </td>
        <td>next at 0x0888 </td>
      </tr>
      <tr>
        <td>0x02F8 (3.51); <br>
        0x04D8 (4.0); <br>
        0x06D8 (5.0) </td>
        <td>
        <pre class="source">ULONG CachePad4 [2];</pre>
        </td>
        <td>3.51 to 5.0 </td>
        <td>&nbsp;</td>
      </tr>
    </tbody>
  </table>
  <p>There is some suggestion that the members from <span class="member">DpcListHead</span> 
  to <span class="member">DpcLock</span>, below, were once modelled as a sub-structure. 
  For instance, code for <span class="function">KiDispatchInterrupt</span> in version 
  3.50 accesses the lock as an offset from the list head, and this seems unlikely 
  to be just an optimisation by the contemporaneous compiler. The space between 
  these members is here thought to have been the original <span class="member">KernelReserved2</span>, 
  as if planned for development as the DPC functionality got more sophisticated.
  </p>
  <table class="Struct">
    <colgroup>
      <col class="Offset"><col class="Definition"><col class="Versions">
      <col class="Remarks">
    </colgroup>
    <thead>
      <tr>
        <th>Offset </th>
        <th>Definition </th>
        <th>Versions </th>
        <th>Remarks </th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td>0x02E8 (3.50); <br>
        0x0300 (3.51); <br>
        0x04E0 (4.0); <br>
        0x06E0 (5.0); <br>
        0x0860 (5.1) </td>
        <td>
        <pre class="source">LIST_ENTRY DpcListHead;</pre>
        </td>
        <td>3.50 to 5.1 </td>
        <td>&nbsp;</td>
      </tr>
      <tr>
        <td>0x0868 (5.1) </td>
        <td>
        <pre class="source">PVOID DpcStack;</pre>
        </td>
        <td>5.1 only </td>
        <td>previously at 0x06FC; <br>
        next at 0x0888 </td>
      </tr>
      <tr>
        <td>0x086C (5.1) </td>
        <td>
        <pre class="source">ULONG DpcCount;</pre>
        </td>
        <td>5.1 only </td>
        <td>previously at 0x06F0 </td>
      </tr>
      <tr>
        <td rowspan="2">0x02F0 (3.50); <br>
        0x0308 (3.51); <br>
        0x04E8 (4.0); <br>
        0x06E8 (5.0); <br>
        0x0870 (5.1) </td>
        <td>
        <pre class="source">ULONG DpcQueueDepth;</pre>
        </td>
        <td>3.50 to 5.0 </td>
        <td>&nbsp;</td>
      </tr>
      <tr>
        <td>
        <pre class="source">ULONG volatile DpcQueueDepth;</pre>
        </td>
        <td>5.1 only </td>
        <td>&nbsp;</td>
      </tr>
      <tr>
        <td rowspan="2"><br>
        0x030C (3.51); <br>
        0x04EC (4.0); <br>
        0x06EC (5.0); <br>
        0x0874 (5.1) </td>
        <td>
        <pre class="source">ULONG DpcRoutineActive;</pre>
        </td>
        <td>3.51 to 5.0 </td>
        <td>previously <span class="type">BOOLEAN</span> at 0xD8 in
        <span class="struct">KPCR</span> </td>
      </tr>
      <tr>
        <td>
        <pre class="source">ULONG volatile DpcRoutineActive;</pre>
        </td>
        <td>5.1 only </td>
        <td>next as <span class="type">BOOLEAN volatile</span> at 0x089A </td>
      </tr>
      <tr>
        <td>0x0878 (5.1) </td>
        <td>
        <pre class="source">ULONG volatile DpcInterruptRequested;</pre>
        </td>
        <td>5.1 only </td>
        <td>previously at 0x06C0; <br>
        next at <span class="type">BOOLEAN volatile</span> at 0x0898 </td>
      </tr>
      <tr>
        <td>0x0310 (3.51); <br>
        0x04F0 (4.0); <br>
        0x06F0 (5.0) </td>
        <td>
        <pre class="source">ULONG DpcCount;</pre>
        </td>
        <td>3.51 to 5.0 </td>
        <td>next at 0x086C </td>
      </tr>
      <tr>
        <td>0x0314 (3.51); <br>
        0x04F4 (4.0); <br>
        0x06F4 (5.0); <br>
        0x087C (5.1) </td>
        <td>
        <pre class="source">ULONG DpcLastCount;</pre>
        </td>
        <td>3.51 to 5.1 </td>
        <td>next at 0x08A0 </td>
      </tr>
      <tr>
        <td>0x0318 (3.51); <br>
        0x04F8 (4.0); <br>
        0x06F8 (5.0); <br>
        0x0880 (5.1) </td>
        <td>
        <pre class="source">ULONG DpcRequestRate;</pre>
        </td>
        <td>3.51 to 5.1 </td>
        <td>next at 0x0890 </td>
      </tr>
      <tr>
        <td>0x0884 (5.1) </td>
        <td>
        <pre class="source">ULONG MaximumDpcQueueDepth;</pre>
        </td>
        <td>5.1 only </td>
        <td>previously at 0x06D0; <br>
        next at 0x088C </td>
      </tr>
      <tr>
        <td>0x0888 (5.1) </td>
        <td>
        <pre class="source">ULONG MinimumDpcRate;</pre>
        </td>
        <td>5.1 only </td>
        <td>previously at 0x06D4; <br>
        next at 0x0894 </td>
      </tr>
      <tr>
        <td>0x06FC (5.0) </td>
        <td>
        <pre class="source">PVOID DpcStack;</pre>
        </td>
        <td>5.0 only </td>
        <td>next at 0x0868 </td>
      </tr>
      <tr>
        <td>0x088C (5.1) </td>
        <td>
        <pre class="source">ULONG QuantumEnd;</pre>
        </td>
        <td>5.1 only </td>
        <td>previously at 0x0750; <br>
        next as <span class="type">BOOLEAN volatile</span> at 0x08C1 </td>
      </tr>
      <tr>
        <td rowspan="4">0x02F4 (3.50); <br>
        0x031C (3.51); <br>
        0x04FC (4.0); <br>
        0x0700 (5.0); <br>
        0x0890 (5.1) </td>
        <td>
        <pre class="source">ULONG KernelReserved2 [0x0F];</pre>
        </td>
        <td>3.50 only </td>
        <td>&nbsp;</td>
      </tr>
      <tr>
        <td>
        <pre class="source">ULONG KernelReserved2 [0x0B];</pre>
        </td>
        <td>3.51 to 4.0 </td>
        <td>&nbsp;</td>
      </tr>
      <tr>
        <td>
        <pre class="source">ULONG KernelReserved2 [0x0A];</pre>
        </td>
        <td>5.0 only </td>
        <td>&nbsp;</td>
      </tr>
      <tr>
        <td>
        <pre class="source">UCHAR PrcbPad5 [0x10];</pre>
        </td>
        <td>5.1 only </td>
        <td>&nbsp;</td>
      </tr>
      <tr>
        <td>0x0330 (3.50); <br>
        0x0348 (3.51); <br>
        0x0528 (4.0); <br>
        0x0728 (5.0); <br>
        0x08A0 (5.1) </td>
        <td>
        <pre class="source">KSPIN_LOCK DpcLock;</pre>
        </td>
        <td>3.50 to 5.1 </td>
        <td>&nbsp;</td>
      </tr>
      <tr>
        <td rowspan="2">0x08A4 (5.1) </td>
        <td>
        <pre class="source">UCHAR PrcbPad6 [0x3C];</pre>
        </td>
        <td>early 5.1 only </td>
        <td>&nbsp;</td>
      </tr>
      <tr>
        <td>
        <pre class="source">UCHAR PrcbPad6 [0x1C];</pre>
        </td>
        <td>late 5.1 only </td>
        <td>&nbsp;</td>
      </tr>
    </tbody>
  </table>
  <p>When <span class="member">DpcRoutineActive</span> was moved here from the
  <span class="struct">KPCR</span> it didn’t become a <span class="member">ULONG</span> 
  just to formalise that the kernel sometimes accessed it as 32-bit boolean. The 
  implementation changed such that <span class="member">DpcRoutineActive</span> 
  holds a pointer into the stack of the kernel routine that holds the
  <span class="member">DpcLock</span> and is retiring the DPCs that it removes ffrom 
  the <span class="member">DpcListHead</span>. That the exported function
  <span class="function">KeIsExecutingDpc</span> continued to return all 32 bits 
  may mean it was never intended to return a <span class="type">BOOLEAN</span> specifically. 
  There’s no documention even now or a contemporaneous declaration to go by. Yet 
  when <span class="function">DpcRoutineActive</span> was reimplemented as a
  <span class="type">BOOLEAN</span> for version 5.2, the code was changed to return 
  a zero-extended byte. </p>
  <h4>DPC Management in Windows Server 2003 and Higher </h4>
  <p>Version 5.2 introduced Threaded DPCs. These reproduce some of the control data 
  that support normal DPCs, and thus <span class="member">DpcListHead</span>,
  <span class="member">DpcLock</span>, <span class="member">DpcQueueDepth</span> 
  and <span class="member">DpcCount</span> were gathered into a structure. Each 
  processor has two of these <span class="struct">
  <a href="../../../../api/ke/dpcobj/kdpc_data.htm">KDPC_DATA</a></span> structures: 
  the first for normal DPCs; the second for Threaded DPCs. </p>
  <table class="Struct">
    <colgroup>
      <col class="Offset"><col class="Definition"><col class="Versions">
      <col class="Remarks">
    </colgroup>
    <thead>
      <tr>
        <th>Offset </th>
        <th>Definition </th>
        <th>Versions </th>
        <th>Remarks </th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td>0x0860 (early 5.2); <br>
        0x0920 (late 5.2); <br>
        0x1960 (early 6.0); <br>
        0x19E0 (late 6.0); <br>
        0x18E0 (6.1); <br>
        0x21E0 </td>
        <td>
        <pre class="source">KDPC_DATA DpcData [2];</pre>
        </td>
        <td>5.2 and higher </td>
        <td>cache-aligned </td>
      </tr>
      <tr>
        <td>0x0888 (early 5.2); <br>
        0x0948 (late 5.2); <br>
        0x1988 (early 6.0); <br>
        0x1A08 (late 6.0); <br>
        0x1908 (6.1); <br>
        0x2208 (6.2); <br>
        0x2210 </td>
        <td>
        <pre class="source">PVOID DpcStack;</pre>
        </td>
        <td>5.2 and higher </td>
        <td>previously at 0x0868 </td>
      </tr>
      <tr>
        <td rowspan="2">0x088C (early 5.2); <br>
        0x094C (late 5.2); <br>
        0x198C (early 6.0); <br>
        0x1A0C (late 6.0); <br>
        0x190C (6.1); <br>
        0x220C (6.2); <br>
        0x2214 </td>
        <td>
        <pre class="source">ULONG MaximumDpcQueueDepth;</pre>
        </td>
        <td>5.2 only </td>
        <td>previously at 0x0884 </td>
      </tr>
      <tr>
        <td>
        <pre class="source">LONG MaximumDpcQueueDepth;</pre>
        </td>
        <td>6.0 and higher </td>
        <td>&nbsp;</td>
      </tr>
      <tr>
        <td>0x0890 (early 5.2); <br>
        0x0950 (late 5.2); <br>
        0x1990 (early 6.0); <br>
        0x1A10 (late 6.0); <br>
        0x1910 (6.1); <br>
        0x2210 (6.2); <br>
        0x2218 </td>
        <td>
        <pre class="source">ULONG DpcRequestRate;</pre>
        </td>
        <td>5.2 and higher </td>
        <td>previously at 0x0880 </td>
      </tr>
      <tr>
        <td>0x0894 (early 5.2); <br>
        0x0954 (late 5.2); <br>
        0x1994 (early 6.0); <br>
        0x1A14 (late 6.0); <br>
        0x1914 (6.1); <br>
        0x2214 (6.2); <br>
        0x221C </td>
        <td>
        <pre class="source">ULONG MinimumDpcRate;</pre>
        </td>
        <td>5.2 and higher </td>
        <td>previously at 0x0888 </td>
      </tr>
      <tr>
        <td>0x0898 (early 5.2); <br>
        0x0958 (late 5.2); <br>
        0x1998 (early 6.0); <br>
        0x1A18 (late 6.0) <br>
        </td>
        <td>
        <pre class="source">BOOLEAN volatile DpcInterruptRequested;</pre>
        </td>
        <td>5.2 to 6.0 </td>
        <td>previously <span class="type">ULONG volatile</span> at 0x0878 </td>
      </tr>
      <tr>
        <td>0x0899 (early 5.2); <br>
        0x0959 (late 5.2); <br>
        0x1999 (early 6.0); <br>
        0x1A19 (late 6.0) </td>
        <td>
        <pre class="source">BOOLEAN volatile DpcThreadRequested;</pre>
        </td>
        <td>5.2 to 6.0 </td>
        <td>&nbsp;</td>
      </tr>
      <tr>
        <td>0x089A (early 5.2); <br>
        0x095A (late 5.2); <br>
        0x199A (early 6.0); <br>
        0x1A1A (late 6.0) </td>
        <td>
        <pre class="source">BOOLEAN volatile DpcRoutineActive;</pre>
        </td>
        <td>5.2 to 6.0 </td>
        <td>previously <span class="type">ULONG volatile</span> at 0x0874; <br>
        next at 0x1932 </td>
      </tr>
      <tr>
        <td>0x089B (early 5.2); <br>
        0x095B (late 5.2); <br>
        0x199B (early 6.0); <br>
        0x1A1B (late 6.0) </td>
        <td>
        <pre class="source">BOOLEAN volatile DpcThreadActive;</pre>
        </td>
        <td>5.2 to 6.0 </td>
        <td>next as bit at 0x1934 </td>
      </tr>
    </tbody>
  </table>
  <p>The <span class="member">DpcInterruptRequested</span> member is notable for 
  some confusion in Windows Vista SP1. This build added one instruction at very 
  nearly the start of the <span class="function">KiDispatchInterrupt</span> function 
  just to clear this member. This function addresses <span class="struct">KPRCB</span> 
  members via a pointer to the current processor’s <span class="struct">KPCR</span>, 
  relying on the <span class="struct">KPRCB</span> to be embedded in the
  <span class="struct">KPCR</span> as the <span class="member">PrcbData</span> member 
  (at offset 0x0120). For Windows Vista SP1, however, the function addresses
  <span class="member">DpcInterruptRequested</span> relative to the
  <span class="struct">KPRCB</span> not the <span class="struct">KPCR</span>. Instead 
  of clearing the intended byte, it clears a byte 0x0120 bytes lower in memory. 
  Put aside any ill effect from not clearing the intended byte. Look instead at 
  what byte gets cleared by mistake. Fortunately, this byte is in the
  <span class="member">Tag</span> in the <span class="member">PPPagedLookasideList</span> 
  for paged pool allocations of 0x0100 bytes. This means the corruption is harmless 
  but it also gives the curiosity of being observable from user mode (in the output 
  from the <span class="constant">SystemLookasideInformation</span> case of
  <span class="function">NtQuerySystemInformation</span>). The error in addressing 
  was corrected as early as Windows Vista SP2 and it was soon made irrelevant by 
  a reworking of DPC management for Windows 7. </p>
  <p>As noted earlier, version 5.2 made <span class="function">DpcRoutineActive</span> 
  into a <span class="type">BOOLEAN</span> and recoded the undocumented
  <span class="function">KeIsExecutingDpc</span> function to return just the zero-extended
  <span class="type">BOOLEAN</span>. Version 6.0 computes its answer as
  <span class="constant">TRUE</span> or <span class="constant">FALSE</span> not 
  from <span class="member">DpcRoutineActive</span> alone but from it and
  <span class="member">DpcThreadActive</span> taken together as one 16-bit word. 
  Its answer for whether its caller is in turn called from someone’s handling of 
  a DPC is therefore yes if either byte is non-zero. </p>
  <table class="Struct">
    <colgroup>
      <col class="Offset"><col class="Definition"><col class="Versions">
      <col class="Remarks">
    </colgroup>
    <thead>
      <tr>
        <th>Offset </th>
        <th>Definition </th>
        <th>Versions </th>
        <th>Remarks </th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td>0x089C (early 5.2); <br>
        0x095C (late 5.2); <br>
        0x199C (early 6.0); <br>
        0x1A1C (late 6.0) </td>
        <td>
        <pre class="source">ULONG PrcbLock;</pre>
        </td>
        <td>5.2 to 6.0 </td>
        <td>next at 0x191C </td>
      </tr>
      <tr>
        <td>0x08A0 (early 5.2); <br>
        0x0960 (late 5.2); <br>
        0x19A0 (early 6.0); <br>
        0x1A20 (late 6.0); <br>
        0x1918 (6.1); <br>
        0x2218 (6.2); <br>
        0x2220 </td>
        <td>
        <pre class="source">ULONG DpcLastCount;</pre>
        </td>
        <td>5.2 and higher </td>
        <td>previously at 0x087C </td>
      </tr>
      <tr>
        <td>0x191C (6.1); <br>
        0x221C (6.2); <br>
        0x2224 </td>
        <td>
        <pre class="source">ULONG PrcbLock;</pre>
        </td>
        <td>6.1 and higher </td>
        <td>previously at 0x1A1C </td>
      </tr>
      <tr>
        <td>0x1920 (6.1); <br>
        0x2220 (6.2); <br>
        0x2228 </td>
        <td>
        <pre class="source">KGATE DpcGate;</pre>
        </td>
        <td>6.1 and higher </td>
        <td>&nbsp;</td>
      </tr>
      <tr>
        <td>0x08A4 (early 5.2); <br>
        0x0964 (late 5.2); <br>
        0x19A4 (early 6.0); <br>
        0x1A24 (late 6.0) </td>
        <td>
        <pre class="source">ULONG volatile TimerHand;</pre>
        </td>
        <td>5.2 to 6.0 </td>
        <td>next at 0x1938 (6.1) </td>
      </tr>
      <tr>
        <td>0x08A8 (early 5.2); <br>
        0x0968 (late 5.2); <br>
        0x19A8 (early 6.0); <br>
        0x1A28 (late 6.0) </td>
        <td>
        <pre class="source">ULONG volatile TimerRequest;</pre>
        </td>
        <td>5.2 to 6.0 </td>
        <td>&nbsp;</td>
      </tr>
      <tr>
        <td>0x19AC (early 6.0); <br>
        0x1A2C (late 6.0) </td>
        <td>
        <pre class="source">PVOID PrcbPad41;</pre>
        </td>
        <td>6.0 only </td>
        <td>&nbsp;</td>
      </tr>
      <tr>
        <td>0x08AC (early 5.2); <br>
        0x096C (late 5.2); <br>
        </td>
        <td>
        <pre class="source">PVOID DpcThread;</pre>
        </td>
        <td>5.2 only </td>
        <td>&nbsp;</td>
      </tr>
      <tr>
        <td>0x08B0 (early 5.2); <br>
        0x0970 (late 5.2); <br>
        0x19B0 (early 6.0); <br>
        0x1A30 (late 6.0) </td>
        <td>
        <pre class="source">KEVENT DpcEvent;</pre>
        </td>
        <td>5.2 to 6.0 </td>
        <td>&nbsp;</td>
      </tr>
      <tr>
        <td>0x08C0 (early 5.2); <br>
        0x0980 (late 5.2); <br>
        0x19C0 (early 6.0); <br>
        0x1A40 (late 6.0); <br>
        0x1930 (6.1); <br>
        0x2230 (6.2); <br>
        0x2238 (6.3) </td>
        <td>
        <pre class="source">BOOLEAN ThreadDpcEnable;</pre>
        </td>
        <td>5.2 to 6.3 </td>
        <td>next at 0x2259 </td>
      </tr>
      <tr>
        <td>0x2238 </td>
        <td>
        <pre class="source">UCHAR IdleState;</pre>
        </td>
        <td>10.0 and higher </td>
        <td>&nbsp;</td>
      </tr>
      <tr>
        <td>0x08C1 (early 5.2); <br>
        0x0981 (late 5.2); <br>
        0x19C1 (early 6.0); <br>
        0x1A41 (late 6.0); <br>
        0x1931 (6.1); <br>
        0x2231 (6.2); <br>
        0x2239 </td>
        <td>
        <pre class="source">BOOLEAN volatile QuantumEnd;</pre>
        </td>
        <td>5.2 and higher </td>
        <td>previously <span class="type">ULONG</span> at 0x088C </td>
      </tr>
      <tr>
        <td>0x08C2 (early 5.2); <br>
        0x0982 (late 5.2); <br>
        0x19C2 (early 6.0); <br>
        0x1A42 (late 6.0) <br>
        </td>
        <td>
        <pre class="source">UCHAR PrcbPad50;</pre>
        </td>
        <td>5.2 to 6.0 </td>
        <td>&nbsp;</td>
      </tr>
      <tr>
        <td>0x1932 (6.1); <br>
        0x2232 (6.2); <br>
        0x223A </td>
        <td>
        <pre class="source">BOOLEAN volatile DpcRoutineActive;</pre>
        </td>
        <td>6.1 and higher </td>
        <td>previously at 0x1A1A </td>
      </tr>
      <tr>
        <td>0x08C3 (early 5.2); <br>
        0x0983 (late 5.2); <br>
        0x19C3 (early 6.0); <br>
        0x1A43 (late 6.0); <br>
        0x1933 (6.1); <br>
        0x2233 (6.2); <br>
        0x223B </td>
        <td>
        <pre class="source">BOOLEAN volatile IdleSchedule;</pre>
        </td>
        <td>5.2 and higher </td>
        <td>&nbsp;</td>
      </tr>
      <tr>
        <td rowspan="2">0x08C4 (early 5.2); <br>
        0x0984 (late 5.2); <br>
        0x19C4 (early 6.0); <br>
        0x1A44 (late 6.0); <br>
        0x1934 (6.1); <br>
        0x2234 (6.2); <br>
        0x223C </td>
        <td>
        <pre class="source">LONG DpcSetEventRequest;</pre>
        </td>
        <td>5.2 to 6.0 </td>
        <td>&nbsp;</td>
      </tr>
      <tr>
        <td>
        <pre class="source">union {
    LONG volatile <a href="dpcrequestsummary.htm">DpcRequestSummary</a>;
    SHORT DpcRequestSlot [2];
    /*  changing members, follow link  */
};</pre>
        </td>
        <td>6.1 and higher </td>
        <td>&nbsp;</td>
      </tr>
    </tbody>
  </table>
  <h4>Timing </h4>
  <table class="Struct">
    <colgroup>
      <col class="Offset"><col class="Definition"><col class="Versions">
      <col class="Remarks">
    </colgroup>
    <thead>
      <tr>
        <th>Offset </th>
        <th>Definition </th>
        <th>Versions </th>
        <th>Remarks </th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td rowspan="3">0x19C8 (early 6.0); <br>
        0x1A48 (late 6.0); <br>
        0x1938 (6.1); <br>
        0x2238 (6.2); <br>
        0x2240 (6.3 to 1903) </td>
        <td>
        <pre class="source">LONG Sleeping;</pre>
        </td>
        <td>6.0 only </td>
        <td>previously at 0x055C </td>
      </tr>
      <tr>
        <td>
        <pre class="source">ULONG volatile TimerHand;</pre>
        </td>
        <td>6.1 only </td>
        <td>previously at 0x1A24 </td>
      </tr>
      <tr>
        <td>
        <pre class="source">ULONG LastTimerHand;</pre>
        </td>
        <td>6.2 to 1903 </td>
        <td>&nbsp;</td>
      </tr>
      <tr>
        <td>0x193C (6.1); <br>
        0x223C (6.2); <br>
        0x2244 (6.3 to 1903); <br>
        0x2240 </td>
        <td>
        <pre class="source">ULONG LastTick;</pre>
        </td>
        <td>6.1 and higher </td>
        <td>&nbsp;</td>
      </tr>
      <tr>
        <td>0x1940 </td>
        <td>
        <pre class="source">LONG MasterOffset;</pre>
        </td>
        <td>6.1 only </td>
        <td>&nbsp;</td>
      </tr>
      <tr>
        <td>0x1944 </td>
        <td>
        <pre class="source">ULONG PrcbPad41 [2];</pre>
        </td>
        <td>6.1 only </td>
        <td>&nbsp;</td>
      </tr>
      <tr>
        <td>0x19CC (early 6.0); <br>
        0x1A4C (late 6.0); <br>
        0x194C (6.1); <br>
        0x2240 (6.2); <br>
        0x2248 (6.3 to 1903); <br>
        0x2244 </td>
        <td>
        <pre class="source">ULONG PeriodicCount;</pre>
        </td>
        <td>6.0 and higher </td>
        <td>&nbsp;</td>
      </tr>
      <tr>
        <td>0x19D0 (early 6.0); <br>
        0x1A50 (late 6.0); <br>
        0x1950 (6.1); <br>
        0x2244 (6.2); <br>
        0x224C (6.3 to 1903); <br>
        0x2248 </td>
        <td>
        <pre class="source">ULONG PeriodicBias;</pre>
        </td>
        <td>6.0 and higher </td>
        <td>&nbsp;</td>
      </tr>
      <tr>
        <td rowspan="4">0x08C8 (early 5.2); <br>
        0x0988 (late 5.2); <br>
        0x19D4 (early 6.0); <br>
        0x1A54 (late 6.0); <br>
        0x1954 (6.1) </td>
        <td>
        <pre class="source">UCHAR PrcbPad5 [0x16];</pre>
        </td>
        <td>early 5.2 only </td>
        <td>&nbsp;</td>
      </tr>
      <tr>
        <td>
        <pre class="source">UCHAR PrcbPad5 [0x12];</pre>
        </td>
        <td>late 5.2 only </td>
        <td>&nbsp;</td>
      </tr>
      <tr>
        <td>
        <pre class="source">UCHAR PrcbPad5 [6];</pre>
        </td>
        <td>early 6.0 only </td>
        <td>&nbsp;</td>
      </tr>
      <tr>
        <td>
        <pre class="source">UCHAR PrcbPad51 [6];</pre>
        </td>
        <td>late 6.0 to 6.1 </td>
        <td>&nbsp;</td>
      </tr>
      <tr>
        <td rowspan="3">0x099C (late 5.2); <br>
        0x19DC (early 6.0); <br>
        0x1A5C (late 6.0); <br>
        0x1958 (6.1); <br>
        0x2248 (6.2); <br>
        0x2250 (6.3 to 1903); <br>
        0x224C </td>
        <td>
        <pre class="source">LONG TickOffset;</pre>
        </td>
        <td>late 5.2 to 6.0 </td>
        <td>&nbsp;</td>
      </tr>
      <tr>
        <td>
        <pre class="source">ULONGLONG TickOffset;</pre>
        </td>
        <td>6.1 only </td>
        <td>&nbsp;</td>
      </tr>
      <tr>
        <td>
        <pre class="source">ULONG ClockInterrupts;</pre>
        </td>
        <td>6.2 and higher </td>
        <td>&nbsp;</td>
      </tr>
      <tr>
        <td>0x224C (6.2); <br>
        0x2254 (6.3 to 1903); <br>
        0x2250 </td>
        <td>
        <pre class="source">ULONG ReadyScanTick;</pre>
        </td>
        <td>6.2 and higher </td>
        <td>&nbsp;</td>
      </tr>
      <tr>
        <td>0x2250 (6.2) </td>
        <td>
        <pre class="source">UCHAR BalanceState;</pre>
        </td>
        <td>6.2 only </td>
        <td>&nbsp;</td>
      </tr>
      <tr>
        <td>0x2251 (6.2); <br>
        0x2258 (6.3 to 1903); <br>
        0x2254 </td>
        <td>
        <pre class="source">BOOLEAN GroupSchedulingOverQuota;</pre>
        </td>
        <td>6.2 and higher </td>
        <td>&nbsp;</td>
      </tr>
      <tr>
        <td>0x2259 (10.0 to 1903); <br>
        0x2255 </td>
        <td>
        <pre class="source">UCHAR ThreadDpcEnable;</pre>
        </td>
        <td>10.0 and higher </td>
        <td>previously at 0x2238 </td>
      </tr>
      <tr>
        <td rowspan="4">0x2252 (6.2); <br>
        0x2259 (6.3); <br>
        0x225A (10.0 to 1903); <br>
        0x2256 </td>
        <td>
        <pre class="source">UCHAR PrcbPad41 [10];</pre>
        </td>
        <td>6.2 only </td>
        <td>&nbsp;</td>
      </tr>
      <tr>
        <td>
        <pre class="source">UCHAR PrcbPad41 [3];</pre>
        </td>
        <td>6.3 only </td>
        <td>&nbsp;</td>
      </tr>
      <tr>
        <td>
        <pre class="source">UCHAR PrcbPad41 [2];</pre>
        </td>
        <td>10.0 to 1903 </td>
        <td>&nbsp;</td>
      </tr>
      <tr>
        <td>
        <pre class="source">UCHAR PrcbPad41 [6];</pre>
        </td>
        <td>2004 and higher </td>
        <td>&nbsp;</td>
      </tr>
    </tbody>
  </table>
  <p><span class="alert">TO BE DONE</span> </p>
  <table class="Struct">
    <colgroup>
      <col class="Offset"><col class="Definition"><col class="Versions">
    </colgroup>
    <thead>
      <tr>
        <th>Offset </th>
        <th>Definition </th>
        <th>Versions </th>
        <th>Remarks </th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td>0x1960 (6.1); <br>
        0x2260 </td>
        <td>
        <pre class="source">KTIMER_TABLE TimerTable;</pre>
        </td>
        <td>6.1 and higher </td>
        <td>cache-aligned </td>
      </tr>
      <tr>
        <td>0x3AB0 </td>
        <td>
        <pre class="source">ULONG PrcbPad92 [12];</pre>
        </td>
        <td>2004 and higher </td>
        <td>&nbsp;</td>
      </tr>
      <tr>
        <td>0x08C0 (late 5.1); <br>
        0x08E0 (early 5.2); <br>
        0x09A0 (late 5.2); <br>
        0x19E0 (early 6.0); <br>
        0x1A60 (late 6.0); <br>
        0x31A0 (6.1); <br>
        0x3AA0 (6.2 to 1903); <br>
        0x3AE0 </td>
        <td>
        <pre class="source"><a href="../../ntosdef_x/kdpc.htm">KDPC</a> CallDpc;</pre>
        </td>
        <td>late 5.1 and higher </td>
        <td>cache-aligned </td>
      </tr>
      <tr>
        <td>0x1A00 (early 6.0); <br>
        0x1A80 (late 6.0); <br>
        0x31C0 (6.1); <br>
        0x3AC0 (6.2 to 1903); <br>
        0x3B00 </td>
        <td>
        <pre class="source">LONG ClockKeepAlive;</pre>
        </td>
        <td>6.0 and higher </td>
        <td>&nbsp;</td>
      </tr>
      <tr>
        <td>0x1A04 (early 6.0); <br>
        0x1A84 (late 6.0); <br>
        0x31C4 (6.1) </td>
        <td>
        <pre class="source">UCHAR ClockCheckSlot;</pre>
        </td>
        <td>6.0 to 6.1 </td>
        <td>&nbsp;</td>
      </tr>
      <tr>
        <td>0x1A05 (early 6.0); <br>
        0x1A85 (late 6.0); <br>
        0x31C5 (6.1) </td>
        <td>
        <pre class="source">UCHAR ClockPollCycle;</pre>
        </td>
        <td>6.0 to 6.1 </td>
        <td>&nbsp;</td>
      </tr>
      <tr>
        <td rowspan="2">0x1A06 (early 6.0); <br>
        0x1A86 (late 6.0); <br>
        0x31C6 (6.1); <br>
        0x3AC4 (6.2 to 1903); <br>
        0x3B04 </td>
        <td>
        <pre class="source">UCHAR PrcbPad6 [2];</pre>
        </td>
        <td>6.0 to 6.1 </td>
        <td>&nbsp;</td>
      </tr>
      <tr>
        <td>
        <pre class="source">UCHAR PrcbPad6 [4];</pre>
        </td>
        <td>6.2 and higher </td>
        <td>&nbsp;</td>
      </tr>
      <tr>
        <td>0x1A08 (early 6.0); <br>
        0x1A88 (late 6.0); <br>
        0x31C8 (6.1); <br>
        0x3AC8 (6.2 to 1903); <br>
        0x3B08 </td>
        <td>
        <pre class="source">LONG DpcWatchdogPeriod;</pre>
        </td>
        <td>6.0 and higher </td>
        <td>&nbsp;</td>
      </tr>
      <tr>
        <td>0x1A0C (early 6.0); <br>
        0x1A8C (late 6.0); <br>
        0x31CC (6.1); <br>
        0x3ACC (6.2 to 1903); <br>
        0x3B0C </td>
        <td>
        <pre class="source">LONG DpcWatchdogCount;</pre>
        </td>
        <td>6.0 and higher </td>
        <td>&nbsp;</td>
      </tr>
      <tr>
        <td>0x1A10 (early 6.0); <br>
        0x1A90 (late 6.0); <br>
        0x31D0 (6.1) </td>
        <td>
        <pre class="source">LONG ThreadWatchdogPeriod;</pre>
        </td>
        <td>6.0 to 6.1 </td>
        <td>&nbsp;</td>
      </tr>
      <tr>
        <td>0x1A14 (early 6.0); <br>
        0x1A94 (late 6.0); <br>
        0x31D4 (6.1) </td>
        <td>
        <pre class="source">LONG ThreadWatchdogCount;</pre>
        </td>
        <td>6.0 to 6.1 </td>
        <td>&nbsp;</td>
      </tr>
      <tr>
        <td>0x31D8 (6.1); <br>
        0x3AD0 (6.2 to 1903); <br>
        0x3B10 </td>
        <td>
        <pre class="source">LONG volatile KeSpinLockOrdering;</pre>
        </td>
        <td>6.1 and higher </td>
        <td>&nbsp;</td>
      </tr>
      <tr>
        <td>0x3AD4 (1703 to 1903); <br>
        0x3B14 </td>
        <td>
        <pre class="source">ULONG DpcWatchdogProfileCumulativeDpcThreshold;</pre>
        </td>
        <td>1703 and higher </td>
        <td>&nbsp;</td>
      </tr>
      <tr>
        <td rowspan="3">0x0900 (early 5.2); <br>
        0x09C0 (late 5.2); <br>
        0x1A18 (early 6.0); <br>
        0x1A98 (late 6.0); <br>
        0x31DC (6.1); <br>
        0x3AD4 (6.1 to 1607) </td>
        <td>
        <pre class="source">ULONG PrcbPad7 [8];</pre>
        </td>
        <td>5.2 only </td>
        <td>&nbsp;</td>
      </tr>
      <tr>
        <td>
        <pre class="source">ULONG PrcbPad70 [2];</pre>
        </td>
        <td>6.0 only </td>
        <td>&nbsp;</td>
      </tr>
      <tr>
        <td>
        <pre class="source">ULONG PrcbPad70 [1];</pre>
        </td>
        <td>6.1 to 1607 </td>
        <td>&nbsp;</td>
      </tr>
    </tbody>
  </table>
  <p><span class="alert">TO BE DONE</span> </p>
  <table class="Struct">
    <colgroup>
      <col class="Offset"><col class="definition"><col class="Versions">
      <col class="Remarks">
    </colgroup>
    <thead>
      <tr>
        <th>Offset </th>
        <th>Definition </th>
        <th>Versions </th>
        <th>Remarks </th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td>0x3AD8 (6.2 to 1903); <br>
        0x3B18 </td>
        <td>
        <pre class="source">ULONG QueueIndex;</pre>
        </td>
        <td>6.2 and higher </td>
        <td>previously at 0x31F0 </td>
      </tr>
      <tr>
        <td>0x3ADC (6.2 to 1903); <br>
        0x3B1C </td>
        <td>
        <pre class="source">SINGLE_LIST_ENTRY DeferredReadyListHead;</pre>
        </td>
        <td>6.2 and higher </td>
        <td>previously at 0x31F4 </td>
      </tr>
      <tr>
        <td>0x0920 (early 5.2); <br>
        0x09E0 (late 5.2); <br>
        0x1A20 (early 6.0); <br>
        0x1AA0 (late 6.0); <br>
        0x31E0 (6.1); <br>
        0x3AE0 (6.2) </td>
        <td>
        <pre class="source">LIST_ENTRY WaitListHead;</pre>
        </td>
        <td>5.2 to 6.2 </td>
        <td>cache-aligned; <br>
        next at 0x3AEC </td>
      </tr>
      <tr>
        <td>0x3AE0 (6.3 to 1903); <br>
        0x3B20 </td>
        <td>
        <pre class="source">ULONG ReadySummary;</pre>
        </td>
        <td>6.3 and higher </td>
        <td>previously at 3AEC </td>
      </tr>
      <tr>
        <td>0x3AE4 (6.3 to 1903); <br>
        0x3B24 </td>
        <td>
        <pre class="source">LONG AffinitizedSelectionMask;</pre>
        </td>
        <td>6.3 and higher </td>
        <td>&nbsp;</td>
      </tr>
      <tr>
        <td>0x1A28 (early 6.0); <br>
        0x1AA8 (late 6.0); <br>
        0x31E8 (6.1); <br>
        0x3AE8 (6.2 to 1903); <br>
        0x3B28 </td>
        <td>
        <pre class="source">KSPIN_LOCK WaitLock;</pre>
        </td>
        <td>6.0 and higher </td>
        <td>&nbsp;</td>
      </tr>
      <tr>
        <td>0x0928 (early 5.2); <br>
        0x09E8 (late 5.2); <br>
        0x1A2C (early 6.0); <br>
        0x1AAC (late 6.0); <br>
        0x31EC (6.1); <br>
        0x3AEC (6.2) </td>
        <td>
        <pre class="source">ULONG ReadySummary;</pre>
        </td>
        <td>5.2 to 6.2 </td>
        <td>next at 3AE0 </td>
      </tr>
      <tr>
        <td>0x3AEC (6.3 to 1903); <br>
        0x3B2C </td>
        <td>
        <pre class="source">LIST_ENTRY WaitListHead;</pre>
        </td>
        <td>6.3 and higher </td>
        <td>previously at 0x3AE0 </td>
      </tr>
      <tr>
        <td rowspan="3">0x092C (early 5.2); <br>
        0x09EC (late 5.2); <br>
        0x1A30 (early 6.0); <br>
        0x1AB0 (late 6.0); <br>
        0x31F0 (6.1); <br>
        0x3AF0 (6.2) </td>
        <td>
        <pre class="source">ULONG SelectNextLast;</pre>
        </td>
        <td>early 5.2 only </td>
        <td>&nbsp;</td>
      </tr>
      <tr>
        <td>
        <pre class="source">ULONG QueueIndex;</pre>
        </td>
        <td>late 5.2 to 6.1 </td>
        <td>next at 0x3AD8 </td>
      </tr>
      <tr>
        <td>
        <pre class="source">ULONG ReadyQueueWeight;</pre>
        </td>
        <td>6.2 only </td>
        <td>&nbsp;</td>
      </tr>
      <tr>
        <td>0x0930 (early 5.2); <br>
        0x09F0 (late 5.2) </td>
        <td>
        <pre class="source">LIST_ENTRY DispatcherReadyListHead [0x20];</pre>
        </td>
        <td>5.2 only </td>
        <td>next at 0x1A60 </td>
      </tr>
      <tr>
        <td rowspan="3">0x0A30 (early 5.2); <br>
        0x0AF0 (late 5.2); <br>
        0x1A34 (early 6.0); <br>
        0x1AB4 (late 6.0); <br>
        0x31F4 (6.1); <br>
        0x3AF4 (6.2 to 1903); <br>
        0x3B34 </td>
        <td>
        <pre class="source">SINGLE_LIST_ENTRY DeferredReadyListHead;</pre>
        </td>
        <td>5.2 to 6.1 </td>
        <td>next at 0x3ADC </td>
      </tr>
      <tr>
        <td>
        <pre class="source">KPRCB *BuddyPrcb;</pre>
        </td>
        <td>6.2 only </td>
        <td>&nbsp;</td>
      </tr>
      <tr>
        <td>
        <pre class="source">ULONG ScbOffset;</pre>
        </td>
        <td>6.3 and higher </td>
        <td>previously at 0x3B14 </td>
      </tr>
      <tr>
        <td>0x3AF8 (1703 to 1903); <br>
        0x3B38 </td>
        <td>
        <pre class="source">ULONG ReadyThreadCount;</pre>
        </td>
        <td>1703 and higher </td>
        <td>&nbsp;</td>
      </tr>
      <tr>
        <td>0x1A38 (early 6.0); <br>
        0x1AB8 (late 6.0); <br>
        0x31F8 (6.1); <br>
        0x3AF8 (6.2 to 1607); <br>
        0x3B00 (1703 to 1903); <br>
        0x3B40 </td>
        <td>
        <pre class="source">ULONGLONG StartCycles;</pre>
        </td>
        <td>6.0 and higher </td>
        <td>&nbsp;</td>
      </tr>
      <tr>
        <td>0x3B00 (10.0 to 1607); <br>
        0x3B08 (1703 to 1903); <br>
        0x3B48 </td>
        <td>
        <pre class="source">ULONGLONG TaggedCyclesStart;</pre>
        </td>
        <td>10.0 and higher </td>
        <td>&nbsp;</td>
      </tr>
      <tr>
        <td rowspan="2">0x3B08 (10.0 to 1607); <br>
        0x3B10 (1703 to 1903); <br>
        0x3B50 </td>
        <td>
        <pre class="source">ULONGLONG TaggedCycles [2];</pre>
        </td>
        <td>10.0 to 1903 </td>
        <td>&nbsp;</td>
      </tr>
      <tr>
        <td>
        <pre class="source">ULONGLONG TaggedCycles [3];</pre>
        </td>
        <td>2004 and higher </td>
        <td>&nbsp;</td>
      </tr>
      <tr>
        <td>0x3B00 (6.2 to 6.3); <br>
        0x3B18 (10.0 to 1607); <br>
        0x3B20 (1703 to 1903) </td>
        <td>
        <pre class="source">ULONGLONG GenerationTarget;</pre>
        </td>
        <td>6.2 to 1903 </td>
        <td>&nbsp;</td>
      </tr>
      <tr>
        <td rowspan="2">0x1A40 (early 6.0); <br>
        0x1AC0 (late 6.0); <br>
        0x3200 (6.1); <br>
        0x3B08 (6.2 to 6.3); <br>
        0x3B20 (10.0 to 1607); <br>
        0x3B28 (1703 to 1903); <br>
        0x3B68 </td>
        <td>
        <pre class="source">ULONGLONG CycleTime;</pre>
        </td>
        <td>6.0 only </td>
        <td>&nbsp;</td>
      </tr>
      <tr>
        <td>
        <pre class="source">ULONGLONG volatile CycleTime;</pre>
        </td>
        <td>6.1 and higher </td>
        <td>&nbsp;</td>
      </tr>
      <tr>
        <td>0x3208 (6.1); <br>
        0x3B10 (6.2) </td>
        <td>
        <pre class="source">ULONG volatile HighCycleTime;</pre>
        </td>
        <td>6.1 to 6.2 </td>
        <td>next at 0x3B30 </td>
      </tr>
      <tr>
        <td>0x3B14 (6.2) </td>
        <td>
        <pre class="source">ULONG ScbOffset;</pre>
        </td>
        <td>6.2 only </td>
        <td>next at 0x3AF4 </td>
      </tr>
      <tr>
        <td>0x3B10 (6.3); <br>
        0x3B28 (10.0 to 1607); <br>
        0x3B30 (1703 to 1903); <br>
        0x3B70 </td>
        <td>
        <pre class="source">ULONGLONG AffinitizedCycles;</pre>
        </td>
        <td>6.3 and higher </td>
        <td>previously at 0x3B18 </td>
      </tr>
      <tr>
        <td>0x3B38 (1703 to 1903); <br>
        0x3B78 </td>
        <td>
        <pre class="source">ULONGLONG ImportantCycles;</pre>
        </td>
        <td>1703 and higher </td>
        <td>&nbsp;</td>
      </tr>
      <tr>
        <td>0x3B40 (1703 to 1903); <br>
        0x3B80 </td>
        <td>
        <pre class="source">ULONGLONG UnimportantCycles;</pre>
        </td>
        <td>1703 and higher </td>
        <td>&nbsp;</td>
      </tr>
      <tr>
        <td>0x3B48 (1703 to 1903); <br>
        0x3B88 </td>
        <td>
        <pre class="source">ULONGLONG ReadyQueueExpectedRunTime;</pre>
        </td>
        <td>1703 and higher </td>
        <td>&nbsp;</td>
      </tr>
      <tr>
        <td rowspan="2">0x3B18 (6.2 to 6.3); <br>
        0x3B30 (10.0 to 1607); <br>
        0x3B50 (1703 to 1903); <br>
        0x3B90 </td>
        <td>
        <pre class="source">ULONGLONG AffinitizedCycles;</pre>
        </td>
        <td>6.2 only </td>
        <td>next at 0x3B10 </td>
      </tr>
      <tr>
        <td>
        <pre class="source">ULONG volatile HighCycleTime;</pre>
        </td>
        <td>6.3 and higher </td>
        <td>previously at 0x3B10 </td>
      </tr>
      <tr>
        <td>0x3B38 (10.0 to 1607); <br>
        0x3B58 (1703 to 1903); <br>
        0x3B98 </td>
        <td>
        <pre class="source">ULONGLONG Cycles [4][2];</pre>
        </td>
        <td>10.0 and higher </td>
        <td>&nbsp;</td>
      </tr>
      <tr>
        <td rowspan="3">0x0A34 (early 5.2); <br>
        0x0AF4 (late 5.2); <br>
        0x1A48 (early 6.0); <br>
        0x1AC8 (late 6.0); <br>
        0x320C (6.1)<br>
        </td>
        <td>
        <pre class="source">ULONG PrcbPad72 [11];</pre>
        </td>
        <td>5.2 only </td>
        <td>&nbsp;</td>
      </tr>
      <tr>
        <td>
        <pre class="source">ULONGLONG PrcbPad71 [3];</pre>
        </td>
        <td>6.0 only </td>
        <td>&nbsp;</td>
      </tr>
      <tr>
        <td>
        <pre class="source">ULONG PrcbPad71;
ULONGLONG PrcbPad72 [2];</pre>
        </td>
        <td>6.1 only </td>
        <td>&nbsp;</td>
      </tr>
      <tr>
        <td rowspan="4">0x3B1C (6.3); <br>
        0x3B78 (10.0 to 1607); <br>
        0x3B98 (1703 to 1903); <br>
        0x3BD8 </td>
        <td>
        <pre class="source">ULONG PrcbPad71;</pre>
        </td>
        <td>6.3 only </td>
        <td>&nbsp;</td>
      </tr>
      <tr>
        <td>
        <pre class="source">ULONG PrcbPad71 [10];</pre>
        </td>
        <td>10.0 to 1607 </td>
        <td>&nbsp;</td>
      </tr>
      <tr>
        <td>
        <pre class="source">ULONG PrcbPad71 [2];</pre>
        </td>
        <td>1703 to 1903 </td>
        <td>&nbsp;</td>
      </tr>
      <tr>
        <td>
        <pre class="source">ULONG PrcbPad71;</pre>
        </td>
        <td>2004 and higher </td>
        <td>&nbsp;</td>
      </tr>
      <tr>
        <td>0x3BDC </td>
        <td>
        <pre class="source">ULONG DpcWatchdogSequenceNumber;</pre>
        </td>
        <td>2004 and higher </td>
        <td>&nbsp;</td>
      </tr>
    </tbody>
  </table>
  <p><span class="alert">TO BE DONE</span> </p>
  <table class="Struct">
    <colgroup>
      <col class="Offset"><col class="Definition"><col class="Versions">
      <col class="Remarks">
    </colgroup>
    <thead>
      <tr>
        <th>Offset </th>
        <th>Definition </th>
        <th>Versions </th>
        <th>Remarks </th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td>0x1A60 (early 6.0); <br>
        0x1AE0 (late 6.0); <br>
        0x3220 (6.1); <br>
        0x3B20 (6.2 to 6.3); <br>
        0x3BA0 (10.0 to 1903); <br>
        0x3BE0 </td>
        <td>
        <pre class="source">LIST_ENTRY DispatcherReadyListHead [0x20];</pre>
        </td>
        <td>6.0 and higher </td>
        <td>previously at 0x09F0; <br>
        cache-aligned </td>
      </tr>
      <tr>
        <td>0x08E0 (5.1); <br>
        0x0A60 (early 5.2); <br>
        0x0B20 (late 6.2); <br>
        0x1B60 (early 6.0); <br>
        0x1BE0 (late 6.0); <br>
        0x3320 (6.1); <br>
        0x3C20 (6.2 to 6.3); <br>
        0x3CA0 (10.0 to 1903); <br>
        0x3CE0 </td>
        <td>
        <pre class="source">PVOID ChainedInterruptList;</pre>
        </td>
        <td>5.1 and higher </td>
        <td>previously at 0x06C4 </td>
      </tr>
      <tr>
        <td>0x08E4 (5.1); <br>
        0x0A64 (early 5.2); <br>
        0x0B24 (late 6.2); <br>
        0x1B64 (early 6.0); <br>
        0x1BE4 (late 6.0); <br>
        0x3324 (6.1); <br>
        0x3C24 (6.2 to 6.3); <br>
        0x3CA4 (10.0 to 1903); <br>
        0x3CE4 </td>
        <td>
        <pre class="source">LONG LookasideIrpFloat;</pre>
        </td>
        <td>5.1 and higher </td>
        <td>&nbsp;</td>
      </tr>
      <tr>
        <td>0x3C28 (6.2 to 6.3); <br>
        0x3CA8 (10.0 to 1903); <br>
        0x3CE8 </td>
        <td>
        <pre class="source">RTL_RB_TREE ScbQueue;</pre>
        </td>
        <td>6.2 and higher </td>
        <td>&nbsp;</td>
      </tr>
      <tr>
        <td>0x3C30 (6.2 to 6.3); <br>
        0x3CB0 (10.0 to 1903); <br>
        0x3CF0 </td>
        <td>
        <pre class="sources">LIST_ENTRY ScbList;</pre>
        </td>
        <td>6.2 and higher </td>
        <td>&nbsp;</td>
      </tr>
      <tr>
        <td rowspan="3">0x08E8 (5.1); <br>
        0x0A68 (early 5.2); <br>
        0x0B28 (late 5.2); <br>
        0x1B68 (early 6.0); <br>
        0x1BE8 (late 6.0); <br>
        0x3328 (6.1); <br>
        0x3C38 (6.2 to 6.3); <br>
        0x3CB8 (10.0 to 1903); <br>
        0x3CF8 </td>
        <td>
        <pre class="source">ULONG SpareFields0 [6];</pre>
        </td>
        <td>5.1 only </td>
        <td>&nbsp;</td>
      </tr>
      <tr>
        <td>
        <pre class="source">ULONG SpareFields0 [4];</pre>
        </td>
        <td>early 5.2 only </td>
        <td>&nbsp;</td>
      </tr>
      <tr>
        <td>
        <pre class="source">LONG volatile MmPageFaultCount;</pre>
        </td>
        <td>late 5.2 and higher </td>
        <td>&nbsp;</td>
      </tr>
      <tr>
        <td>0x0B2C (late 5.2); <br>
        0x1B6C (early 6.0); <br>
        0x1BEC (late 6.0); <br>
        0x332C (6.1); <br>
        0x3C3C (6.2 to 6.3); <br>
        0x3CBC (10.0 to 1903); <br>
        0x3CFC </td>
        <td>
        <pre class="source">LONG volatile MmCopyOnWriteCount;</pre>
        </td>
        <td>late 5.2 and higher </td>
        <td>&nbsp;</td>
      </tr>
      <tr>
        <td>0x0B30 (late 5.2); <br>
        0x1B70 (early 6.0); <br>
        0x1BF0 (late 6.0); <br>
        0x3330 (6.1); <br>
        0x3C40 (6.2 to 6.3); <br>
        0x3CC0 (10.0 to 1903); <br>
        0x3D00 </td>
        <td>
        <pre class="source">LONG volatile MmTransitionCount;</pre>
        </td>
        <td>late 5.2 and higher </td>
        <td>&nbsp;</td>
      </tr>
      <tr>
        <td>0x0B34 (late 5.2); <br>
        0x1B74 (early 6.0); <br>
        0x1BF4 (late 6.0); <br>
        0x3334 (6.1); <br>
        0x3C44 (6.2 to 6.3); <br>
        0x3CC4 (10.0 to 1903); <br>
        0x3D04 </td>
        <td>
        <pre class="source">LONG volatile MmCacheTransitionCount;</pre>
        </td>
        <td>late 5.2 and higher </td>
        <td>&nbsp;</td>
      </tr>
      <tr>
        <td>0x0B38 (late 5.2); <br>
        0x1B78 (early 6.0); <br>
        0x1BF8 (late 6.0); <br>
        0x3338 (6.1); <br>
        0x3C48 (6.2 to 6.3); <br>
        0x3CC8 (10.0 to 1903); <br>
        0x3D08 </td>
        <td>
        <pre class="source">LONG volatile MmDemandZeroCount;</pre>
        </td>
        <td>late 5.2 and higher </td>
        <td>&nbsp;</td>
      </tr>
      <tr>
        <td>0x0B3C (late 5.2); <br>
        0x1B7C (early 6.0); <br>
        0x1BFC (late 6.0); <br>
        0x333C (6.1); <br>
        0x3C4C (6.2 to 6.3); <br>
        0x3CCC (10.0 to 1903); <br>
        0x3D0C </td>
        <td>
        <pre class="source">LONG volatile MmPageReadCount;</pre>
        </td>
        <td>late 5.2 and higher </td>
        <td>&nbsp;</td>
      </tr>
      <tr>
        <td>0x0B40 (late 5.2); <br>
        0x1B80 (early 6.0); <br>
        0x1C00 (late 6.0); <br>
        0x3340 (6.1); <br>
        0x3C50 (6.2 to 6.3); <br>
        0x3CD0 (10.0 to 1903); <br>
        0x3D10 </td>
        <td>
        <pre class="source">LONG volatile MmPageReadIoCount;</pre>
        </td>
        <td>late 5.2 and higher </td>
        <td>&nbsp;</td>
      </tr>
      <tr>
        <td>0x0B44 (late 5.2); <br>
        0x1B84 (early 6.0); <br>
        0x1C04 (late 6.0); <br>
        0x3344 (6.1); <br>
        0x3C54 (6.2 to 6.3); <br>
        0x3CD4 (10.0 to 1903); <br>
        0x3D14 </td>
        <td>
        <pre class="source">LONG volatile MmCacheReadCount;</pre>
        </td>
        <td>late 5.2 and higher </td>
        <td>&nbsp;</td>
      </tr>
      <tr>
        <td>0x0B48 (late 5.2); <br>
        0x1B88 (early 6.0); <br>
        0x1C08 (late 6.0); <br>
        0x3348 (6.1); <br>
        0x3C58 (6.2 to 6.3); <br>
        0x3CD8 (10.0 to 1903); <br>
        0x3D18 </td>
        <td>
        <pre class="source">LONG volatile MmCacheIoCount;</pre>
        </td>
        <td>late 5.2 and higher </td>
        <td>&nbsp;</td>
      </tr>
      <tr>
        <td>0x0B4C (late 5.2); <br>
        0x1B8C (early 6.0); <br>
        0x1C0C (late 6.0); <br>
        0x334C (6.1); <br>
        0x3C5C (6.2 to 6.3); <br>
        0x3CDC (10.0 to 1903); <br>
        0x3D1C </td>
        <td>
        <pre class="source">LONG volatile MmDirtyPagesWriteCount;</pre>
        </td>
        <td>late 5.2 and higher </td>
        <td>&nbsp;</td>
      </tr>
      <tr>
        <td>0x0B50 (late 5.2); <br>
        0x1B90 (early 6.0); <br>
        0x1C10 (late 6.0); <br>
        0x3350 (6.1); <br>
        0x3C60 (6.2 to 6.3); <br>
        0x3CE0 (10.0 to 1903); <br>
        0x3D20 </td>
        <td>
        <pre class="source">LONG volatile MmDirtyWriteIoCount;</pre>
        </td>
        <td>late 5.2 and higher </td>
        <td>&nbsp;</td>
      </tr>
      <tr>
        <td>0x0B54 (late 5.2); <br>
        0x1B94 (early 6.0); <br>
        0x1C14 (late 6.0); <br>
        0x3354 (6.1); <br>
        0x3C64 (6.2 to 6.3); <br>
        0x3CE4 (10.0 to 1903); <br>
        0x3D24 </td>
        <td>
        <pre class="source">LONG volatile MmMappedPagesWriteCount;</pre>
        </td>
        <td>late 5.2 and higher </td>
        <td>&nbsp;</td>
      </tr>
      <tr>
        <td>0x0B58 (late 5.2); <br>
        0x1B98 (early 6.0); <br>
        0x1C18 (late 6.0); <br>
        0x3358 (6.1); <br>
        0x3C68 (6.2 to 6.3); <br>
        0x3CE8 (10.0 to 1903); <br>
        0x3D28 </td>
        <td>
        <pre class="source">LONG volatile MmMappedWriteIoCount;</pre>
        </td>
        <td>late 5.2 and higher </td>
        <td>&nbsp;</td>
      </tr>
      <tr>
        <td>0x1B9C (early 6.0); <br>
        0x1C1C (late 6.0); <br>
        0x335C (6.1); <br>
        0x3C6C (6.2 to 6.3); <br>
        0x3CEC (10.0 to 1903); <br>
        0x3D2C </td>
        <td>
        <pre class="source">ULONG volatile CachedCommit;</pre>
        </td>
        <td>6.0 and higher </td>
        <td>&nbsp;</td>
      </tr>
      <tr>
        <td>0x1BA0 (early 6.0); <br>
        0x1C20 (late 6.0); <br>
        0x3360 (6.1); <br>
        0x3C70 (6.2 to 6.3); <br>
        0x3CF0 (10.0 to 1903); <br>
        0x3D30 </td>
        <td>
        <pre class="source">ULONG volatile CachedResidentAvailable;</pre>
        </td>
        <td>6.0 and higher </td>
        <td>&nbsp;</td>
      </tr>
      <tr>
        <td>0x1BA4 (early 6.0); <br>
        0x1C24 (late 6.0); <br>
        0x3364 (6.1); <br>
        0x3C74 (6.2 to 6.3); <br>
        0x3CF4 (10.0 to 1903); <br>
        0x3D34 </td>
        <td>
        <pre class="source">PVOID HyperPte;</pre>
        </td>
        <td>6.0 and higher </td>
        <td>&nbsp;</td>
      </tr>
      <tr>
        <td>0x0B5C (late 5.2) </td>
        <td>
        <pre class="source">ULONG SpareFields0 [1];</pre>
        </td>
        <td>late 5.2 only </td>
        <td>&nbsp;</td>
      </tr>
    </tbody>
  </table>
  <h4>The Old End </h4>
  <table class="Struct">
    <colgroup>
      <col class="Offset"><col class="Definition"><col class="Versions">
      <col class="Remarks">
    </colgroup>
    <thead>
      <tr>
        <th>Offset </th>
        <th>Definition </th>
        <th>Versions </th>
        <th>Remarks </th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td>0x0334 (3.50); <br>
        0x034C (3.51); <br>
        0x052C (4.0); <br>
        0x072C (5.0) </td>
        <td>
        <pre class="source">BOOLEAN SkipTick;</pre>
        </td>
        <td>3.50 to 5.0 </td>
        <td>next at 0x04C4 </td>
      </tr>
      <tr>
        <td>0x1BA8 (early 6.0); <br>
        0x1C28 (late 6.0) </td>
        <td>
        <pre class="source">UCHAR CpuVendor;</pre>
        </td>
        <td>6.0 only </td>
        <td>next at 0x03C4 </td>
      </tr>
      <tr>
        <td rowspan="3">0x1BA9 (early 6.0); <br>
        0x1C29 (late 6.0); <br>
        0x3368 (6.1); <br>
        0x3C78 (6.2 to 6.3); <br>
        0x3CF8 (10.0 to 1903); <br>
        0x3D38 </td>
        <td>
        <pre class="source">UCHAR PrcbPad9 [3];</pre>
        </td>
        <td>early 6.0 only </td>
        <td>&nbsp;</td>
      </tr>
      <tr>
        <td>
        <pre class="source">UCHAR PrcbPad8 [3];</pre>
        </td>
        <td>late 6.0 only </td>
        <td>&nbsp;</td>
      </tr>
      <tr>
        <td>
        <pre class="source">UCHAR PrcbPad8 [4];</pre>
        </td>
        <td>6.1 and higher </td>
        <td>&nbsp;</td>
      </tr>
      <tr>
        <td>0x0335 (3.50); <br>
        0x034D (3.51); <br>
        0x052D (4.0); <br>
        0x072D (5.0); <br>
        0x0900 (5.1); <br>
        0x0A78 (early 5.2); <br>
        0x0B60 (late 5.2); <br>
        0x1BAC (early 6.0); <br>
        0x1C2C (late 6.0); <br>
        0x336C (6.1); <br>
        0x3C7C (6.2 to 6.3); <br>
        0x3CFC (10.0 to 1903); <br>
        0x3D3C </td>
        <td>
        <pre class="source">UCHAR VendorString [0x0D];</pre>
        </td>
        <td>3.50 and higher </td>
        <td>&nbsp;</td>
      </tr>
      <tr>
        <td>0x090D (5.1); <br>
        0x0A85 (early 5.2); <br>
        0x0B6D (late 5.2); <br>
        0x1BB9 (early 6.0); <br>
        0x1C39 (late 6.0); <br>
        0x3379 (6.1); <br>
        0x3C89 (6.2 to 6.3); <br>
        0x3D09 (10.0 to 1903); <br>
        0x3D49 </td>
        <td>
        <pre class="source">UCHAR InitialApicId;</pre>
        </td>
        <td>5.1 and higher </td>
        <td>&nbsp;</td>
      </tr>
      <tr>
        <td>0x1BBA (early 6.0) </td>
        <td>
        <pre class="source">UCHAR CoresPerPhysicalProcessor;</pre>
        </td>
        <td>early 6.0 only </td>
        <td>next at 0x03C0 </td>
      </tr>
      <tr>
        <td>0x090E (5.1); <br>
        0x0A86 (early 5.2); <br>
        0x0B6E (late 5.2); <br>
        0x1BBB (early 6.0); <br>
        0x1C3A (late 6.0); <br>
        0x337A (6.1); <br>
        0x3C8A (6.2 to 6.3); <br>
        0x3D0A (10.0 to 1903); <br>
        0x3D4A </td>
        <td>
        <pre class="source">UCHAR LogicalProcessorsPerPhysicalProcessor;</pre>
        </td>
        <td>5.1 and higher </td>
        <td>&nbsp;</td>
      </tr>
      <tr>
        <td>0x1C3B (late 6.0); <br>
        0x337B (6.1); <br>
        0x3C8B (6.2 to 6.3); <br>
        0x3D0B (10.0 to 1903); <br>
        0x3D4B </td>
        <td>
        <pre class="source">UCHAR PrcbPad9 [5];</pre>
        </td>
        <td>late 6.0 and higher </td>
        <td>&nbsp;</td>
      </tr>
      <tr>
        <td>0x053C (4.0); <br>
        0x073C (5.0); <br>
        0x0910 (5.1); <br>
        0x0A88 (early 5.2); <br>
        0x0B70 (late 5.2); <br>
        0x1BBC (early 6.0) <br>
        </td>
        <td>
        <pre class="source">ULONG MHz;</pre>
        </td>
        <td>4.0 to early 6.0 </td>
        <td>next at 0x03C4 </td>
      </tr>
      <tr>
        <td rowspan="2">0x0540 (4.0); <br>
        0x0740 (5.0); <br>
        0x0914 (5.1); <br>
        0x0A8C (early 5.2); <br>
        0x0B74 (late 5.2); <br>
        0x1BC0 (early 6.0); <br>
        0x1C40 (late 6.0); <br>
        0x3380 (6.1); <br>
        0x3C90 (6.2 to 6.3); <br>
        0x3D10 (10.0 to 1903); <br>
        0x3D50 </td>
        <td>
        <pre class="source">ULONG FeatureBits;</pre>
        </td>
        <td>4.0 to 6.3 </td>
        <td>&nbsp;</td>
      </tr>
      <tr>
        <td>
        <pre class="source">ULONGLONG FeatureBits;</pre>
        </td>
        <td>10.0 and higher </td>
        <td>&nbsp;</td>
      </tr>
      <tr>
        <td>0x0548 (4.0); <br>
        0x0748 (5.0); <br>
        0x0918 (5.1); <br>
        0x0A90 (early 5.2); <br>
        0x0B78 (late 5.2); <br>
        0x1BC8 (early 6.0); <br>
        0x1C48 (late 6.0); <br>
        0x3388 (6.1); <br>
        0x3C98 (6.2 to 6.3); <br>
        0x3D18 (10.0 to 1903); <br>
        0x3D58 </td>
        <td>
        <pre class="source">LARGE_INTEGER UpdateSignature;</pre>
        </td>
        <td>4.0 and higher </td>
        <td>&nbsp;</td>
      </tr>
      <tr>
        <td>0x0344 (3.50); <br>
        0x035C (3.51); <br>
        0x0550 (4.0); <br>
        0x0750 (5.0) </td>
        <td>
        <pre class="source">ULONG QuantumEnd;</pre>
        </td>
        <td>3.50 to 5.0 </td>
        <td>last member in 3.50; <br>
        last member in 3.51; <br>
        last member in 4.0; <br>
        next at 0x088C </td>
      </tr>
    </tbody>
  </table>
  <p>The <span class="member">InitialApicId</span> is the high byte of what’s returned 
  in <span class="register">ebx</span> for <span class="instruction">cpuid</span> 
  leaf 1. </p>
  <p>Given a GenuineIntel processor whose <span class="member">CpuType</span>, i.e., 
  family, is at least 6, the <span class="member">UpdateSignature</span> is all 
  64 bits that are read from the Model Specific Register 0x8B (<span class="constant">IA32_BIOS_SIGN_ID</span>), 
  having first written zero to that register and then executed the
  <span class="instruction">cpuid</span> instruction’s leaf 1. Starting with version 
  6.2, Windows also gets the <span class="member">UpdateSignature</span>—by a straightforward 
  read of the MSR—if the vendor is AuthenticAMD and the family is at least 15.
  </p>
  <p>What <span class="member">QuantumEnd</span> holds is an indicator of which 
  thread was most recently seen to have ended its quantum while running on this 
  processor. The indicator is an address of apparently no signficance from the thread’s 
  stack at the time. Later versions eventually turn it into a <span class="type">
  BOOLEAN</span>. The kernel’s <span class="function">KiDispatchInterrupt</span> 
  function checks for this indicator after retiring DPCs so that action to take 
  at the end of the quantum is in effect a lowest-priority DPC. Version 3.10 actually 
  did schedule this action as a DPC, with no control over the ordering. </p>
  <h4>Appended for Windows 2000 </h4>
  <p>The significant development of power management for Windows 2000 brought to 
  the <span class="struct">KPRCB</span> a large structure for which Microsoft provides 
  a C-language definition in NTPOAPI.H. The <span class="struct">
  <a href="../../procpowr/processor_power_state.htm">PROCESSOR_POWER_STATE</a></span> 
  has since changed beyond recognition, yet the definition for Windows 2000 remains 
  even in the NTPOAPI.H from the WDK for Windows 10. Throughout, a comment describes 
  it as the “Power structure in each processor’s PRCB”. </p>
  <p>The <span class="member">PowerState</span> and <span class="member">NpxSaveArea</span> 
  anyway got swapped for version 5.1. The latter needs 16-byte alignment. This left 
  version 5.2 with 8 bytes to use for the <span class="member">IsrTime</span>. That 
  it remains seems to have given later versions some work. </p>
  <table class="Struct">
    <colgroup>
      <col class="Offset"><col class="Definition"><col class="Versions">
      <col class="Remarks">
    </colgroup>
    <thead>
      <tr>
        <th>Offset </th>
        <th>Definition </th>
        <th>Versions </th>
        <th>Remarks </th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td>0x0758 (5.0) </td>
        <td>
        <pre class="source">PROCESSOR_POWER_STATE PowerState;</pre>
        </td>
        <td>5.0 only </td>
        <td>next at 0x0B30 </td>
      </tr>
      <tr>
        <td>0x0A98 (early 5.2); <br>
        0x0B80 (late 5.2); <br>
        0x1BD0 (early 6.0); <br>
        0x1C50 (late 6.0); <br>
        0x3390 (6.1); <br>
        0x3CA0 (6.2 to 6.3); <br>
        0x3D20 (10.0 to 1903); <br>
        0x3D60 </td>
        <td>
        <pre class="source">ULONGLONG volatile IsrTime;</pre>
        </td>
        <td>5.2 and higher </td>
        <td>&nbsp;</td>
      </tr>
      <tr>
        <td rowspan="3">0x0B88 (late 5.2); <br>
        0x1BD8 (early 6.0); <br>
        0x1C58 (late 6.0); <br>
        0x3398 (6.1); <br>
        0x3CA8 (6.2) </td>
        <td>
        <pre class="source">ULONGLONG SpareField1;</pre>
        </td>
        <td>late 5.2 to 6.0 </td>
        <td>&nbsp;</td>
      </tr>
      <tr>
        <td>
        <pre class="source">ULONGLONG RuntimeAccumulation;</pre>
        </td>
        <td>6.1 only </td>
        <td>&nbsp;</td>
      </tr>
      <tr>
        <td>
        <pre class="source">ULONG Stride;</pre>
        </td>
        <td>6.2 only </td>
        <td>&nbsp;</td>
      </tr>
      <tr>
        <td rowspan="2">0x3CAC (6.2); <br>
        0x3CA8 (6.3); <br>
        0x3D28 </td>
        <td>
        <pre class="source">ULONG PrcbPad90;</pre>
        </td>
        <td>6.2 only </td>
        <td>&nbsp;</td>
      </tr>
      <tr>
        <td>
        <pre class="source">ULONG PrcbPad90 [2];</pre>
        </td>
        <td>6.3 and higher </td>
        <td>&nbsp;</td>
      </tr>
      <tr>
        <td>0x3D68 </td>
        <td>
        <pre class="source">ULONGLONG GenerationTarget;</pre>
        </td>
        <td>2004 and higher </td>
        <td>&nbsp;</td>
      </tr>
      <tr>
        <td>0x07E0 (5.0); <br>
        0x0920 (5.1); <br>
        0x0AA0 (early 5.2); <br>
        0x0B90 (late 5.2); <br>
        0x1BE0 (early 6.0); <br>
        0x1C60 (late 6.0) </td>
        <td>
        <pre class="source">FX_SAVE_AREA NpxSaveArea;</pre>
        </td>
        <td>5.0 to 6.0 </td>
        <td>last member in 5.0 </td>
      </tr>
    </tbody>
  </table>
  <h4>Appended for Windows XP </h4>
  <table class="Struct">
    <colgroup>
      <col class="Offset"><col class="Definition"><col class="Versions">
      <col class="Remarks">
    </colgroup>
    <thead>
      <tr>
        <th>Offset </th>
        <th>Definition </th>
        <th>Versions </th>
        <th>Remarks </th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td>0x0B30 (5.1); <br>
        0x0CB0 (early 5.2); <br>
        0x0DA0 (late 5.2); <br>
        0x1DF0 (early 6.0); <br>
        0x1E70 (late 6.0); <br>
        0x33A0 (6.1); <br>
        0x3CB0 (6.2 to 6.3); <br>
        0x3D30 (10.0 to 1903); <br>
        0x3D70 </td>
        <td>
        <pre class="source">PROCESSOR_POWER_STATE PowerState;</pre>
        </td>
        <td>5.1 and higher </td>
        <td>previously at 0x0758; <br>
        last member in 5.1; <br>
        last member in 5.2 </td>
      </tr>
    </tbody>
  </table>
  <p>The intention behind the following padding is not known. </p>
  <table class="Struct">
    <colgroup>
      <col class="Offset"><col class="Definition"><col class="Versions">
    </colgroup>
    <thead>
      <tr>
        <th>Offset </th>
        <th>Definition </th>
        <th>Versions </th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td>0x3EB0 (1703); <br>
        0x3ED8 (1709 to 1903); <br>
        0x3F18 </td>
        <td>
        <pre class="source">KDPC ForceIdleDpc;</pre>
        </td>
        <td>1703 and higher </td>
      </tr>
      <tr>
        <td>0x3F38 </td>
        <td>
        <pre class="source">ULONGLONG MsrIa32TsxCtrl;</pre>
        </td>
        <td>2004 and higher </td>
      </tr>
      <tr>
        <td rowspan="5">0x3E30 (6.2); <br>
        0x3E40 (6.3); <br>
        0x3EB0 (10.0 to 1607); <br>
        0x3ED0 (1703); <br>
        0x3DF8 (1709 to 1903); <br>
        0x3F40 </td>
        <td>
        <pre class="source">ULONG PrcbPad91 [1];</pre>
        </td>
        <td>6.2 only </td>
      </tr>
      <tr>
        <td>
        <pre class="source">ULONG PrcbPad91 [11];</pre>
        </td>
        <td>6.3 to 1607 </td>
      </tr>
      <tr>
        <td>
        <pre class="source">ULONG PrcbPad91 [8];</pre>
        </td>
        <td>1703 only </td>
      </tr>
      <tr>
        <td>
        <pre class="source">ULONG PrcbPad91 [14];</pre>
        </td>
        <td>1709 to 1903 </td>
      </tr>
      <tr>
        <td>
        <pre class="source">ULONG PrcbPad91 [6];</pre>
        </td>
        <td>2004 and higher </td>
      </tr>
    </tbody>
  </table>
  <h4>Appended For Windows Vista </h4>
  <table class="Struct">
    <colgroup>
      <col class="Offset"><col class="Definition"><col class="Versions">
      <col class="Remarks">
    </colgroup>
    <thead>
      <tr>
        <th>Offset </th>
        <th>Definition </th>
        <th>Versions </th>
        <th>Remarks </th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td>0x3F58 </td>
        <td>
        <pre class="source">RTL_HASH_TABLE *DpcRuntimeHistoryHashTable;</pre>
        </td>
        <td>2004 and higher </td>
        <td>&nbsp;</td>
      </tr>
      <tr>
        <td>0x3F5C </td>
        <td>
        <pre class="source">KDPC *DpcRuntimeHistoryHashTableCleanupDpc;</pre>
        </td>
        <td>2004 and higher </td>
        <td>&nbsp;</td>
      </tr>
      <tr>
        <td>0x3F60 </td>
        <td>
        <pre class="source">ULONGLONG CurrentDpcRuntimeHistoryCached;</pre>
        </td>
        <td>2004 and higher </td>
        <td>&nbsp;</td>
      </tr>
      <tr>
        <td>0x3F68 </td>
        <td>
        <pre class="source">ULONGLONG CurrentDpcStartTime;</pre>
        </td>
        <td>2004 and higher </td>
        <td>&nbsp;</td>
      </tr>
      <tr>
        <td>0x3F70 </td>
        <td>
        <pre class="source">KDEFERRED_ROUTINE *CurrentDpcRoutine;</pre>
        </td>
        <td>2004 and higher </td>
        <td>&nbsp;</td>
      </tr>
      <tr>
        <td>0x3EF0 (1703); <br>
        0x3F30 (1709 to 1903); <br>
        0x3F74 </td>
        <td>
        <pre class="source">ULONG DpcWatchdogProfileSingleDpcThreshold;</pre>
        </td>
        <td>1703 and higher </td>
        <td>&nbsp;</td>
      </tr>
      <tr>
        <td>0x1ED0 (early 6.0); <br>
        0x1F38 (late 6.0); <br>
        0x3468 (6.1); <br>
        0x3E34 (6.2); <br>
        0x3E74 (6.3); <br>
        0x3EF4 (10.0 to 1703); <br>
        0x3F34 (1709 to 1903); <br>
        0x3F78 </td>
        <td>
        <pre class="source">KDPC DpcWatchdogDpc;</pre>
        </td>
        <td>6.0 and higher </td>
        <td>&nbsp;</td>
      </tr>
      <tr>
        <td>0x1EF0 (early 6.0); <br>
        0x1F58 (late 6.0); <br>
        0x3488 (6.1); <br>
        0x3E58 (6.2); <br>
        0x3E98 (6.3); <br>
        0x3F18 (10.0 to 1703); <br>
        0x3F58 (1709 to 1903); <br>
        0x3F98 </td>
        <td>
        <pre class="source"><a href="../../ntosdef_x/ktimer.htm">KTIMER</a> DpcWatchdogTimer;</pre>
        </td>
        <td>6.0 and higher </td>
        <td>&nbsp;</td>
      </tr>
      <tr>
        <td>0x1F18 (early 6.0); <br>
        0x1F80 (late 6.0); <br>
        0x34B0 (6.1) </td>
        <td>
        <pre class="source">PVOID WheaInfo;</pre>
        </td>
        <td>6.0 to 6.1 </td>
        <td>next at 0x3F04 </td>
      </tr>
      <tr>
        <td>0x1F1C (early 6.0); <br>
        0x1F84 (late 6.0); <br>
        0x34B4 (6.1) </td>
        <td>
        <pre class="source">PVOID EtwSupport;</pre>
        </td>
        <td>6.0 to 6.1 </td>
        <td>next at 0x3F08 </td>
      </tr>
      <tr>
        <td>0x1F20 (early 6.0); <br>
        0x1F88 (late 6.0); <br>
        0x34B8 (6.1) </td>
        <td>
        <pre class="source">SLIST_HEADER InterruptObjectPool;</pre>
        </td>
        <td>6.0 to 6.1 </td>
        <td>next at 0x3F10 </td>
      </tr>
    </tbody>
  </table>
  <p>The WHEA in the naming of <span class="member">WheaInfo</span> is the Windows 
  Hardware Error Architecture. What the <span class="member">WheaInfo</span> points 
  to is a <span class="struct">WHEAP_INFO_BLOCK</span>. </p>
  <p>Windows 8 moves the <span class="member">WheaInfo</span>,
  <span class="member">EtwSupport</span> and (8-byte aligned)
  <span class="member">InterruptObjectPool</span> further into the structure, keeping 
  them together. Whether they’re intended as some sort of set is not known, but 
  they are also together in the x64 <span class="struct">KPRCB</span>. </p>
  <p>According to what the WMITRACE.DLL debugger extension’s undocumented
  <span class="command">!systrace StackTraceCounters</span> command would do if 
  given the expected kernel symbols, what the <span class="member">EtwSupport</span> 
  points to is an <span class="struct">ETW_TRACING_BLOCK</span>. The kernel’s public 
  symbols do not show this structure, nor do any symbol files in the downloadable 
  packages of public symbols. Whether any at Microsoft’s public symbol server do, 
  I don’t know, but it’s safe to say that the <span class="struct">ETW_TRACING_BLOCK</span> 
  is as obscure as can be for a kernel structure whose name is known with the certainty 
  of its being looked for by a debugger extension. Searching for it through Google 
  today, 8th February 2023, both with and without a leading underscore, gets zero 
  matches. </p>
  <table class="Struct">
    <colgroup>
      <col class="Offset"><col class="Definition"><col class="Versions">
      <col class="Remarks">
    </colgroup>
    <thead>
      <tr>
        <th>Offset </th>
        <th>Definition </th>
        <th>Versions </th>
        <th>Remarks </th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td rowspan="2">0x1F28 (early 6.0); <br>
        0x1F90 (late 6.0); <br>
        0x34C0 (6.1); <br>
        0x3E80 (6.2); <br>
        0x3EC0 (6.3); <br>
        0x3F40 (10.0 to 1703); <br>
        0x3F80 (1709 to 1903); <br>
        0x3FC0 </td>
        <td>
        <pre class="source">LARGE_INTEGER HypercallPagePhysical;</pre>
        </td>
        <td>early 6.0 only </td>
        <td>&nbsp;</td>
      </tr>
      <tr>
        <td>
        <pre class="source">SLIST_HEADER HypercallPageList;</pre>
        </td>
        <td>late 6.0 and higher </td>
        <td>&nbsp;</td>
      </tr>
      <tr>
        <td rowspan="2">0x1F30 (early 6.0); <br>
        0x1F98 (late 6.0); <br>
        0x34C8 (6.1); <br>
        0x3E88 (6.2); <br>
        0x3EC8 (6.3); <br>
        0x3F48 (10.0 to 1703); <br>
        0x3F88 (1709 to 1903); <br>
        0x3FC8 </td>
        <td>
        <pre class="source">PVOID HypercallPageVirtual;</pre>
        </td>
        <td>6.0 to 6.3 </td>
        <td>&nbsp;</td>
      </tr>
      <tr>
        <td>
        <pre class="source">PVOID HypercallCachedPages;</pre>
        </td>
        <td>10.0 and higher </td>
        <td>&nbsp;</td>
      </tr>
      <tr>
        <td>0x1F9C (late 6.0); <br>
        0x34CC (6.1); <br>
        0x3E8C (6.2); <br>
        0x3ECC (6.3); <br>
        0x3F4C (10.0 to 1703); <br>
        0x3F8C (1709 to 1903); <br>
        0x3FCC </td>
        <td>
        <pre class="source">PVOID VirtualApicAssist;</pre>
        </td>
        <td>late 6.0 and higher </td>
        <td>&nbsp;</td>
      </tr>
      <tr>
        <td>0x1FA0 (late 6.0); <br>
        0x34D0 (6.1); <br>
        0x3E90 (6.2); <br>
        0x3ED0 (6.3); <br>
        0x3F50 (10.0 to 1703); <br>
        0x3F90 (1709 to 1903); <br>
        0x3FD0 </td>
        <td>
        <pre class="source">ULONGLONG *StatisticsPage;</pre>
        </td>
        <td>late 6.0 and higher </td>
        <td>&nbsp;</td>
      </tr>
      <tr>
        <td>0x1F34 (early 6.0); <br>
        0x1FA4 (late 6.0); <br>
        0x34D4 (6.1) </td>
        <td>
        <pre class="source">PVOID RateControl;</pre>
        </td>
        <td>6.0 to 6.1 </td>
        <td>&nbsp;</td>
      </tr>
      <tr>
        <td>0x1F38 (early 6.0); <br>
        0x1FA8 (late 6.0); <br>
        0x34D8 (6.1); <br>
        0x3E94 (6.2); <br>
        0x3ED4 (6.3); <br>
        0x3F54 (10.0 to 1703); <br>
        0x3F94 (1709 to 1903); <br>
        0x3FD4 </td>
        <td>
        <pre class="source">CACHE_DESCRIPTOR Cache [5];</pre>
        </td>
        <td>6.0 and higher </td>
        <td>&nbsp;</td>
      </tr>
      <tr>
        <td>0x1F74 (early 6.0); <br>
        0x1FE4 (late 6.0); <br>
        0x3514 (6.1); <br>
        0x3ED0 (6.2); <br>
        0x3F10 (6.3); <br>
        0x3F90 (10.0 to 1703); <br>
        0x3FD0 (1709 to 1903); <br>
        0x4010 </td>
        <td>
        <pre class="source">ULONG CacheCount;</pre>
        </td>
        <td>6.0 and higher </td>
        <td>&nbsp;</td>
      </tr>
      <tr>
        <td>0x1F78 (early 6.0); <br>
        0x1FE8 (late 6.0); <br>
        0x3518 (6.1) </td>
        <td>
        <pre class="source">ULONG CacheProcessorMask [5];</pre>
        </td>
        <td>6.0 to 6.1 </td>
        <td>next at 0x3EE0 </td>
      </tr>
      <tr>
        <td>0x1F8C (early 6.0) </td>
        <td>
        <pre class="source">UCHAR LogicalProcessorsPerCore;</pre>
        </td>
        <td>early 6.0 only </td>
        <td>next at 0x03C1 </td>
      </tr>
      <tr>
        <td>0x1F8D (early 6.0) </td>
        <td>
        <pre class="source">UCHAR PrcbPad8 [3];</pre>
        </td>
        <td>early 6.0 only </td>
        <td>&nbsp;</td>
      </tr>
      <tr>
        <td rowspan="2">0x1F90 (early 6.0); <br>
        0x1FFC (late 6.0); <br>
        0x352C (6.1); <br>
        0x3ED4 (6.2); <br>
        0x3F14 (6.3); <br>
        0x3F94 (10.0 to 1703); <br>
        0x3FD4 (1709 to 1903); <br>
        0x4014 </td>
        <td>
        <pre class="source">KAFFINITY PackageProcessorSet;</pre>
        </td>
        <td>6.0 only </td>
        <td>&nbsp;</td>
      </tr>
      <tr>
        <td>
        <pre class="source"><a href="../../../../api/ke/affinity/kaffinity_ex.htm">KAFFINITY_EX</a> PackageProcessorSet;</pre>
        </td>
        <td>6.1 and higher </td>
        <td>&nbsp;</td>
      </tr>
    </tbody>
  </table>
  <p>That the <span class="struct">KPRCB</span> has a <span class="struct">KAFFINITY_EX</span> 
  among its members has a curious side-effect in the symbol file WNTDLL.PDB for 
  the WOW64 variant of NTDLL.DLL. Its type information for the
  <span class="struct">KPRCB</span> is wrong because the <span class="struct">KAFFINITY_EX</span> 
  is compiled with the greater allowance that 64-bit Windows has for processor groups 
  (20 instead 1). For this symbol file, which the 32-bit debugger uses for the 32-bit 
  NTDLL.DLL when debugging a 32-bit application, everything after
  <span class="member">PackageProcessorSet</span> is said to be further into the
  <span class="struct">KPRCB</span> than it truly is. </p>
  <p>The wonder, of course, is that a symbol file for any user-mode DLL has type 
  information for the kernel-mode <span class="struct">KPRCB</span>. Even the symbol 
  file for NTDLL surely is not intended to. It picks up <span class="struct">KPRCB</span> 
  from a <span class="directive">#include</span> of I386_X.H. That this header gets 
  included may itself be unintended. But included it is, and since it not only defines 
  the <span class="struct">KPRCB</span> but uses it in an inline routine even the 
  public symbols get type information for it. The practical consequence for debugging 
  is nothing, the <span class="struct">KPRCB</span> having no meaning in the circumstances, 
  but the significance for reverse engineering is two-fold. First, type information 
  can turn up in symbol files for modules that make no run-time use of the type. 
  This also has significance for programmers, and perhaps their lawyers, who are 
  concerned for what’s revealed in symbol files. Second, type information is not 
  as certainly correct as reverse engineers tend to think (or blindly hope). </p>
  <table class="Struct">
    <colgroup>
      <col class="Offset"><col class="Definition"><col class="Versions">
      <col class="Remarks">
    </colgroup>
    <thead>
      <tr>
        <th>Offset </th>
        <th>Definition </th>
        <th>Versions </th>
        <th>Remarks </th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td rowspan="2">0x3EE0 (6.2); <br>
        0x3F20 (6.3); <br>
        0x3FA0 (10.0 to 1703); <br>
        0x3FE0 (1709 to 1903); <br>
        0x4020 </td>
        <td>
        <pre class="source">ULONG CacheProcessorMask [5];</pre>
        </td>
        <td>6.2 only </td>
        <td>previously at 0x3518; <br>
        next at 0x3F34 </td>
      </tr>
      <tr>
        <td>
        <pre class="source">ULONG SharedReadyQueueMask;</pre>
        </td>
        <td>6.3 and higher </td>
        <td>&nbsp;</td>
      </tr>
      <tr>
        <td rowspan="3">0x3538 (6.1); <br>
        0x3EF4 (6.2); <br>
        0x3F24 (6.3); <br>
        0x3FA4 (10.0 to 1703); <br>
        0x3FE4 (1709 to 1903); <br>
        0x4024 </td>
        <td>
        <pre class="source">ULONG PrcbPad91 [1];</pre>
        </td>
        <td>6.1 only </td>
        <td>&nbsp;</td>
      </tr>
      <tr>
        <td>
        <pre class="source">ULONG ScanSiblingMask;</pre>
        </td>
        <td>6.2 only </td>
        <td>next at 0x3F2C </td>
      </tr>
      <tr>
        <td>
        <pre class="source">KSHARED_READY_QUEUE *SharedReadyQueue;</pre>
        </td>
        <td>6.3 and higher </td>
        <td>&nbsp;</td>
      </tr>
      <tr>
        <td>0x3FA8 (10.0 to 1703); <br>
        0x3FE8 (1709 to 1903); <br>
        0x4028 </td>
        <td>
        <pre class="source">ULONG SharedQueueScanOwner;</pre>
        </td>
        <td>10.0 and higher </td>
        <td>&nbsp;</td>
      </tr>
      <tr>
        <td>0x1F94 (early 6.0); <br>
        0x2000 (late 6.0); <br>
        0x353C (6.1); <br>
        0x3EF8 (6.2); <br>
        0x3F28 (6.3); <br>
        0x3FAC (10.0 to 1703); <br>
        0x3FEC (1709 to 1903); <br>
        0x402C </td>
        <td>
        <pre class="source">ULONG CoreProcessorSet;</pre>
        </td>
        <td>6.0 and higher </td>
        <td>last member in 6.0 </td>
      </tr>
    </tbody>
  </table>
  <h4>Inserted For Windows 8 </h4>
  <table class="Struct">
    <colgroup>
      <col class="Offset"><col class="Definition"><col class="Versions">
      <col class="Remarks">
    </colgroup>
    <thead>
      <tr>
        <th>Offset </th>
        <th>Definition </th>
        <th>Versions </th>
        <th>Remarks </th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td>0x3F2C (6.3); <br>
        0x3FB0 (10.0 to 1703); <br>
        0x3FF0 (1709 to 1903); <br>
        0x4030 </td>
        <td>
        <pre class="source">ULONG ScanSiblingMask;</pre>
        </td>
        <td>6.3 and higher </td>
        <td>previously at 0x3EF4 </td>
      </tr>
      <tr>
        <td>0x3F30 (6.3); <br>
        0x3FB4 (10.0 to 1703); <br>
        0x3FF4 (1709 to 1903); <br>
        0x4034 </td>
        <td>
        <pre class="source">ULONG LLCMask;</pre>
        </td>
        <td>6.3 and higher </td>
        <td>&nbsp;</td>
      </tr>
      <tr>
        <td>0x3F34 (6.3); <br>
        0x3FB8 (10.0 to 1703); <br>
        0x3FF8 (1709 to 1903); <br>
        0x4038 </td>
        <td>
        <pre class="source">ULONG CacheProcessorMask [5];</pre>
        </td>
        <td>6.3 and higher </td>
        <td>previously at 0x3EE0 </td>
      </tr>
      <tr>
        <td>0x3EFC (6.2); <br>
        0x3F48 (6.3); <br>
        0x3FCC (10.0 to 1703); <br>
        0x400C (1709 to 1903); <br>
        0x404C </td>
        <td>
        <pre class="source">ULONG ScanSiblingIndex;</pre>
        </td>
        <td>6.2 and higher </td>
        <td>&nbsp;</td>
      </tr>
      <tr>
        <td>0x3F00 (6.2) </td>
        <td>
        <pre class="source">ULONG LLCLevel;</pre>
        </td>
        <td>6.2 only </td>
        <td>&nbsp;</td>
      </tr>
      <tr>
        <td>0x3F04 (6.2); <br>
        0x3F4C (6.3); <br>
        0x3FD0 (10.0 to 1703); <br>
        0x4010 (1709 to 1903); <br>
        0x4050 </td>
        <td>
        <pre class="source">PVOID WheaInfo;</pre>
        </td>
        <td>6.2 and higher </td>
        <td>previously at 0x34B0 </td>
      </tr>
      <tr>
        <td>0x3F08 (6.2); <br>
        0x3F50 (6.3); <br>
        0x3FD4 (10.0 to 1703); <br>
        0x4014 (1709 to 1903); <br>
        0x4054 </td>
        <td>
        <pre class="source">PVOID EtwSupport;</pre>
        </td>
        <td>6.2 and higher </td>
        <td>previously at 0x34B4 </td>
      </tr>
      <tr>
        <td>0x3F10 (6.2); <br>
        0x3F58 (6.3); <br>
        0x3FD8 (10.0 to 1703); <br>
        0x4018 (1709 to 1903); <br>
        0x4058 </td>
        <td>
        <pre class="source">SLIST_HEADER InterruptObjectPool;</pre>
        </td>
        <td>6.2 and higher </td>
        <td>previously at 0x34B8 </td>
      </tr>
      <tr>
        <td>0x3F60 (6.3) </td>
        <td>
        <pre class="source">ULONG SharedReadyQueueOffset;</pre>
        </td>
        <td>6.3 only </td>
        <td>&nbsp;</td>
      </tr>
      <tr>
        <td>0x3FE0 (1703); <br>
        0x4020 (1709 to 1903); <br>
        0x4060 </td>
        <td>
        <pre class="source">PVOID *DpcWatchdogProfile;</pre>
        </td>
        <td>1703 and higher </td>
        <td>&nbsp;</td>
      </tr>
      <tr>
        <td>0x3FE4 (1703); <br>
        0x4024 (1709 to 1903); <br>
        0x4064 </td>
        <td>
        <pre class="source">PVOID *DpcWatchdogProfileCurrentEmptyCapture;</pre>
        </td>
        <td>1703 and higher </td>
        <td>&nbsp;</td>
      </tr>
      <tr>
        <td rowspan="5">0x3F18 (6.2); <br>
        0x3F64 (6.3); <br>
        0x3FE0 (10.0 to 1607); <br>
        0x3FE8 (1703); <br>
        0x4028 (1709 to 1903); <br>
        0x4068 </td>
        <td>
        <pre class="source">ULONG PrcbPad92 [8];</pre>
        </td>
        <td>6.2 only </td>
        <td>&nbsp;</td>
      </tr>
      <tr>
        <td>
        <pre class="source">ULONG PrcbPad92 [2];</pre>
        </td>
        <td>6.3 only </td>
        <td>&nbsp;</td>
      </tr>
      <tr>
        <td>
        <pre class="source">ULONG PrcbPad92 [3];</pre>
        </td>
        <td>10.0 to 1607 </td>
        <td>&nbsp;</td>
      </tr>
      <tr>
        <td>
        <pre class="source">ULONG PrcbPad92 [1];</pre>
        </td>
        <td>1703 to 1709 </td>
        <td>&nbsp;</td>
      </tr>
      <tr>
        <td>
        <pre class="source">ULONG PackageId;</pre>
        </td>
        <td>1903 and higher </td>
        <td>&nbsp;</td>
      </tr>
      <tr>
        <td>0x3F6C (6.3); <br>
        0x3FEC (10.0 to 1703); <br>
        0x402C (1709 to 1903); <br>
        0x406C </td>
        <td>
        <pre class="source">ULONG PteBitCache;</pre>
        </td>
        <td>6.3 and higher </td>
        <td>&nbsp;</td>
      </tr>
      <tr>
        <td>0x3F70 (6.3); <br>
        0x3FF0 (10.0 to 1703); <br>
        0x4030 (1709 to 1903); <br>
        0x4070 </td>
        <td>
        <pre class="source">ULONG PteBitOffset;</pre>
        </td>
        <td>6.3 and higher </td>
        <td>&nbsp;</td>
      </tr>
      <tr>
        <td>0x3F74 (6.3); <br>
        0x3FF4 (10.0 to 1703); <br>
        0x4034 (1709 to 1903); <br>
        0x4074 </td>
        <td>
        <pre class="source">ULONG PrcbPad93;</pre>
        </td>
        <td>6.3 and higher </td>
        <td>&nbsp;</td>
      </tr>
      <tr>
        <td>0x3F38 (6.2); <br>
        0x3F78 (6.3); <br>
        0x3FF8 (10.0 to 1703); <br>
        0x4038 (1709 to 1903); <br>
        0x4078 </td>
        <td>
        <pre class="source"><a href="../../../api/ntexapi/processor_profile_control_area.htm">PROCESSOR_PROFILE_CONTROL_AREA</a> *ProcessorProfileControlArea;</pre>
        </td>
        <td>6.2 and higher </td>
        <td>&nbsp;</td>
      </tr>
      <tr>
        <td>0x3F3C (6.2); <br>
        0x3F7C (6.3); <br>
        0x3FFC (10.0 to 1703); <br>
        0x403C (1709 to 1903); <br>
        0x407C </td>
        <td>
        <pre class="source">PVOID ProfileEventIndexAddress;</pre>
        </td>
        <td>6.2 and higher </td>
        <td>&nbsp;</td>
      </tr>
    </tbody>
  </table>
  <h4>Appended For Windows 7 </h4>
  <table class="Struct">
    <colgroup>
      <col class="Offset"><col class="Definition"><col class="Versions">
    </colgroup>
    <thead>
      <tr>
        <th>Offset </th>
        <th>Definition </th>
        <th>Versions </th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td>0x3540 (6.1); <br>
        0x3F40 (6.2); <br>
        0x3F80 (6.3); <br>
        0x4000 (10.0 to 1703); <br>
        0x4040 (1709 to 1903); <br>
        0x4080 </td>
        <td>
        <pre class="source">KDPC TimerExpirationDpc;</pre>
        </td>
        <td>6.1 and higher </td>
      </tr>
    </tbody>
  </table>
  <p>Windows 7 appends numerous performance counters for synchronisation, but they 
  didn’t stay as separate members for long. </p>
  <table class="Struct">
    <colgroup>
      <col class="Offset"><col class="Definition"><col class="Versions">
    </colgroup>
    <thead>
      <tr>
        <th>Offset </th>
        <th>Definition </th>
        <th>Versions </th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td>0x3560 (6.1) </td>
        <td>
        <pre class="source">ULONG SpinLockAcquireCount;</pre>
        </td>
        <td>6.1 only </td>
      </tr>
      <tr>
        <td>0x3564 (6.1) </td>
        <td>
        <pre class="source">ULONG SpinLockContentionCount;</pre>
        </td>
        <td>6.1 only </td>
      </tr>
      <tr>
        <td>0x3568 (6.1) </td>
        <td>
        <pre class="source">ULONG SpinLockSpinCount;</pre>
        </td>
        <td>6.1 only </td>
      </tr>
      <tr>
        <td>0x356C (6.1) </td>
        <td>
        <pre class="source">ULONG IpiSendRequestBroadcastCount;</pre>
        </td>
        <td>6.1 only </td>
      </tr>
      <tr>
        <td>0x3570 (6.1) </td>
        <td>
        <pre class="source">ULONG IpiSendRequestRoutineCount;</pre>
        </td>
        <td>6.1 only </td>
      </tr>
      <tr>
        <td>0x3574 (6.1) </td>
        <td>
        <pre class="source">ULONG IpiSendSoftwareInterruptCount;</pre>
        </td>
        <td>6.1 only </td>
      </tr>
      <tr>
        <td>0x3578 (6.1) </td>
        <td>
        <pre class="source">ULONG ExInitializeResourceCount;</pre>
        </td>
        <td>6.1 only </td>
      </tr>
      <tr>
        <td>0x357C (6.1) </td>
        <td>
        <pre class="source">ULONG ExReInitializeResourceCount;</pre>
        </td>
        <td>6.1 only </td>
      </tr>
      <tr>
        <td>0x3580 (6.1) </td>
        <td>
        <pre class="source">ULONG ExDeleteResourceCount;</pre>
        </td>
        <td>6.1 only </td>
      </tr>
      <tr>
        <td>0x3584 (6.1) </td>
        <td>
        <pre class="source">ULONG ExecutiveResourceAcquiresCount;</pre>
        </td>
        <td>6.1 only </td>
      </tr>
      <tr>
        <td>0x3588 (6.1) </td>
        <td>
        <pre class="source">ULONG ExecutiveResourceContentionsCount;</pre>
        </td>
        <td>6.1 only </td>
      </tr>
      <tr>
        <td>0x358C (6.1) </td>
        <td>
        <pre class="source">ULONG ExecutiveResourceReleaseExclusiveCount;</pre>
        </td>
        <td>6.1 only </td>
      </tr>
      <tr>
        <td>0x3590 (6.1) </td>
        <td>
        <pre class="source">ULONG ExecutiveResourceReleaseSharedCount;</pre>
        </td>
        <td>6.1 only </td>
      </tr>
      <tr>
        <td>0x3594 (6.1) </td>
        <td>
        <pre class="source">ULONG ExecutiveResourceConvertsCount;</pre>
        </td>
        <td>6.1 only </td>
      </tr>
      <tr>
        <td>0x3598 (6.1) </td>
        <td>
        <pre class="source">ULONG ExAcqResExclusiveAttempts;</pre>
        </td>
        <td>6.1 only </td>
      </tr>
      <tr>
        <td>0x359C (6.1) </td>
        <td>
        <pre class="source">ULONG ExAcqResExclusiveAcquiresExclusive;</pre>
        </td>
        <td>6.1 only </td>
      </tr>
      <tr>
        <td>0x35A0 (6.1) </td>
        <td>
        <pre class="source">ULONG ExAcqResExclusiveAcquiresExclusiveRecursive;</pre>
        </td>
        <td>6.1 only </td>
      </tr>
      <tr>
        <td>0x35A4 (6.1) </td>
        <td>
        <pre class="source">ULONG ExAcqResExclusiveWaits;</pre>
        </td>
        <td>6.1 only </td>
      </tr>
      <tr>
        <td>0x35A8 (6.1) </td>
        <td>
        <pre class="source">ULONG ExAcqResExclusiveNotAcquires;</pre>
        </td>
        <td>6.1 only </td>
      </tr>
      <tr>
        <td>0x35AC (6.1) </td>
        <td>
        <pre class="source">ULONG ExAcqResSharedAttempts;</pre>
        </td>
        <td>6.1 only </td>
      </tr>
      <tr>
        <td>0x35B0 (6.1) </td>
        <td>
        <pre class="source">ULONG ExAcqResSharedAcquiresExclusive;</pre>
        </td>
        <td>6.1 only </td>
      </tr>
      <tr>
        <td>0x35B4 (6.1) </td>
        <td>
        <pre class="source">ULONG ExAcqResSharedAcquiresShared;</pre>
        </td>
        <td>6.1 only </td>
      </tr>
      <tr>
        <td>0x35B8 (6.1) </td>
        <td>
        <pre class="source">ULONG ExAcqResSharedAcquiresSharedRecursive;</pre>
        </td>
        <td>6.1 only </td>
      </tr>
      <tr>
        <td>0x35BC (6.1) </td>
        <td>
        <pre class="source">ULONG ExAcqResSharedWaits;</pre>
        </td>
        <td>6.1 only </td>
      </tr>
      <tr>
        <td>0x35C0 (6.1) </td>
        <td>
        <pre class="source">ULONG ExAcqResSharedNotAcquires;</pre>
        </td>
        <td>6.1 only </td>
      </tr>
      <tr>
        <td>0x35C4 (6.1) </td>
        <td>
        <pre class="source">ULONG ExAcqResSharedStarveExclusiveAttempts;</pre>
        </td>
        <td>6.1 only </td>
      </tr>
      <tr>
        <td>0x35C8 (6.1) </td>
        <td>
        <pre class="source">ULONG ExAcqResSharedStarveExclusiveAcquiresExclusive;</pre>
        </td>
        <td>6.1 only </td>
      </tr>
      <tr>
        <td>0x35CC (6.1) </td>
        <td>
        <pre class="source">ULONG ExAcqResSharedStarveExclusiveAcquiresShared;</pre>
        </td>
        <td>6.1 only </td>
      </tr>
      <tr>
        <td>0x35D0 (6.1) </td>
        <td>
        <pre class="source">ULONG ExAcqResSharedStarveExclusiveAcquiresSharedRecursive;</pre>
        </td>
        <td>6.1 only </td>
      </tr>
      <tr>
        <td>0x35D4 (6.1) </td>
        <td>
        <pre class="source">ULONG ExAcqResSharedStarveExclusiveWaits;</pre>
        </td>
        <td>6.1 only </td>
      </tr>
      <tr>
        <td>0x35D8 (6.1) </td>
        <td>
        <pre class="source">ULONG ExAcqResSharedStarveExclusiveNotAcquires;</pre>
        </td>
        <td>6.1 only </td>
      </tr>
      <tr>
        <td>0x35DC (6.1) </td>
        <td>
        <pre class="source">ULONG ExAcqResSharedWaitForExclusiveAttempts;</pre>
        </td>
        <td>6.1 only </td>
      </tr>
      <tr>
        <td>0x35E0 (6.1) </td>
        <td>
        <pre class="source">ULONG ExAcqResSharedWaitForExclusiveAcquiresExclusive;</pre>
        </td>
        <td>6.1 only </td>
      </tr>
      <tr>
        <td>0x35E4 (6.1) </td>
        <td>
        <pre class="source">ULONG ExAcqResSharedWaitForExclusiveAcquiresShared;</pre>
        </td>
        <td>6.1 only </td>
      </tr>
      <tr>
        <td>0x35E8 (6.1) </td>
        <td>
        <pre class="source">ULONG ExAcqResSharedWaitForExclusiveAcquiresSharedRecursive;</pre>
        </td>
        <td>6.1 only </td>
      </tr>
      <tr>
        <td>0x35EC (6.1) </td>
        <td>
        <pre class="source">ULONG ExAcqResSharedWaitForExclusiveWaits;</pre>
        </td>
        <td>6.1 only </td>
      </tr>
      <tr>
        <td>0x35F0 (6.1) </td>
        <td>
        <pre class="source">ULONG ExAceResSharedWaitForExclusiveNotAcquires;</pre>
        </td>
        <td>6.1 only </td>
      </tr>
      <tr>
        <td>0x35F4 (6.1) </td>
        <td>
        <pre class="source">ULONG ExSetResOwnerPointerExclusive;</pre>
        </td>
        <td>6.1 only </td>
      </tr>
      <tr>
        <td>0x35F8 (6.1) </td>
        <td>
        <pre class="source">ULONG ExSetResOwnerPointerSharedNew;</pre>
        </td>
        <td>6.1 only </td>
      </tr>
      <tr>
        <td>0x35FC (6.1) </td>
        <td>
        <pre class="source">ULONG ExSetResOwnerPointerSharedOld;</pre>
        </td>
        <td>6.1 only </td>
      </tr>
      <tr>
        <td>0x3600 (6.1) </td>
        <td>
        <pre class="source">ULONG ExTryToAcqExclusiveAttempts;</pre>
        </td>
        <td>6.1 only </td>
      </tr>
      <tr>
        <td>0x3604 (6.1) </td>
        <td>
        <pre class="source">ULONG ExTryToAcqExclusiveAcquires;</pre>
        </td>
        <td>6.1 only </td>
      </tr>
      <tr>
        <td>0x3608 (6.1) </td>
        <td>
        <pre class="source">ULONG ExBoostExclusiveOwner;</pre>
        </td>
        <td>6.1 only </td>
      </tr>
      <tr>
        <td>0x360C (6.1) </td>
        <td>
        <pre class="source">ULONG ExBoostSharedOwners;</pre>
        </td>
        <td>6.1 only </td>
      </tr>
      <tr>
        <td>0x3610 (6.1) </td>
        <td>
        <pre class="source">ULONG ExEtwSynchTrackingNotificationsCount;</pre>
        </td>
        <td>6.1 only </td>
      </tr>
      <tr>
        <td>0x3614 (6.1) </td>
        <td>
        <pre class="source">ULONG ExEtwSynchTrackingNotificationsAccountedCount;</pre>
        </td>
        <td>6.1 only </td>
      </tr>
    </tbody>
  </table>
  <p>Windows 8 formalises the preceding as one structure and inserts another for 
  file and disk I/O. </p>
  <table class="Struct">
    <colgroup>
      <col class="Offset"><col class="Definition"><col class="Versions">
    </colgroup>
    <thead>
      <tr>
        <th>Offset </th>
        <th>Definition </th>
        <th>Versions </th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td>0x3F60 (6.2); <br>
        0x3FA0 (6.3); <br>
        0x4020 (10.0 to 1703); <br>
        0x4060 (1709 to 1903); <br>
        0x40A0 </td>
        <td>
        <pre class="source">SYNCH_COUNTERS SynchCounters;</pre>
        </td>
        <td>6.2 and higher </td>
      </tr>
      <tr>
        <td>0x4018 (6.2); <br>
        0x4058 (6.3); <br>
        0x40D8 (10.0 to 1703); <br>
        0x4118 (1709 to 1903); <br>
        0x4158 </td>
        <td>
        <pre class="source">FILESYSTEM_DISK_COUNTERS FsCounters;</pre>
        </td>
        <td>6.2 and higher </td>
      </tr>
    </tbody>
  </table>
  <p><span class="alert">TO BE DONE</span> </p>
  <table class="struct">
    <colgroup>
      <col class="Offset"><col class="Definition"><col class="Versions">
      <col class="Remarks">
    </colgroup>
    <thead>
      <tr>
        <th>Offset </th>
        <th>Definition </th>
        <th>Versions </th>
        <th>Remarks </th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td>0x3618 (6.1); <br>
        0x4028 (6.2); <br>
        0x4068 (6.3); <br>
        0x40E8 (10.0 to 1703); <br>
        0x4128 (1709 to 1903); <br>
        0x4168 </td>
        <td>
        <pre class="source">CONTEXT *Context;</pre>
        </td>
        <td>6.1 and higher </td>
        <td>&nbsp;</td>
      </tr>
      <tr>
        <td rowspan="2">0x361C (6.1); <br>
        0x402C (6.2); <br>
        0x406C (6.3); <br>
        0x40EC (10.0 to 1703); <br>
        0x412C (1709 to 1903); <br>
        0x416C </td>
        <td>
        <pre class="source">ULONG ContextFlags;</pre>
        </td>
        <td>6.1 only </td>
        <td>&nbsp;</td>
      </tr>
      <tr>
        <td>
        <pre class="source">ULONG ContextFlagsInit;</pre>
        </td>
        <td>6.2 and higher </td>
        <td>&nbsp;</td>
      </tr>
      <tr>
        <td>0x3620 (6.1); <br>
        0x4030 (6.2); <br>
        0x4070 (6.3); <br>
        0x40F0 (10.0 to 1703); <br>
        0x4130 (1709 to 1903); <br>
        0x4170 </td>
        <td>
        <pre class="source">XSAVE_AREA *ExtendedState;</pre>
        </td>
        <td>6.1 and higher </td>
        <td>last member in 6.1 </td>
      </tr>
    </tbody>
  </table>
  <h4>Appended For Windows 8 </h4>
  <table class="Struct">
    <colgroup>
      <col class="Offset"><col class="Definition"><col class="Versions">
      <col class="Remarks">
    </colgroup>
    <thead>
      <tr>
        <th>Offset </th>
        <th>Definition </th>
        <th>Versions </th>
        <th>Remarks </th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td>0x4034 (6.2); <br>
        0x4074 (6.3); <br>
        0x40F4 (10.0 to 1703); <br>
        0x4134 (1709 to 1903); <br>
        0x4174</td>
        <td>
        <pre class="source">KENTROPY_TIMING_STATE EntropyTimingState;</pre>
        </td>
        <td>6.2 and higher </td>
        <td>last member in 6.2 </td>
      </tr>
    </tbody>
  </table>
  <h4>Appended For Windows 8.1 </h4>
  <table class="Struct">
    <colgroup>
      <col class="Offset"><col class="Definition"><col class="Versions">
      <col class="Remarks">
    </colgroup>
    <thead>
      <tr>
        <th>Offset </th>
        <th>Definition </th>
        <th>Versions </th>
        <th>Remarks </th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td>0x419C (6.3); <br>
        0x421C (10.0 to 1703); <br>
        0x425C (1709 to 1903); <br>
        0x429C </td>
        <td>
        <pre class="source">PVOID IsrStack;</pre>
        </td>
        <td>6.3 and higher </td>
        <td>&nbsp;</td>
      </tr>
      <tr>
        <td>0x41A0 (6.3); <br>
        0x4220 (10.0 to 1703); <br>
        0x4260 (1709 to 1903); <br>
        0x42A0 </td>
        <td>
        <pre class="source"><a href="../../ke_x/kinterrupt.htm">KINTERRUPT</a> *VectorToInterruptObject [0xD0];</pre>
        </td>
        <td>6.3 and higher </td>
        <td>&nbsp;</td>
      </tr>
      <tr>
        <td>0x44E0 (6.3); <br>
        0x4560 (10.0 to 1703); <br>
        0x45A0 (1709 to 1903); <br>
        0x45E0 </td>
        <td>
        <pre class="source">SINGLE_LIST_ENTRY AbSelfIoBoostsList;</pre>
        </td>
        <td>6.3 and higher </td>
        <td>&nbsp;</td>
      </tr>
      <tr>
        <td>0x44E4 (6.3); <br>
        0x4564 (10.0 to 1703); <br>
        0x45A4 (1709 to 1903); <br>
        0x45E4 </td>
        <td>
        <pre class="source">SINGLE_LIST_ENTRY AbPropagateBoostsList;</pre>
        </td>
        <td>6.3 and higher </td>
        <td>&nbsp;</td>
      </tr>
      <tr>
        <td>0x44E8 (6.3); <br>
        0x4568 (10.0 to 1703); <br>
        0x45A8 (1709 to 1903); <br>
        0x45E8 </td>
        <td>
        <pre class="source">KDPC AbDpc;</pre>
        </td>
        <td>6.3 and higher </td>
        <td>last member in 6.3 </td>
      </tr>
    </tbody>
  </table>
  <p>The <span class="member">VectorToInterruptObject</span> array is for interrupt 
  vectors 0x30 to 0xFF inclusive. This is the range that all x86 versions allow 
  for hardware interrupts. </p>
  <h4>Appended For Windows 10 </h4>
  <p>The additions for Windows 10 pad three times, apparently for cache alignment 
  in each case. </p>
  <table class="Struct">
    <colgroup>
      <col class="Offset"><col class="Definition"><col class="Versions">
    </colgroup>
    <thead>
      <tr>
        <th>Offset </th>
        <th>Definition </th>
        <th>Versions </th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td>0x4588 (10.0 to 1703); <br>
        0x45C8 (1709 to 1903); <br>
        0x4608 </td>
        <td>
        <pre class="source">IOP_IRP_STACK_PROFILER IoIrpStackProfilerCurrent;</pre>
        </td>
        <td>10.0 and higher </td>
      </tr>
      <tr>
        <td>0x45DC (10.0 to 1703); <br>
        0x461C (1709 to 1903); <br>
        0x465C </td>
        <td>
        <pre class="source">IOP_IRP_STACK_PROFILER IoIrpStackProfilerPrevious;</pre>
        </td>
        <td>10.0 and higher </td>
      </tr>
      <tr>
        <td>0x4630 (10.0 to 1703); <br>
        0x4670 (1709 to 1903); <br>
        0x46B0 </td>
        <td>
        <pre class="source">KTIMER_EXPIRATION_TRACE TimerExpirationTrace [0x10];</pre>
        </td>
        <td>10.0 and higher </td>
      </tr>
      <tr>
        <td>0x4730 (10.0 to 1703); <br>
        0x4770 (1709 to 1903); <br>
        0x47B0 </td>
        <td>
        <pre class="source">ULONG TimerExpirationTraceCount;</pre>
        </td>
        <td>10.0 and higher </td>
      </tr>
      <tr>
        <td>0x4734 (10.0 to 1703); <br>
        0x4774 (1709 to 1903); <br>
        0x47B4 </td>
        <td>
        <pre class="source">PVOID ExSaPageArray;</pre>
        </td>
        <td>10.0 and higher </td>
      </tr>
      <tr>
        <td>0x4778 (1803 to 1903); <br>
        0x47B8 </td>
        <td>
        <pre class="source">XSAVE_AREA_HEADER *ExtendedSupervisorState;</pre>
        </td>
        <td>1803 and higher </td>
      </tr>
      <tr>
        <td rowspan="2">0x4738 (10.0 to 1703); <br>
        0x4778 (1709); <br>
        0x477C&nbsp;(1803 to 1903); <br>
        0x47BC </td>
        <td>
        <pre class="source">ULONG PrcbPad100 [10];</pre>
        </td>
        <td>10.0 to 1709 </td>
      </tr>
      <tr>
        <td>
        <pre class="source">ULONG PrcbPad100 [9];</pre>
        </td>
        <td>1803 and higher </td>
      </tr>
    </tbody>
  </table>
  <p><span class="alert">TO BE DONE</span> </p>
  <table class="Struct">
    <colgroup>
      <col class="Offset"><col class="Definition"><col class="Versions">
      <col class="Remarks">
    </colgroup>
    <thead>
      <tr>
        <th>Offset </th>
        <th>Definition </th>
        <th>Versions </th>
        <th>Remarks </th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td>0x4760 (10.0 to 1703); <br>
        0x47A0 (1709 to 1903); <br>
        0x47E0 </td>
        <td>
        <pre class="source">KSHARED_READY_QUEUE LocalSharedReadyQueue;</pre>
        </td>
        <td>10.0 and higher </td>
        <td>cache-aligned </td>
      </tr>
      <tr>
        <td>0x4894 (10.0 to 1607) </td>
        <td>
        <pre class="source">UCHAR PrcbPad95 [12];</pre>
        </td>
        <td>10.0 to 1607 </td>
        <td>&nbsp;</td>
      </tr>
    </tbody>
  </table>
  <p>One might wonder, though, at having a cache line for just one pointer: </p>
  <table class="Struct">
    <colgroup>
      <col class="Offset"><col class="Definition"><col class="Versions">
      <col class="Remarks">
    </colgroup>
    <thead>
      <tr>
        <th>Offset </th>
        <th>Definition </th>
        <th>Versions </th>
        <th>Remarks </th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td>0x48A0 (10.0 to 1703); <br>
        0x48E0 (1709 to 1903); <br>
        0x4920 </td>
        <td>
        <pre class="source">REQUEST_MAILBOX *Mailbox;</pre>
        </td>
        <td>10.0 and higher </td>
        <td>cache-aligned </td>
      </tr>
      <tr>
        <td rowspan="2">0x48A4 (10.0 to 1703); <br>
        0x48E4 (1709 to 1903); <br>
        0x4924 </td>
        <td>
        <pre class="source">UCHAR PrcbPad [0x3C];</pre>
        </td>
        <td>10.0 to 1709 </td>
        <td>&nbsp;</td>
      </tr>
      <tr>
        <td>
        <pre class="source">UCHAR PrcbPad [0x05FC];</pre>
        </td>
        <td>1803 and higher </td>
        <td>&nbsp;</td>
      </tr>
    </tbody>
  </table>
  <p>The preceding padding is greatly expanded for Version 1803 so that additions 
  are not just cache-aligned but page-aligned: </p>
  <table class="Struct">
    <colgroup>
      <col class="Offset"><col class="Definition"><col class="Versions">
      <col class="Remarks">
    </colgroup>
    <thead>
      <tr>
        <th>Offset </th>
        <th>Definition </th>
        <th>Versions </th>
        <th>Remarks </th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td>0x4EE0 </td>
        <td>
        <pre class="source">ULONG KernelDirectoryTableBase;</pre>
        </td>
        <td>1803 and higher </td>
        <td>page-aligned </td>
      </tr>
      <tr>
        <td>0x4EE4 </td>
        <td>
        <pre class="source">ULONG EspBaseShadow;</pre>
        </td>
        <td>1803 and higher </td>
        <td>&nbsp;</td>
      </tr>
      <tr>
        <td>0x4EE8 </td>
        <td>
        <pre class="source">ULONG UserEspShadow;</pre>
        </td>
        <td>1803 and higher </td>
        <td>&nbsp;</td>
      </tr>
      <tr>
        <td>0x4EEC </td>
        <td>
        <pre class="source">ULONG ShadowFlags;</pre>
        </td>
        <td>1803 and higher </td>
        <td>&nbsp;</td>
      </tr>
      <tr>
        <td>0x4EF0 </td>
        <td>
        <pre class="source">ULONG UserDS;</pre>
        </td>
        <td>1803 and higher </td>
        <td>&nbsp;</td>
      </tr>
      <tr>
        <td>0x4EF4 </td>
        <td>
        <pre class="source">ULONG UserES;</pre>
        </td>
        <td>1803 and higher </td>
        <td>&nbsp;</td>
      </tr>
      <tr>
        <td>0x4EF8 </td>
        <td>
        <pre class="source">ULONG UserFS;</pre>
        </td>
        <td>1803 and higher </td>
        <td>&nbsp;</td>
      </tr>
      <tr>
        <td>0x4EFC </td>
        <td>
        <pre class="source">PVOID EspIretd;</pre>
        </td>
        <td>1803 and higher </td>
        <td>&nbsp;</td>
      </tr>
      <tr>
        <td>0x4F00 </td>
        <td>
        <pre class="source">ULONG RestoreSegOption;</pre>
        </td>
        <td>1803 and higher </td>
        <td>&nbsp;</td>
      </tr>
      <tr>
        <td>0x4F04 </td>
        <td>
        <pre class="source">ULONG SavedEsi;</pre>
        </td>
        <td>1803 and higher </td>
        <td>&nbsp;</td>
      </tr>
      <tr>
        <td>0x4F08 </td>
        <td>
        <pre class="source">USHORT VerwSelector;</pre>
        </td>
        <td>2004 and higher </td>
        <td>&nbsp;</td>
      </tr>
      <tr>
        <td>0x4F0A </td>
        <td>
        <pre class="source">USHORT PrcbShadowPad;</pre>
        </td>
        <td>2004 and higher </td>
        <td>&nbsp;</td>
      </tr>
      <tr>
        <td>0x4F0C </td>
        <td>
        <pre class="source">ULONG TaskSwitchCount;</pre>
        </td>
        <td>2004 and higher </td>
        <td>&nbsp;</td>
      </tr>
      <tr>
        <td>0x4F08 (1803 to 1903); <br>
        0x4F10 </td>
        <td>
        <pre class="source">ULONG DbgLogs [0x0200];</pre>
        </td>
        <td>1803 and higher </td>
        <td>&nbsp;</td>
      </tr>
      <tr>
        <td>0x5708 (1803 to 1903); <br>
        0x5710 </td>
        <td>
        <pre class="source">ULONG DbgCount;</pre>
        </td>
        <td>1803 and higher </td>
        <td>&nbsp;</td>
      </tr>
      <tr>
        <td rowspan="2">0x570C (1803 to 1903); <br>
        0x5714 </td>
        <td>
        <pre class="source">ULONG PrcbPadRemainingPage [0x01F5];</pre>
        </td>
        <td>1803 to 1903 </td>
        <td>&nbsp;</td>
      </tr>
      <tr>
        <td>
        <pre class="source">ULONG PrcbPadRemainingPage [0x01F3];</pre>
        </td>
        <td>2004 and higher </td>
        <td>&nbsp;</td>
      </tr>
    </tbody>
  </table>
  <p>The <span class="member">RequestMailbox</span> array is at the very end so 
  that the kernel can easily provide as many mailboxes as there can ever be processors.
  </p>
  <table class="Struct">
    <colgroup>
      <col class="Offset"><col class="Definition"><col class="Versions">
      <col class="Remarks">
    </colgroup>
    <thead>
      <tr>
        <th>Offset </th>
        <th>Definition </th>
        <th>Versions </th>
        <th>Remarks </th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td>0x48E0 (10.0 to 1703); <br>
        0x4920 (1709); <br>
        0x5EE0 </td>
        <td>
        <pre class="source">REQUEST_MAILBOX RequestMailbox [ANYSIZE_ARRAY];</pre>
        </td>
        <td>10.0 and higher </td>
        <td>cache-aligned; <br>
        page-aligned in 1803 and higher; <br>
        last member in 10.0 and higher </td>
      </tr>
    </tbody>
  </table>
  <div class="Footer">
    <p class="Dates">This page was created on 19th May 2016 but was not published 
    until 14th <a href="../../../../../../../../new/16/11.htm">November 2016</a>. 
    It was last modified on 24th February 2023. </p>
    <!--webbot bot="Include" U-Include="../../../../../_include/c1623.htm" TAG="BODY" startspan -->

<p class="Copyright">Copyright © 2016-2023. Geoff Chappell. All rights reserved. 
<a href="../../../../../../../../about/terms.htm">Conditions apply</a>. </p>

<!--webbot bot="Include" endspan i-checksum="14266" -->
  </div>
</div>

</body>

</html>
